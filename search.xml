<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>怎么找到一个想要的开源项目</title>
    <url>/2024/02/17/howToFindAOpensourceProject/</url>
    <content><![CDATA[<p>本篇文章主要记录本人查找相关开源项目的经验，鉴于本人水平有限，仍在进步中，后续会对本文内容进行进一步的修改与更新。</p>
<span id="more"></span>

<p>在GitHub上存在着许多非常有价值的开源项目以及记录开发者经验的仓库。而开源项目本身可以给我们的学习过程带来一定的参考和帮助。而除此之外，我们也可以通过借鉴或使用这些开源项目来实现我们自己的项目开发。</p>
<p>在此，我觉得非常有必要推荐一个gitbook<a href="https://zhuangbiaowei.gitbook.io/learn-with-open-source/">Learn Coding with Open Source</a>，在这本书里面比较详尽的介绍了怎么去借助开源项目来学习项目的开发（不过里面的有些例子可能有一些过时了，需要结合当前自己的需求进行判断）。</p>
<p>就目前而言，我所倾向于的寻找开源项目的开源社区是GitHub。不过在我们正式去找一个开源项目进行软件架构的分析、项目的复现以及进一步的使用和拓展之前，我们需要确定一下我们的需求和兴趣所在。我们大可以先去搜索引擎查找相关的技术话题或者是说自己希望提升的方向，通过这些大致的话题总结出我们所需要的关键词——这可能比较花费时间，因为我们需要从海量的信息中去查找一些有价值的信息。不过呢，我们也可以去关注一些大牛、科技公司的的博客、公众号和视频号（直接站在巨人的肩膀上好像更省力一点）。甚至还可以去知乎、stackflow这些技术问答网站来请人推荐几个项目…</p>
<p>不过，在上面的gitbook也谈到了,</p>
<blockquote>
<p>“github中有人总结过各个语言在不同的应用方向上值得推荐的开源项目列表, 即Awesome List. Awesome List不仅可以方便大家找到优秀的项目进行学习, 还可以让大家方便地找到各种已有的轮子来进行开发”</p>
</blockquote>
<table>
<thead>
<tr>
<th>语言&#x2F;平台</th>
<th>Awesome List 地址</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td><a href="https://github.com/akullpp/awesome-java">awesome-java</a></td>
</tr>
<tr>
<td>c++</td>
<td><a href="https://github.com/fffaraz/awesome-cpp">awesome-cpp</a></td>
</tr>
<tr>
<td>python</td>
<td><a href="https://github.com/vinta/awesome-python">awesome-python</a></td>
</tr>
<tr>
<td>go</td>
<td><a href="https://github.com/avelino/awesome-go">awesome-go</a></td>
</tr>
<tr>
<td>javascript(浏览器)</td>
<td><a href="https://github.com/sorrycc/awesome-javascript">awesome-javascript</a></td>
</tr>
<tr>
<td>nodejs</td>
<td><a href="https://github.com/sindresorhus/awesome-nodejs">awesome-nodejs</a></td>
</tr>
<tr>
<td>.net</td>
<td><a href="https://github.com/quozd/awesome-dotnet">awesome-dotnet</a></td>
</tr>
<tr>
<td>.net core</td>
<td><a href="https://github.com/thangchung/awesome-dotnet-core">awesome-dotnet-core</a></td>
</tr>
<tr>
<td>ruby</td>
<td><a href="https://github.com/markets/awesome-ruby">awesome-ruby</a></td>
</tr>
<tr>
<td>php</td>
<td><a href="https://github.com/ziadoz/awesome-php">awesome-php</a></td>
</tr>
<tr>
<td>rust</td>
<td><a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a></td>
</tr>
<tr>
<td>dart</td>
<td><a href="https://github.com/yissachar/awesome-dart">awesome-dart</a></td>
</tr>
<tr>
<td>ios(Objective-C和swift)</td>
<td><a href="https://github.com/vsouza/awesome-ios">awesome-ios</a></td>
</tr>
<tr>
<td>android</td>
<td><a href="https://github.com/snowdream/awesome-android">awesome-android</a></td>
</tr>
</tbody></table>
<p>除此之外也有一些近期热门的项目有必要供我们了解。<br><a href="https://github.com/OpenGithubs/weekly">Github开源项目精选周刊</a></p>
<p>除了这些，还有一些关键词如“项目”，“每周”等，就可以让我们找到一些大陆工程师们实现或推荐的项目或资讯。</p>
<h1 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h1><p>而以下则是一个寻找开源项目的例子的记录。在这个例子中，我需要完成基于数据湖、向量数据库、索引技术和领域大模型的一个项目。所以，我首先希望去查找一些较为成熟或是具有参考价值的项目，从而形成我对于项目实际开发的技术路线的思考。</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记1——操作系统结构</title>
    <url>/2024/06/21/note1/</url>
    <content><![CDATA[<h1 id="操作系统笔记1——操作系统结构"><a href="#操作系统笔记1——操作系统结构" class="headerlink" title="操作系统笔记1——操作系统结构"></a>操作系统笔记1——操作系统结构</h1><h2 id="1-操作系统的定义"><a href="#1-操作系统的定义" class="headerlink" title="1. 操作系统的定义"></a>1. 操作系统的定义</h2><p>什么是OS？从操作系统扮演的角色来看，它是一个处于APP和硬件之间的软件系统，扮演了一个中间人的角色。</p>
<p>从<strong>用户</strong>的角度来看，操作系统是一个控制程序，为用户提供一个<strong>方便</strong>且<strong>高效</strong>的操作环境。</p>
<p>从<strong>硬件</strong>的角度来看，操作系统是一个资源管理器，它管理着计算机的硬件资源。</p>
<h2 id="2-计算机系统的组成"><a href="#2-计算机系统的组成" class="headerlink" title="2. 计算机系统的组成"></a>2. 计算机系统的组成</h2><p>在硬盘上有一个 <code>boot sector</code>，当计算机启动时，BIOS会将这个 <code>boot sector</code> 加载到内存中。这个 <code>boot sector</code> 里面有一个MBR（Master Boot Record），MBR 里面有一个引导程序，这个引导程序会加载操作系统的内核。</p>
<p>而在操作系统启动后，会等待 <strong>随机事件(Random Event)</strong> 的发生，当随机事件发生时，操作系统会调用相应的<strong>中断</strong>处理程序。这些随机事件包括：时钟中断、硬件中断、软件中断等。</p>
<p><strong>存储系统</strong>，包括易失性的内存和非易失性的硬盘。<br>操作系统还包括<strong>I&#x2F;O设备的管理</strong>，包括键盘、鼠标、显示器、打印机等。</p>
<h2 id="3-计算机系统的体系结构"><a href="#3-计算机系统的体系结构" class="headerlink" title="3. 计算机系统的体系结构"></a>3. 计算机系统的体系结构</h2><ol>
<li>单核系统</li>
<li>多核系统</li>
<li>分布式系统<ol>
<li>LAN</li>
<li>WAN</li>
<li>SAN(Storage Area Network)</li>
</ol>
</li>
</ol>
<h2 id="4-操作系统的结构"><a href="#4-操作系统的结构" class="headerlink" title="4. 操作系统的结构"></a>4. 操作系统的结构</h2><ol>
<li>多道程序设计</li>
<li>分时系统</li>
</ol>
<p>CPU调度-&gt;交换-&gt;虚拟内存-&gt;硬盘</p>
<p>文件-&gt;同步&#x2F;异步（&#x3D;随机）-&gt;死锁</p>
<h2 id="5-操作系统的服务"><a href="#5-操作系统的服务" class="headerlink" title="5. 操作系统的服务"></a>5. 操作系统的服务</h2><ul>
<li>用户和应用程序</li>
<li>User Interface<br>  GUI&#x2F;Batch&#x2F;Shell(Command Line Interface)</li>
<li>系统调用(System Call)</li>
<li>内核服务(Kernel Service)<br>  程序执行&#x2F;I&#x2F;O操作&#x2F;文件系统&#x2F;进程管理&#x2F;内存管理&#x2F;网络管理&#x2F;进程通信&#x2F;资源分配&#x2F;错误检测&#x2F;保护和安全</li>
<li>硬件设备</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">User -&gt; GUIAndBatchAndShell: User Interface</span><br><span class="line">GUIAndBatchAndShell -&gt; SystemCall: System Call</span><br><span class="line">SystemCall -&gt; KernelService: Kernel Service</span><br><span class="line">KernelService -&gt; Hardware: Hardware</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h3 id="5-1-User-Interface"><a href="#5-1-User-Interface" class="headerlink" title="5.1 User Interface"></a>5.1 User Interface</h3><p>几乎所有的操作系统都有一个用户接口(UI)，用户通过UI与操作系统进行交互。</p>
<ul>
<li>GUI</li>
<li>Batch<br>  支持批处理作业，由原来的顺序执行，到可以有条件执行、循环执行、并行执行等。</li>
<li>Shell&#x2F;CLI</li>
</ul>
<h3 id="5-2-System-Call"><a href="#5-2-System-Call" class="headerlink" title="5.2 System Call"></a>5.2 System Call</h3><p><strong>系统调用</strong>提供了访问和使用操作系统所提供的服务的接口。它的实现代码是操作系统级的，这个接口通常面向程序员。</p>
<p>而**API(Application Programming Interface)**是面向应用程序的，它是由系统调用构建的。一般而言，API是指明了函数的参数和返回值的一组函数。开发人员往往通过API间接的调用系统调用。</p>
<h4 id="双重模式"><a href="#双重模式" class="headerlink" title="双重模式"></a>双重模式</h4><p>现代计算机系统有一个特殊硬件用来划分系统的运行状态，至少有两种运行状态：</p>
<ul>
<li><strong>用户态(User Mode)</strong>:执行用户代码</li>
<li><strong>内核态(Kernel Mode)</strong>:执行操作系统代码</li>
</ul>
<p>目的是确保操作系统的正确执行。</p>
<p>实现方式：用一个硬件模式位来区分用户态和内核态，当硬件检测到一个特殊的指令时，会切换到内核态。0表示内核态，1表示用户态。</p>
<h4 id="运行模式的切换"><a href="#运行模式的切换" class="headerlink" title="运行模式的切换"></a>运行模式的切换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">User -&gt; SystemCall: System Call</span><br><span class="line">SystemCall -&gt; Kernel: Kernel Mode</span><br><span class="line">Kernel -&gt; User: User Mode</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">App</span><br><span class="line">----&gt;---&gt;System Call    </span><br><span class="line">          |             ^</span><br><span class="line">          |Trap         |Return</span><br><span class="line">          v             |</span><br><span class="line">       Kernel----&gt;System Code</span><br></pre></td></tr></table></figure>

<p>从用户态切换到内核态也叫做<strong>陷入</strong>，从内核态切换到用户态也叫做<strong>返回</strong>。</p>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul>
<li>每个系统调用都有一个唯一的编号，这个编号被传递给操作系统，操作系统根据这个编号来调用相应的服务。这个编号也被称为<strong>系统调用号</strong>。</li>
<li>用户代码调用API时，会像系统调用接口指明系统调用号，然后操作系统会根据这个号去索引表中检索系统调用代码在内核中的位置。——类似中断向量表。</li>
</ul>
<h2 id="6-操作系统的构建方式"><a href="#6-操作系统的构建方式" class="headerlink" title="6. 操作系统的构建方式"></a>6. 操作系统的构建方式</h2><h3 id="操作系统的设计思路"><a href="#操作系统的设计思路" class="headerlink" title="操作系统的设计思路"></a>操作系统的设计思路</h3><ul>
<li>设计目标<ul>
<li>用户目标</li>
<li>系统目标</li>
</ul>
</li>
<li>机制与策略<ul>
<li>机制：如何做</li>
<li>策略：做什么</li>
<li>微内核操作系统</li>
<li>联想到策略模式</li>
</ul>
</li>
</ul>
<h2 id="7-GNU-Linux系统的结构"><a href="#7-GNU-Linux系统的结构" class="headerlink" title="7. GNU&#x2F;Linux系统的结构"></a>7. GNU&#x2F;Linux系统的结构</h2><h3 id="开源操作系统"><a href="#开源操作系统" class="headerlink" title="开源操作系统"></a>开源操作系统</h3><p>开源、闭源、混合式(hybrid)</p>
<p>源代码与二进制代码</p>
<p><img src="/images/note1-1719040438862.png" alt="图 1">  </p>
<blockquote>
<p>GNU -&gt; GNU is Not Unix</p>
</blockquote>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>os_lab_1</title>
    <url>/2024/02/15/os-lab-1/</url>
    <content><![CDATA[<h1 id="Lab-Xv6-and-Unix-utilities"><a href="#Lab-Xv6-and-Unix-utilities" class="headerlink" title="Lab: Xv6 and Unix utilities"></a>Lab: Xv6 and Unix utilities</h1><p>本文章主要记录操作系统课程6.S081的实验1过程，该实验主要帮助熟悉xv6以及系统调用。</p>
<span id="more"></span>

<h2 id="启动xv6"><a href="#启动xv6" class="headerlink" title="启动xv6"></a>启动xv6</h2><blockquote>
<p>easy</p>
</blockquote>
<p>本实验一开始配置环境按照2020版的说明在ubantu虚拟机上进行，但是由于2024年xv6的toolchain和qemu版本的变更问题，编译后不能正常执行和启动（包括配置文件属性更改、虚拟磁盘无法正常加载等等），同时编译该环境的资源需求也非常庞大（toolchain有将近10G的文件）。最后还是选择放弃了该方案，而是选择了采用WSL+VScode+ubantu20.04LTS进行实验，后者的资源需求明显降低，并且采用vscode进行实验在操作上会更为简便。</p>
<p>使用vscode在终端输入以下命令安装工具包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure>

<p>在实验开始之前，需要获取xv6的源文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/mit-pdos/xv6-riscv.git</span><br></pre></td></tr></table></figure>

<p>也可以获取如下的源文件（我采用的是xv6-labs-2020的版本）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br></pre></td></tr></table></figure>

<p>然后进入对应目录切换到对应分支：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">git checkout util</span><br></pre></td></tr></table></figure>

<p>然后我们可以通过以下命令构建并运行xv6：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/xv6-labs-2020$ make qemu</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>而如果我们在提示符$后输入<code>ls</code>，我们可以看到以下类似的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2059</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 23896</span><br><span class="line"><span class="built_in">echo</span>           2 5 22728</span><br><span class="line">forktest       2 6 13080</span><br><span class="line">grep           2 7 27248</span><br><span class="line">init           2 8 23824</span><br><span class="line"><span class="built_in">kill</span>           2 9 22696</span><br><span class="line"><span class="built_in">ln</span>             2 10 22648</span><br><span class="line"><span class="built_in">ls</span>             2 11 26128</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 22792</span><br><span class="line"><span class="built_in">rm</span>             2 13 22784</span><br><span class="line">sh             2 14 41664</span><br><span class="line">stressfs       2 15 23800</span><br><span class="line">usertests      2 16 147440</span><br><span class="line">grind          2 17 37912</span><br><span class="line"><span class="built_in">wc</span>             2 18 25032</span><br><span class="line">zombie         2 19 22192</span><br><span class="line">console        3 20 0</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p>xv6中没有<code>ps</code>命令，不过我们可以按下<code>Ctrl</code>&amp;<code>p</code>，然后内核就会打印出每个进程的信息。而如果需要退出，我们可以按下<code>Ctrl</code>&amp;<code>p</code>+<code>x</code>。</p>
<p>我们可以运行<code>make grade</code>来用评分程序测试我们的解决方案。</p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><blockquote>
<p>easy</p>
</blockquote>
<p>实验要求：</p>
<blockquote>
<p>Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>
</blockquote>
<p>这个功能的实现即调用系统函数<code>sleep</code>来实现用户函数<code>sleep</code>，主要就是供我们熟悉怎么去在这个xv6环境下写代码。不过，我们并不能去调用标准的C库，我们所有能够调用的系统函数都在<code>user/user.h</code>中。而实现这个功能并不难，只需要调用系统函数即可，需要注意的是补全我们的提示信息。</p>
<p>以下为<code>sleep.c</code>的实现。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;kernel/types.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;user/user.h&quot;</span></span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  char *arg_ticks;</span><br><span class="line">  int ticks;</span><br><span class="line">  int ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc != 2)&#123;</span><br><span class="line">    fprintf(2, <span class="string">&quot;usage: sleep [ticks num]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(1);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  arg_ticks = argv[1];</span><br><span class="line">  ticks = atoi(arg_ticks);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">sleep</span>(ticks);</span><br><span class="line">  <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为测试结果(需要注意的是，我们首先要把<code>sleep</code>添加到Makefile的<code>UPROGS</code>中)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lee@lazybear:~/xv6-labs-2020$ ./grade-lab-util <span class="built_in">sleep</span></span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test <span class="built_in">sleep</span>, no arguments == <span class="built_in">sleep</span>, no arguments: OK (0.6s) </span><br><span class="line">    (Old xv6.out.sleep_no_args failure <span class="built_in">log</span> removed)</span><br><span class="line">== Test <span class="built_in">sleep</span>, returns == <span class="built_in">sleep</span>, returns: OK (1.0s) </span><br><span class="line">== Test <span class="built_in">sleep</span>, makes syscall == <span class="built_in">sleep</span>, makes syscall: OK (1.0s) </span><br><span class="line">    (Old xv6.out.sleep failure <span class="built_in">log</span> removed)</span><br></pre></td></tr></table></figure>

<h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><blockquote>
<p>easy</p>
</blockquote>
<p>实验要求：</p>
<blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p>
</blockquote>
<p>这一部分实验实现主要参考xv6-book的第一章管道部分。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;kernel/types.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;user/user.h&quot;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  int p1[2]; // parent2child</span><br><span class="line">  int p2[2]; // child2parent</span><br><span class="line">  char buf[] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">  int pid;</span><br><span class="line"></span><br><span class="line">  // Create pipes</span><br><span class="line">  pipe(p1);</span><br><span class="line">  pipe(p2);</span><br><span class="line"></span><br><span class="line">  // fork and ping-pong between parent and child.</span><br><span class="line">  <span class="keyword">if</span> (fork() == 0) &#123;</span><br><span class="line">    // child</span><br><span class="line">    pid = getpid();</span><br><span class="line">    close(p1[1]);</span><br><span class="line">    close(p2[0]);</span><br><span class="line">    <span class="built_in">read</span>(p1[0], buf, 1); // Read 1 byte of data from p1 into buf.</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">    write(p2[1], buf, 1);</span><br><span class="line">    <span class="built_in">exit</span>(0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // parent</span><br><span class="line">    pid = getpid();</span><br><span class="line">    close(p2[1]);</span><br><span class="line">    close(p1[0]);</span><br><span class="line">    write(p1[1], buf, 1); // Write 1 byte of data from buf into p1 and child will <span class="built_in">read</span>.</span><br><span class="line">    <span class="built_in">wait</span>((int *) <span class="number">0</span>); // Wait for the child process to finish</span><br><span class="line">    printf(&quot;%d: received pong\n&quot;, pid);</span><br><span class="line">    read(p2[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将pingpong加入Makefile后测试结果如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lee@lazybear:~/xv6-labs-2020$ ./grade-lab-util pingpong</span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test pingpong == pingpong: OK (0.9s) </span><br></pre></td></tr></table></figure>

<h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><blockquote>
<p><em><strong>hard</strong></em></p>
</blockquote>
<p>实验要求：</p>
<blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<blockquote>
<p>您的目标是使用<code>pipe</code>和<code>fork</code>来设置管道。第一个进程将数字2到35输入到管道中。对于每个素数，您将安排创建一个进程，该进程通过一个管道从其左邻居读取，并通过另一个管道向其右邻居写入。由于xv6具有有限数量的文件描述符和进程，因此第一个进程可以在35处停止。</p>
</blockquote>
<p>实验中需要注意的点是：</p>
<ul>
<li>关闭进程不必要的文件描述符</li>
<li>一旦第一个进程达到35，它就应该等待，直到整个管道终止，包括所有的子进程、孙进程等等。因此，主素数进程应该只在打印完所有输出之后以及所有其他素数进程退出之后才退出。</li>
<li>当写侧管道关闭时，<code>read</code>返回0。</li>
</ul>
<p>这个实验涉及到了一个质数筛选算法——素数筛法，是一种快速“筛”出2~n之间所有素数的方法。朴素的筛法叫埃氏筛（the Sieve ofEratosthenes，埃拉托色尼筛）。这个算法可以具体去看<a href="https://zhuanlan.zhihu.com/p/100051075">知乎文章——算法学习笔记(17): 素数筛</a>。</p>
<p>这个算法最朴素的实现代码如下；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isnp[MAXN]; <span class="comment">// is not prime: 不是素数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">                isnp[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而回到我们需要完成的题目，其实更像是完成一个欧式筛，我们通过创建进程维护了一个质数表，每一个进程对应一个已经经过检验的质数，它首先会打印这个质数，然后会通过管道不断接受来自左手边进程的数字，如果数字为自己质数的倍数，就筛掉它，否则就fork创建一个新进程，然后把这个数字（即质数）传给新进程。需要注意的是，每个进程都需要等待它的子进程结束才可以退出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sieve</span><span class="params">(<span class="type">int</span> read_fd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> prime = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> passed_num;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> forked = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pipes[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    n = read(read_fd, &amp;passed_num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">      close(read_fd);</span><br><span class="line">      <span class="keyword">if</span>(forked)&#123;</span><br><span class="line">        close(pipes[<span class="number">1</span>]); <span class="comment">//关闭写端通道，告诉子进程没有数传递过来了</span></span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prime==<span class="number">0</span>)&#123;</span><br><span class="line">      prime = passed_num;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数是否是本进程素数的倍数</span></span><br><span class="line">    <span class="keyword">if</span> (passed_num % prime != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!forked) &#123;</span><br><span class="line">        pipe(pipes);</span><br><span class="line">        forked = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ret = fork();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// child</span></span><br><span class="line">          close(pipes[<span class="number">1</span>]);</span><br><span class="line">          close(read_fd);</span><br><span class="line">          sieve(pipes[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// parent</span></span><br><span class="line">          close(pipes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 传递数到右进程</span></span><br><span class="line">      write(pipes[<span class="number">1</span>], &amp;passed_num, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">    write(fd[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(fd[<span class="number">1</span>]);  <span class="comment">// 关闭写端管道</span></span><br><span class="line"></span><br><span class="line">  sieve(fd[<span class="number">0</span>]);  <span class="comment">// 启动第一个素数筛进程</span></span><br><span class="line"></span><br><span class="line">  close(fd[<span class="number">0</span>]);  <span class="comment">// 关闭读端管道</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><blockquote>
<p><em><strong>moderate</strong></em></p>
</blockquote>
<p>实验要求：</p>
<blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<p>本题需要以下几个方法：读取目录、通过递归进入子目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">char</span> *pathname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *prev = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *curr = <span class="built_in">strchr</span>(pathname, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = <span class="built_in">strchr</span>(curr + <span class="number">1</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *currname;</span><br><span class="line">        <span class="type">int</span> match;</span><br><span class="line"></span><br><span class="line">        currname = basename(path);</span><br><span class="line">        match = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(currname, filename))</span><br><span class="line">            match = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (match)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">    &#123;</span><br><span class="line">        uint curr_path_len;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        curr_path_len = <span class="built_in">strlen</span>(path);</span><br><span class="line">        <span class="built_in">memcpy</span>(buf, path, curr_path_len);</span><br><span class="line">        buf[curr_path_len] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        p = buf + curr_path_len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">                <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">            find(buf, filename); <span class="comment">// recurse</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find [directory] [target filename]\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
        <category>Lab</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Lab</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081-note-lec1</title>
    <url>/2024/02/15/6.S081-note-lec1/</url>
    <content><![CDATA[<p>本篇文章为对xv6-book-rev2的第一章的阅读笔记(主要内容为rev2的翻译理解)以及针对6.S081-2020-Lec1的笔记。</p>
<span id="more"></span>

<h1 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h1><p>操作系统的工作包括将计算机资源分享给多个程序，并提供比硬件本身支持更有用的服务。它管理和抽象底层的硬件，使应用程序无需关心使用的是哪种类型的磁盘硬件。然后，操作系统将硬件资源分享给多个程序，使它们能够同时运行或表现出同时运行的状态。最后，操作系统提供受限的方式让程序进行交互，以便它们能够共享数据或共同工作。</p>
<p>操作系统通过接口向用户程序提供服务。设计一个好的接口是困难的，一方面，我们希望接口简单且窄，因为这样更容易使得我们的实现是正确的；另一方面，我们可能会倾向于为应用程序提供许多复杂的功能。而解决这种紧张关系的诀窍就在于设计一些依赖于少量机制的接口，而这些机制可以组合在一起提供很多的通用性。</p>
<p><img src="/images/fig1.1.png" alt="fig1.1"></p>
<p>xv6采用了传统的内核(kernel)形式——为程序运行提供服务的一种特殊程序。而每个运行中的程序——即进程，它有包含了指令、数据和栈的一片内存。指令实现了程序的计算过程，而数据就是程序执行过程中的那些变量。对于栈来说，它实际上是用来将程序的存储过程调用组织起来。一般而言，一个计算机有多个进程而只有一个内核。</p>
<p>当进程需要调用内核服务时，它会调用系统调用，即操作系统接口中的一个调用。系统调用进入内核；内核执行服务并返回。因此，进程在用户空间和内核空间中交替执行。而对于用户程序而言，它们仅能看到内核所提供的系统调用接口，而无法看到这些接口的实现细节。如下为xv6所实现的系统调用：</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的PID</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，并将状态报告给wait()函数。无返回</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止对应PID的进程，返回0，或返回-1表示错误</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的PID</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停n个时钟节拍</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载一个文件并使用参数执行它; 只有在出错时才返回</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>按n 字节增长进程的内存。返回新内存的开始</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开一个文件；flags表示read&#x2F;write；返回一个fd(文件描述符)</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从buf 写n 个字节到文件描述符fd; 返回n</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>释放打开的文件fd</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与fd 相同的文件</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，把read&#x2F;write文件描述符放在p[0]和p[1]中</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>改变当前的工作目录</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将打开文件fd的信息放入*st</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将指定名称的文件信息放入*st</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件file1创建另一个名称(file2)</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除一个文件</td>
</tr>
</tbody></table>
<p>​		表1.2：xv6系统调用(除非另外声明，这些系统调用返回0表示无误，返回-1表示出错)</p>
<p>另外，shell是一个用于读入用户命令并执行的程序，它是用户程序而非内核的一部分。xv6 shell是Unix Bourne shell的一个简单实现。它的实现可以在(<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L1">user&#x2F;sh.c:1</a>)中找到。</p>
<h2 id="1-进程与内存-Processes-and-memory"><a href="#1-进程与内存-Processes-and-memory" class="headerlink" title="1. 进程与内存(Processes and memory)"></a>1. 进程与内存(Processes and memory)</h2><p>一个xv6的进程由用户空间内存(指令、数据和栈)以及每个进程对内核私有的状态组成。Xv6在时间上共享进程：它在等待执行的一组进程之间透明地切换可用的CPU。当进程未执行时，xv6会保存其CPU寄存器，并在下次运行进程时恢复这些寄存器。内核将进程标识符(<strong>PID</strong>)与每个进程相关联。</p>
<p>在xv6中，一个进程可以使用<code>fork</code>来创建一个新的进程。正如Lec1中讲到的，<code>fork</code>所创建的新进程有着和原进程相同的内存内容，而<code>fork</code>也会在两个进程中返回。不过<code>fork</code>在原进程中返回新进程的PID，在新进程中返回0。原进程和新进程也被叫做父进程和子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，代码首先执行<code>int pid = fork();</code>，这是一个创建子进程的系统调用。<code>fork()</code>函数会创建一个新的进程，该进程是原始进程(称为父进程)的副本。在父进程中，<code>fork()</code>函数返回子进程的进程ID(PID)，而在子进程中，它返回0。接下来，代码检查pid的值，以确定当前是父进程还是子进程。<strong>如果pid &gt; 0</strong>，则表示当前为父进程。父进程会打印一条消息，指示其子进程的PID，并使用<code>wait()</code>函数等待子进程完成。<code>wait()</code>函数使父进程暂停执行，直到子进程终止。一旦子进程终止，父进程会打印一条消息，指示子进程的PID。<strong>如果pid &#x3D;&#x3D; 0</strong>，则表示当前为子进程。子进程会打印一条消息，表示它正在退出，然后调用<code>exit(0)</code>函数正常终止。<strong>如果pid &lt; 0</strong>，则表示<code>fork()</code>调用失败，没有成功创建子进程。这时，代码会打印一条错误消息。</p>
<p>这个例子中有几个需要注意的点：</p>
<ol>
<li><code>exit</code>: <code>exit</code>会造成调用进程停止执行并释放内存和打开的文件等资源。它需要一个整数状态参数，一般而言0表示成果，1表示失败。</li>
<li><code>wait</code>: <code>wait</code>的返回值是一个执行完毕或被杀死的当前进程的子进程的PID，并且会通过传入的参数地址返回子进程的执行状态。不过如果<code>wait</code>没有子进程，那么会当即返回-1。有一个小技巧是，如果不关注子进程执行状态，那么我们可以传入0地址。</li>
<li>尽管最初两个进程具有相同的内存内容，但是实际上它们使用不同的内存和寄存器来执行程序，这也意味着更改一个进程的变量并不会影响到另一个进程的变量。</li>
</ol>
<p>除了上面这个例子所提到的两个系统调用，我们还需要关注到<code>exec</code>——它实际上会用从文件系统中的文件加载的内存镜像替换掉当前调用进程的内存，而这个文件需要具有特定的格式。<code>exec</code>接受两个参数：包含可执行文件的文件名和字符串参数数组。而当<code>exec</code>执行成功时，它并不会返回调用程序，相反，它会从文件加载的指令从ELF头中声明的入口点开始执行。</p>
<p>shell利用了它在IO重定向中实现的隔离特性，为了避免创建重复进程而立即替换掉的浪费，内核通过使用虚拟内存技术(如写时复制)来优化<code>fork</code>的实现。而这也让<code>fork</code>和<code>exec</code>并没有合并在一个调用中。</p>
<p>Xv6隐式分配大多数用户空间内存：<code>fork</code>分配父内存的子副本所需的内存，<code>exec</code>分配足够的内存来保存可执行文件。在运行时需要更多内存的进程(可能是<code>malloc</code>)可以调用<code>sbrk(n)</code>来将其数据内存增加n个字节；<code>sbrk</code>返回新内存的位置。</p>
<h2 id="2-IO与文件描述符-I-O-and-File-descriptors"><a href="#2-IO与文件描述符-I-O-and-File-descriptors" class="headerlink" title="2. IO与文件描述符(I&#x2F;O and File descriptors)"></a>2. IO与文件描述符(I&#x2F;O and File descriptors)</h2><p>文件描述符指的是一个表示由内核管理的用于进程读写对象的整数。而这个文件描述符可以通过打开文件、目录、设备、管道或者复制一个现有的描述符来获得。文件描述符接口使得我们能够抽离文件、管道和设备之间的差别，让它们都变为字节流的形式。而这种输入输出我们也叫做I&#x2F;O。</p>
<p>在内部，xv6内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符的私有空间。按照惯例，进程读取文件描述符0(标准输入)，将输出写入文件描述符1(标准输出)，并将错误消息写入文件描述符2(标准错误)。shell利用协议来实现I&#x2F;O重定向和管道。shell确保始终打开三个文件描述符(<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L151">user&#x2F;sh.c:151</a>)，默认情况下，这三个描述符是控制台的文件描述符。</p>
<p><code>read(fd, buf, n)</code>调用从文件描述符<code>fd</code>中读取最多n字节数据并存入<code>buf</code>中，然后返回读取的字节数。每个文件描述符都有一个与其相关的偏移量。<code>read</code>从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数：后续读取将返回第一次读取返回的字节之后的字节。当没有更多的字节可读取时，<code>read</code>返回零表示文件的结束。</p>
<p><code>write(fd, buf, n)</code>调用将<code>buf</code>中的n个字节写入文件描述符<code>fd</code>，并返回写入的字节数。只有当发生错误时，写入的字节数才少于n个。与读取一样，<code>write</code>以当前文件偏移量写入数据，然后将该偏移量后移写入的字节数：每次写入都会从上一次写入的位置开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>, buf, n) != n)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>close</code>调用释放了一个文件描述符，使其可以自由地供未来的<code>open</code>、<code>pipe</code>或<code>dup</code>重用。新分配的文件描述符总是当前进程中编号最低的未使用描述符。</p>
<p>文件描述符和<code>fork</code>相互作用，使I&#x2F;O重定向易于实现。<code>fork</code>将父级的文件描述符表及其内存一起复制，以便子级从与父级完全相同的打开文件开始。<code>exec</code>替换调用进程的内存，但保留其文件表。这种行为允许shell通过<code>fork</code>、重新打开子级中选定的文件描述符，然后调用<code>exec</code>来运行新程序，从而实现I&#x2F;O重定向。</p>
<p><code>open</code>的第二个参数由一组以位表示的标记组成，这些标记控制打开的操作。可能的值在文件控制(fcntl)头文件<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/fcntl.h#L1-L5">(kernel&#x2F;fcntl.h:1-5)</a>中定义：<strong>O_RDONLY、O_WRONLY、O_2 RDWR、O_CREATE和O_TRUNC</strong>，它们指示打开以打开文件进行读取、写入、同时进行读取和写入、如果文件不存在则创建文件、将文件截断为零长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，子进程与父进程共享偏移量——它们指向的是同一个对象。在上面这个片段中，描述符1对应的文件最终会包含数据<code>hello world</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><code>dup</code>调用复制一个现有的文件描述符，返回一个引用相同底层I&#x2F;O对象的新描述符。两个文件描述符共享一个偏移量，就像<code>fork</code>复制的文件描述符一样。</p>
<p>而如果两个文件描述符是通过一系列<code>fork</code>和<code>dup</code>调用从同一原始文件描述符派生而来，则它们共享一个偏移量。否则，文件描述符不会共享偏移量，即使它们是由对同一文件的打开调用引起的。<code>dup</code>允许shell实现如下命令：<code>ls existing file non-existing file&gt;tmp1 2&gt;&amp;1</code>。<code>2&gt;&amp;1</code>命令告诉shell为命令提供一个文件描述符2，该描述符与描述符1重复。现有文件的名称和不存在文件的错误消息都将显示在文件tmp1中。xv6 shell不支持错误文件描述符的I&#x2F;O重定向。</p>
<p>文件描述符是一个强大的抽象，因为它们隐藏了它们所连接的内容的细节：写入文件描述符1的进程可能是写入文件、控制台等设备或管道。</p>
<h2 id="3-管道-Pipes"><a href="#3-管道-Pipes" class="headerlink" title="3. 管道(Pipes)"></a>3. 管道(Pipes)</h2><p>管道是一种用于进程间通信的通信方式，它是半双工的(单向的)。管道实际上是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。</p>
<p><a href="https://zhuanlan.zhihu.com/p/557052338">一篇介绍管道的文章</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，代码声明了一个整型数组<code>p[2]</code>，用于存储管道的文件描述符。管道需要两个文件描述符，一个用于读取数据，另一个用于写入数据。然后，代码声明了一个字符指针数组<code>argv[2]</code>，用于存储传递给<code>exec</code>的参数。在本例中，<code>argv[0]</code>被设置为字符串<code>&quot;wc&quot;</code>，<code>argv[1]</code>被设置为<code>0（NULL）</code>。接下来，代码调用<code>pipe(p)</code>函数创建了一个管道。<code>pipe()</code>函数会创建一个新的管道，并将两个文件描述符分别存储在<code>p[0]</code>和<code>p[1]</code>中。<code>p[0]</code>用于从管道中读取数据，<code>p[1]</code>用于向管道中写入数据。然后，代码调用<code>fork()</code>函数创建一个子进程。子进程是父进程的副本，包括文件描述符的复制。在子进程中，通过检查<code>fork()</code>的返回值为0来确定当前是子进程。子进程首先关闭标准输入文件描述符0（即关闭标准输入），然后使用<code>dup(p[0])</code>将管道的读取端复制到文件描述符0（即将管道的读取端作为子进程的标准输入），接着关闭不再需要的文件描述符<code>p[0]</code>和<code>p[1]</code>，最后调用<code>exec(&quot;/bin/wc&quot;, argv)</code>来执行wc命令，将管道的输入作为wc命令的输入。在父进程中，通过检查<code>fork()</code>的返回值是否为0来确定当前是父进程。父进程使用<code>write(p[1], &quot;hello world\n&quot;, 12)</code>将字符串<code>&quot;hello world\n&quot;</code>写入管道的写入端，然后关闭不再需要的文件描述符<code>p[0]</code>和<code>p[1]</code>。</p>
<p>这段代码的目的是创建一个管道，并通过将数据写入管道的写入端，然后从管道的读取端读取数据来实现父子进程之间的通信。子进程通过执行wc命令，将从管道读取的数据作为输入，并返回统计信息。需要注意的是，如果数据没有准备好，那么对管道执行的<code>read</code>会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。在后一种情况中，<code>read</code> 会返回 0，就像是一份文件读到了最后。</p>
<p>xv6 shell 对管道的实现（比如 <code>fork sh.c | wc -l</code>）和上面的描述是类似的。子进程创建一个管道连接管道的左右两端。然后它为管道左右两端都调用 <code>runcmd</code>，然后通过两次 wait 等待左右两端结束。管道右端可能也是一个带有管道的指令，如 <code>a | b | c</code>, 它 <code>fork</code> 两个新的子进程（一个 <code>b</code> 一个 <code>c</code>），因此，shell 可能创建出一颗进程树。树的叶子节点是命令，中间节点是进程，它们会等待左子和右子执行结束。理论上，你可以让中间节点都运行在管道的左端，但做的如此精确会使得实现变得复杂。</p>
<p><code>pipe</code> 可能看上去和临时文件没有什么两样：命令</p>
<p><code>echo hello world | wc</code></p>
<p>可以用无管道的方式实现：</p>
<p><code>echo hello world &gt; /tmp/xyz; wc &lt; /tmp/xyz</code></p>
<p>但管道和临时文件起码有三个关键的不同点。</p>
<ol>
<li>首先，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 &#x2F;tmp&#x2F;xyz。</li>
<li>第二，管道可以传输任意长度的数据。</li>
<li>第三，管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 write 完成数据的发送。</li>
</ol>
<h2 id="4-文件系统-File-system"><a href="#4-文件系统-File-system" class="headerlink" title="4. 文件系统(File system)"></a>4. 文件系统(File system)</h2><p>xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。xv6 把目录实现为一种特殊的文件。目录是一棵树，它的根节点是一个特殊的目录 <code>root</code>。<code>/a/b/c</code> 指向一个在目录 <code>b</code> 中的文件 <code>c</code>，而 <code>b</code> 本身又是在目录 <code>a</code> <code>中的，a</code> 又是处在 <code>root</code> 目录下的。不从 <code>/</code> 开始的目录表示的是相对调用进程当前目录的目录，调用进程的当前目录可以通过 <code>chdir</code> 这个系统调用进行改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<p>上面的代码片段中的两个例子都打开了同一个文件，不同的是，第一种方式修改了当前目录。</p>
<p>有很多的系统调用可以创建一个新的文件或者目录：<code>mkdir</code> 创建一个新的目录，<code>open</code> 加上 <code>O_CREATE</code> 标志打开一个新的文件，<code>mknod</code> 创建一个新的设备文件。 <code>mknod</code> 在文件系统中创建一个文件，但是这个文件没有任何内容。相反，这个文件的元信息标志它是一个设备文件，并且记录主设备号和辅设备号（<code>mknod</code> 的两个参数），这两个设备号唯一确定一个内核设备。当一个进程之后打开这个文件的时候，内核将读、写的系统调用转发到内核设备的实现上，而不是传递给文件系统。</p>
<p><code>fstat</code> 可以获取一个文件描述符指向的文件的信息。它填充一个名为 <code>stat</code> 的结构体，它在 <code>stat.h</code> 中定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEV  3</span></span><br><span class="line"><span class="comment">// Directory</span></span><br><span class="line"><span class="comment">// File</span></span><br><span class="line"><span class="comment">// Device</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">       <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">       <span class="type">int</span> dev;     <span class="comment">// File system’s disk device</span></span><br><span class="line">       uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">       <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">       uint size;   <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件名和这个文件本身是有很大的区别。同一个文件（称为 <strong>inode</strong>）可能有多个名字，称为连接 (<strong>links</strong>)。系统调用 <code>link</code> 创建另一个文件系统的名称，它指向同一个 <code>inode</code>。下面的代码创建了一个既叫做 <code>a</code> 又叫做 <code>b</code> 的新文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE|O_WRONGLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>unlink</code> 这个系统调用用于从文件系统移除一个文件名。一个文件的 <code>inode</code> 和磁盘空间只有当它的链接数变为 0 的时候才会被清空，也就是没有一个文件再指向它。因此在上面的代码最后加上<code>unlink(&quot;a&quot;)</code>，我们同样可以通过 b 访问到它。另外，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>是创建一个临时 <code>inode</code> 的最佳方式，这个 <code>inode</code> 会在进程关闭 <code>fd</code> 或者退出的时候被清空。</p>
<p>xv6 关于文件系统的操作都被实现为用户程序，诸如 <code>mkdir</code>，<code>ln</code>，<code>rm</code> 等等。这种设计允许任何人都可以通过用户命令拓展 shell 。现在看起来这种设计是很显然的，但是 Unix 时代的其他系统的设计都将这样的命令内置在了 shell 中，而 shell 又是内置在内核中的。</p>
<p>有一个例外，那就是 <code>cd</code>，它是在 shell 中实现的（8016）。<code>cd</code> 必须改变 shell 自身的当前工作目录。如果 <code>cd</code> 作为一个普通命令执行，那么 shell 就会 <code>fork</code> 一个子进程，而子进程会运行 <code>cd</code>，<code>cd</code> 只会改变子进程的当前工作目录。父进程的工作目录保持原样。</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>6.S081</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记2——进程死锁</title>
    <url>/2024/06/24/note2-3/</url>
    <content><![CDATA[<h1 id="操作系统笔记2——进程死锁"><a href="#操作系统笔记2——进程死锁" class="headerlink" title="操作系统笔记2——进程死锁"></a>操作系统笔记2——进程死锁</h1><blockquote>
<p>了解死锁的定义，掌握死锁预防，了解死锁避免，死锁检测，死锁恢复的方法。</p>
</blockquote>
<h2 id="1-死锁的定义及性质"><a href="#1-死锁的定义及性质" class="headerlink" title="1. 死锁的定义及性质"></a>1. 死锁的定义及性质</h2><h3 id="1-1-死锁的定义"><a href="#1-1-死锁的定义" class="headerlink" title="1.1 死锁的定义"></a>1.1 死锁的定义</h3><ul>
<li>在一个进程集合中，若<strong>每个进程</strong>都在<strong>等待某些事件</strong>（指：释放资源）的发生，而<strong>这些事件又必须由这个进程集合中的某些进程来产生</strong>，就称该进程集合处于死锁状态。</li>
</ul>
<h4 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h4><ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。（存在互斥使用资源的情况）</li>
<li><strong>占有等待条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（一定有占有资源而又等待其它资源的进程）</li>
<li><strong>非抢占（剥夺）条件</strong>：进程已获得的资源，在未使用完之前，不能强行剥夺。（资源只能由进程自己释放，系统中进程占有的资源未主动释放时不可以剥夺 ）</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。（进程集合{P0, P1, ……, Pn}，Pi等待Pi+1，Pn等待P0）</li>
</ul>
<h2 id="2-死锁的处理"><a href="#2-死锁的处理" class="headerlink" title="2. 死锁的处理"></a>2. 死锁的处理</h2><ol>
<li><p>置之不理法：不处理死锁，让系统自生自灭。简单、节约成本但是不够安全。</p>
</li>
<li><p>积极防御法：破坏死锁的四个必要条件之一，从根本上解决死锁问题。</p>
<ul>
<li>静态策略：<strong>进程创建时就由系统分配了所有需要的资源</strong>，然后才执行，并且以后没有资源申请要求。缺点：系统效率低，并发性下降，资源浪费严重。</li>
<li>动态策略：执行时动态改变资源分配策略。缺点：实现复杂。优点：灵活，资源利用率高。</li>
</ul>
</li>
<li><p>事后处理法：检测死锁，一旦发现死锁，采取措施解除死锁。</p>
<ul>
<li>预防策略虽然可以杜绝死锁发生，但是它提出的策略可能会或多或少影响到系统效率。</li>
<li>可以容忍死锁的发生，事后处理。</li>
<li>灵活性好，但是效率高。</li>
</ul>
</li>
</ol>
<p>死锁研究的主要内容就是死锁防止、死锁避免、死锁检测和死锁恢复。<br>前两者是无死锁系统，后两者则是允许死锁，出现排除死锁的方法。</p>
<h3 id="2-1-死锁防止"><a href="#2-1-死锁防止" class="headerlink" title="2.1 死锁防止"></a>2.1 死锁防止</h3><ul>
<li>死锁防止是通过破坏死锁的四个必要条件之一来防止死锁的发生。</li>
<li>$\begin{aligned}&amp;\mathrm{D}\to\mathrm{C}1\wedge\mathrm{C}2\wedge\mathrm{C}3\wedge\mathrm{C}4\&amp;\rceil\mathrm{C}1\vee\rceil\mathrm{C}2\vee\rceil\mathrm{C}3\vee\rceil\mathrm{C}4\to\rceil\mathrm{D}\end{aligned}$</li>
<li>破坏四个必要条件中的任何一个，就可以防止死锁的发生。</li>
</ul>
<h4 id="2-1-1-破坏互斥条件"><a href="#2-1-1-破坏互斥条件" class="headerlink" title="2.1.1 破坏互斥条件"></a>2.1.1 破坏互斥条件</h4><ul>
<li>让资源可以被多个进程共享，如打印机资源可以被多个进程共享。（但有些资源是不可共享的）</li>
</ul>
<h4 id="2-1-2-破坏占有等待条件"><a href="#2-1-2-破坏占有等待条件" class="headerlink" title="2.1.2 破坏占有等待条件"></a>2.1.2 破坏占有等待条件</h4><ul>
<li>采用一次性分配策略，即进程在<strong>运行前一次性</strong>申请所有资源，不再申请资源。<strong>要么没分到一个资源，要么全部满足</strong>（适合廉价资源的分配）</li>
<li>进程在<strong>下一轮申请资源</strong>时，<strong>释放所占的所有资源</strong> (用完一个再用下一个)</li>
</ul>
<h4 id="2-1-3-破坏非抢占（剥夺）条件"><a href="#2-1-3-破坏非抢占（剥夺）条件" class="headerlink" title="2.1.3 破坏非抢占（剥夺）条件"></a>2.1.3 破坏非抢占（剥夺）条件</h4><blockquote>
<p>适用于内存管理和CPU管理</p>
</blockquote>
<ul>
<li>当进程Pi申请ri类资源时，若有则分配，若没有则<strong>剥夺（释放）Pi占有的所有资源</strong>；</li>
<li>当进程Pi申请ri类资源时，若有则分配，若无则<strong>剥夺（淘汰）占有ri类资源进程所占的ri类资源分配给Pi</strong>；或<strong>看占用ri类资源的Pk处于什么状态，若处于等资源状态，则剥夺其资源，否则让Pi等待,等于剥夺Pi的资源</strong>。</li>
</ul>
<h4 id="2-1-4-破坏循环等待条件"><a href="#2-1-4-破坏循环等待条件" class="headerlink" title="2.1.4 破坏循环等待条件"></a>2.1.4 破坏循环等待条件</h4><ul>
<li><strong>资源顺序分配方法</strong>：系统规定所有资源类型有一个编号，进程在申请资源时必须按照编号递增的顺序申请资源。</li>
<li>如果出现循环等待，则必然会出现环路，环路中的进程按照资源编号递增的顺序申请资源，所以环路中的进程必然会按照资源编号递增的顺序释放资源，从而打破循环等待条件。</li>
</ul>
<h3 id="2-2-死锁避免"><a href="#2-2-死锁避免" class="headerlink" title="2.2 死锁避免"></a>2.2 死锁避免</h3><ul>
<li>死锁避免是在进程运行时，根据进程对资源的请求，<strong>预测是否会发生死锁</strong>，若会发生死锁，则<strong>不分配资源</strong>，否则分配资源。</li>
<li>允许死锁产生的条件存在，但通过动态的、明智的选择——在分配资源之前，系统判断假若满足进程的要求是否会发生死锁，如果会，资源就不予分配，从而确保永远不会到达死锁点，避免死锁的发生。</li>
<li>优点：比预防策略更为灵活实用，允许更多的并发，其资源利用率和效率也更高。</li>
</ul>
<p>死锁避免声明了一个安全状态的概念，即系统在某一时刻的状态是安全的，如果系统在某一时刻的状态是安全的，那么系统就可以继续分配资源，否则就不分配资源。</p>
<h4 id="什么是安全状态？"><a href="#什么是安全状态？" class="headerlink" title="什么是安全状态？"></a>什么是安全状态？</h4><ul>
<li>安全状态：指在某个时刻，当多个进程动态的申请资源时，如果存在一种顺序如<strong>P1,P2,P3,…,Pn</strong> ，使得系统<strong>按照这种顺序</strong>逐次地为<strong>每个进程分配所需资源</strong>后<strong>每个进程都可以在最终得到最大需求量</strong>后，依次顺利地完成。</li>
<li><strong>避免死锁的关键</strong>就是：让系统在动态分配资源的过程中，不要进入不安全状态。</li>
</ul>
<h4 id="单银行家算法（Banker’s-Algorithm）"><a href="#单银行家算法（Banker’s-Algorithm）" class="headerlink" title="单银行家算法（Banker’s Algorithm）"></a>单银行家算法（Banker’s Algorithm）</h4><ul>
<li>1965年由Dijkstra为T.H.E系统设计</li>
<li>基本思想：借用了银行借贷系统的分配策略。基于这样一些规则：</li>
</ul>
<p><img src="/images/note2-3-1719235595827.png" alt="图 0">  </p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>在系统处理资源申请时，判断在满足申请时，系统是否还<strong>处于安全状态</strong>？是则满足本次资源申请，否则拒绝。依此引导进程的运行次序。</p>
<p>单类资源系统安全状态定义：设系统中有n个进程，若存在一个序列$\langle P_1,P_2,\cdots,P_n\rangle$，使得对于每个进程$P_i$，都有$P_i$的资源需求量$\leq$系统现有资源量与其他进程($P_1,\cdots,P_{i-1}$)的资源量之和，那么系统就是安全的,我们也称这个序列$\langle P_1,P_2,\cdots,P_n\rangle$为安全序列。</p>
<h5 id="算法例子"><a href="#算法例子" class="headerlink" title="算法例子"></a>算法例子</h5><ul>
<li>初始条件</li>
</ul>
<p>假设系统中有3个进程（P1, P2, P3）和10个相同的资源单元。进程的最大资源需求量和当前已分配的资源量如下：</p>
<ul>
<li>P1：最大需求量&#x3D;6，已分配&#x3D;2</li>
<li>P2：最大需求量&#x3D;5，已分配&#x3D;1</li>
<li>P3：最大需求量&#x3D;7，已分配&#x3D;2</li>
</ul>
<p>因此，系统当前可用资源量&#x3D;10-(2+1+2)&#x3D;5。</p>
<ul>
<li>进程资源申请</li>
</ul>
<p>假设P2申请了2个资源单元。</p>
<ul>
<li>判断安全状态</li>
</ul>
<ol>
<li><strong>计算新的可用资源量</strong>：如果满足P2的申请，系统的可用资源量将变为5-2&#x3D;3。</li>
<li><strong>尝试找到安全序列</strong>：<ul>
<li><strong>第一步</strong>：查看所有进程，判断它们的最大需求量与当前已分配的资源量之差是否小于等于新的可用资源量3。<ul>
<li>P1需要4个资源单元（6-2），P2需要2个资源单元（5-3），P3需要5个资源单元（7-2）。</li>
</ul>
</li>
<li><strong>第二步</strong>：在当前情况下，只有P2的需求（2个资源单元）可以被满足。</li>
<li><strong>第三步</strong>：如果P2完成执行并释放所有资源，系统的可用资源量将变为3+3&#x3D;6。</li>
<li><strong>第四步</strong>：现在，P1和P3的资源需求都可以被满足。如果先满足P1（需要4个资源单元），P1完成后系统可用资源量变为6+2&#x3D;8。</li>
<li><strong>第五步</strong>：最后，P3的需求（需要5个资源单元）也可以被满足。</li>
</ul>
</li>
</ol>
<p>因此，存在一个安全序列：$\langle P_2, P_1, P_3 \rangle$。</p>
<p>类似的，我们也可以采用相似的思路对下面的举例进行分析：</p>
<p><img src="/images/note2-3-1719235963149.png" alt="图 1">  </p>
<p>我们会发现，按照$b\to c \to a \to d$的顺序，系统是安全的。</p>
<h5 id="整体算法流程"><a href="#整体算法流程" class="headerlink" title="整体算法流程"></a>整体算法流程</h5><p><img src="/images/note2-3-1719236116389.png" alt="图 2">  </p>
<h4 id="扩展银行家算法"><a href="#扩展银行家算法" class="headerlink" title="扩展银行家算法"></a>扩展银行家算法</h4><ul>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li>$n$：进程数, $m$：资源种类数</li>
<li>$Available$：系统可用资源向量，是一个$m$维向量，表示系统中每类资源的可用数量。其初始值是系统中每类资源的总数减去已分配给进程的资源数之和。如果$Available[j]&#x3D;k$，表示系统中第$j$类资源的可用数量是$k$。</li>
<li>$Max$：最大需求矩阵，是一个$n\times m$矩阵，表示每个进程对每类资源的最大需求量。如果$Max[i][j]&#x3D;k$，表示进程$i$对第$j$类资源的最大需求数量是$k$。</li>
<li>$Allocation$：已分配矩阵，是一个$n\times m$矩阵，表示每个进程已分配到的资源数量。如果$Allocation[i][j]&#x3D;k$，表示进程$i$已分配到第$j$类资源的数量是$k$。</li>
<li>$Need$：需求矩阵，是一个$n\times m$矩阵，表示每个进程对每类资源的需求量。如果$Need[i][j]&#x3D;k$，表示进程$i$对第$j$类资源的需求数量是$k$。</li>
</ul>
</li>
<li><p>从上面的数据结构描述我们就可以得到一个如下的等式：</p>
<ul>
<li>$Need[i][j]&#x3D;Max[i][j]-Allocation[i][j]$。</li>
</ul>
</li>
<li><p><strong>算法流程</strong>：</p>
<ul>
<li>当进程提出资源申请时，系统<strong>首先检查</strong>该进程<strong>对资源的申请量</strong>是否<strong>超过</strong>其<strong>最大需求量</strong>及<strong>系统现有资源能否满足进程需要</strong>。若能则进一步检查：若把资源分给该进程系统能否处于安全状态。若安全则分配，否则置该进程为等待资源状态。</li>
<li>为简单起见，设$A_i为A(1),A(2),\cdots,A(m)$的简写，$B_i为B(1),B(2),\cdots,B(m)$的简写。定义长度为m的向量$X$和$Y$之间的大小关系：$X\leq Y$当且仅当$X(i)\leq Y(i),i&#x3D;1,2,\cdots,m$。</li>
<li>设$Request_i$为进程$P_i$对资源的申请量，若$Request_i\leq Need_i$，则进程$P_i$的资源申请是合法的。若$Request_i\leq Available$，则系统有足够的资源满足进程$P_i$的资源申请。</li>
<li>系统试探性地分配资源给进程$P_i$，即$Available&#x3D;Available-Request_i$，$Allocation_i&#x3D;Allocation_i+Request_i$，$Need_i&#x3D;Need_i-Request_i$。然后系统执行安全性算法，判断系统是否处于安全状态。否则，系统回滚到原来的状态，即$Available&#x3D;Available+Request_i$，$Allocation_i&#x3D;Allocation_i-Request_i$，$Need_i&#x3D;Need_i+Request_i$。</li>
</ul>
</li>
<li><p><strong>安全状态检测算法</strong>：</p>
<ul>
<li>设置工作向量$Work&#x3D;Available$，Finish向量的所有元素置为false。工作向量表示系统可用资源量，一开始等于系统可用资源量$Available$。Finish数组表示系统中的进程是否能完成执行，一开始都是false。</li>
<li>从进程集合中找到一个进程$P_i$，满足以下条件：<ul>
<li>$Finish[i]&#x3D;false$；</li>
<li>$Need_i\leq Work$。</li>
</ul>
</li>
<li>若找到这样的进程$P_i$，则执行以下操作：<ul>
<li>$Work&#x3D;Work+Allocation_i$；</li>
<li>$Finish[i]&#x3D;true$；</li>
</ul>
</li>
<li>重复上述操作，直到找不到这样的进程为止。</li>
<li>若所有进程都满足$Finish[i]&#x3D;true$，则系统处于安全状态，否则系统处于不安全状态。</li>
</ul>
</li>
</ul>
<h5 id="扩展银行家算法例子"><a href="#扩展银行家算法例子" class="headerlink" title="扩展银行家算法例子"></a>扩展银行家算法例子</h5><p><img src="/images/note2-3-1719236752697.png" alt="图 3">  </p>
<p><img src="/images/note2-3-1719236841436.png" alt="图 4">  </p>
<p><img src="/images/note2-3-1719236852726.png" alt="图 5">  </p>
<p><img src="/images/note2-3-1719236879839.png" alt="图 6">  </p>
<p><img src="/images/note2-3-1719236871261.png" alt="图 7">  </p>
<p><img src="/images/note2-3-1719236934494.png" alt="图 8">  </p>
<p><img src="/images/note2-3-1719236949411.png" alt="图 9">  </p>
<h3 id="2-3-死锁检测"><a href="#2-3-死锁检测" class="headerlink" title="2.3 死锁检测"></a>2.3 死锁检测</h3><ul>
<li>第一种方法其实就是<strong>银行家算法</strong>中的安全状态检测算法。</li>
<li>第二种方法是<strong>资源分配图</strong>法。</li>
</ul>
<h4 id="资源分配图法"><a href="#资源分配图法" class="headerlink" title="资源分配图法"></a>资源分配图法</h4><ul>
<li><strong>资源分配图</strong>：用图形的方式表示系统中进程和资源之间的关系，以便于直观地观察系统中的资源分配情况。是描述进程申请资源和资源分配情况的关系模型图。表示系统中某个时刻进程对资源的申请和占有情况。</li>
<li><strong>资源分配图的构成</strong>：<ul>
<li><strong>顶点</strong>：表示进程和资源。</li>
<li><strong>边</strong>：表示进程对资源的请求和资源的分配。</li>
<li><strong>资源分配图的种类</strong>：<ul>
<li><strong>请求边</strong>：表示进程对资源的请求。</li>
<li><strong>分配边</strong>：表示资源分配给进程。</li>
<li><strong>环路</strong>：表示死锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/note2-3-1719237077582.png" alt="图 10">  </p>
<p>注意！<strong>圆是进程，方是资源。</strong></p>
<p>注意！<strong>一个箭头表示一个资源的分配，一个箭头表示一个资源的请求。</strong></p>
<p>注意！<strong>资源中的小点表示资源的数量。</strong></p>
<ul>
<li><strong>资源分配图的检测方法</strong>：<ul>
<li><strong>安全状态</strong>：如果资源分配图中不存在环路，则系统处于安全状态，否则系统处于不安全状态。</li>
<li><strong>死锁状态</strong>：如果资源分配图中存在环路，则系统处于死锁状态，否则系统处于非死锁状态。</li>
</ul>
</li>
<li>一张合理的资源分配图应该满足以下条件：<ul>
<li>设资源类$R_j$有$W_j$个，用$|(R_j,P_i)|$表示进程$P_i$已经从资源类$R_j$中分配了多少资源，用$|(P_i,R_j)|$表示进程$P_i$还需要多少资源。</li>
<li>**资源分配图中的每个进程节点$P_i$的资源需求量$|(P_i,R_j)|$加上已分配的资源量$|(R_j,P_i)|$应该小于等于资源类$R_j$的总数$W_j$，即$|(P_i,R_j)|+|(R_j,P_i)|\leq W_j$。</li>
<li>**资源分配图中的每个进程节点$P_i$的已获取资源量$|(R_j,P_i)|$之和应该小于等于资源类$R_j$的总数$W_j$，即$\sum_{i&#x3D;1}^n|(R_j,P_i)|\leq W_j$。</li>
</ul>
</li>
</ul>
<h4 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h4><ul>
<li><strong>死锁检测算法</strong>：检测系统是否处于死锁状态，如果处于死锁状态，则采取措施解除死锁。采用化简资源分配图的方法检测系统中有无进程处于死锁状态。</li>
</ul>
<h5 id="死锁检测算法流程"><a href="#死锁检测算法流程" class="headerlink" title="死锁检测算法流程"></a>死锁检测算法流程</h5><ol>
<li><p>在图中找一个进程顶点，它的所有请求边都能被立即满足。</p>
<ul>
<li>$|(P_i,R_j)|+\sum_{k&#x3D;1}^n|(R_j,P_k)|\leq W_j$，则该进程顶点是一个安全顶点。</li>
</ul>
</li>
<li><p>从图中删除该进程顶点和与之相关的边，并释放该进程占用的资源。</p>
</li>
</ol>
<p><img src="/images/note2-3-1719237464264.png" alt="图 11">  </p>
<ul>
<li>资源分配图中的所有进程如果都能化简成孤立结点，则这个资源图就是<strong>可完全化简的（completely reducible）</strong>；反之，就是不可完全化简的（irrreducible）。</li>
<li><strong>死锁定理</strong>：如果一个系统状态为死锁状态，当且仅当资源分配图是不可完全化简的。也即，如果资源图中所有的进程都成为孤立结点，则系统不会死锁；否则系统状态为死锁状态。</li>
</ul>
<p><img src="/images/note2-3-1719237990210.png" alt="图 12">  </p>
<p>上图是一个典型的无法完全化简的资源分配图，因此系统处于死锁状态。</p>
<h3 id="2-4-死锁恢复"><a href="#2-4-死锁恢复" class="headerlink" title="2.4 死锁恢复"></a>2.4 死锁恢复</h3><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><ul>
<li><strong>重新启动</strong>：这是一种常用但比较粗暴的方法，虽然实现简单，但会使之前的工作全部白费，造成很大的损失和浪费。</li>
<li><strong>撤消进程</strong>：死锁发生时，系统撤消造成死锁的进程，解除死锁。<ul>
<li>一次性撤消所有的死锁进程。损失较大。</li>
<li>逐个撤消，分别收回资源。具体做法：系统可以先撤消那些优先级低的、已占有资源少或已运行时间短的、还需运行时间较长的进程，尽量减少系统的损失。</li>
</ul>
</li>
<li><strong>剥夺资源</strong>：死锁时，系统保留死锁进程，只剥夺死锁进程占有的资源，直到解除死锁。选择被剥夺资源进程的方法和选择被撤消进程相同。</li>
<li><strong>进程回退</strong>：死锁时，系统可以根据保留的历史信息，让死锁的进程从当前状态向后退回到某种状态，直到死锁解除。<br>  实现方法：可以通过<strong>结合检查点或回退（checkpoint&#x2F;Rollback）</strong>机制实现。进程某一时刻的瞬间状态叫做检查点，可以定期设置检查点。系统保存所有的检查点。一旦系统检查到有某个进程卷入了死锁，该进程就会被终止，剥夺它占有的所有资源。然后，系统查看保存的检查点信息，重新建立该进程的状态，从上次检查点的位置重新执行。目前发展已比较成熟，广泛用于DBMS中。</li>
</ul>
<h3 id="死锁的综合处理"><a href="#死锁的综合处理" class="headerlink" title="死锁的综合处理"></a>死锁的综合处理</h3><p>把系统中的资源分成几大类，整体上采用<strong>资源顺序分配法</strong>，再对每类资源根据其特点选择最适合的方法。<br>例如：<br>（1）主存、处理机 –  <strong>剥夺法</strong><br>（2）辅存        –   <strong>预分配法</strong><br>（3）其他        –   <strong>检测后处理</strong><br>还有的预防死锁方法：<strong>设立资源阈值</strong>，当资源少于阀值时不让新进程申请，只让老进程申请，避免申请不到资源。</p>
<h2 id="3-some-problems"><a href="#3-some-problems" class="headerlink" title="3. some problems"></a>3. some problems</h2><ol>
<li>系统死锁的可能原因主要是<strong>时间上和空间上的</strong>。时间上由于进程运行中推进顺序不当，即<strong>调度时机不合适</strong>，不该切换进程时进行了切换，可能会造成死锁：空间上的原因是对<strong>独占资源分配不当</strong>，互斥资源部分分配又不可剥夺，极易造成死锁。<strong>那么，为什么系统资源不足不是造成死锁的原因呢？</strong>系统资源不足只会对进程造成“饥饿”。例如，某系统只有三台打印机，若进程运行中要申请四台，显然不能满足，该进程会永远等待下去。若该进程在创建时便声明需要四台打印机，则操作系统立即就会拒绝，这实际上是资源分配不当的一种表现。不能以系统资源不足来描述剩余资源不足的情形。</li>
<li>死锁避免是指在资源动态分配过程中用某些算法加以限制，<strong>防止系统进入不安全状态</strong>从而避免死锁的发生。死锁防止则是通过破坏死锁的四个必要条件之一来防止死锁的发生。</li>
<li>资源有序分配算法为死锁预防策略，而银行家算法为死锁避免算法，是动态的，根据进程对资源的请求，预测是否会发生死锁，若会发生死锁，则不分配资源，否则分配资源。</li>
<li>某个进程主动释放资源不会导致死锁，因为破坏了请求并保持条件。颠簸也就是抖动，这是请求分页系统中页面调度不当而导致的现象，是下一章讨论的问题。回退是指从此时此刻的状态退回到一分钟之前的状态，假如一分钟之前拥有资源X,它有可能释放了资源X,那就不称回到一分钟之前的状态，也就不是回退。由于进程过于“慷慨”，不断把自己已得到的资源送给别人，导致自己长期无法完成，所以是饥饿。</li>
<li>银行家算法要求，进程运行之前先声明它对各类资源的最大需求量，并保证<strong>它在任何时刻对每类资源的请求量不超过它所声明的最大需求量</strong>。<strong>当进程已占有的资源数与本次申请的资源数之和不超过对资源的最大需求量，且现存资源量能满足尚需的最大资源量时</strong>，才分配资源。</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记3——存储管理</title>
    <url>/2024/06/24/note3-1/</url>
    <content><![CDATA[<h1 id="操作系统笔记3——存储管理"><a href="#操作系统笔记3——存储管理" class="headerlink" title="操作系统笔记3——存储管理"></a>操作系统笔记3——存储管理</h1><blockquote>
<p>了解存储管理的基本概念，掌握连续分配存储管理方式，了解页式存储管理方式，掌握段式存储管理方式。</p>
</blockquote>
<h2 id="1-存储管理的基本概念"><a href="#1-存储管理的基本概念" class="headerlink" title="1. 存储管理的基本概念"></a>1. 存储管理的基本概念</h2><ul>
<li>冯·诺依曼体系结构：存储器、运算器、控制器、输入设备、输出设备。</li>
<li>存储管理的必要性：<strong>存储器一直以来都是较为珍贵的系统资源，需要合理使用。程序的逻辑空间和实际的物理空间不甚相同，需要进行映射。</strong></li>
<li>存储结构层次：<strong>寄存器、高速缓存、主存、辅存。</strong><ul>
<li><img src="/images/note3-1-1719279045598.png" alt="图 0"></li>
</ul>
</li>
<li>存储管理的目的：<ul>
<li>使得用户和用户程序不涉及内存物理的细节。——<strong>逻辑地址和物理地址的映射</strong>。</li>
<li>自动完成用户程序的装入。——<strong>装入程序</strong>。</li>
<li>提高内存的利用率。——<strong>内存的分配和回收</strong>。</li>
<li>解决内存速度与CPU速度不匹配的问题。——<strong>缓冲技术</strong>。</li>
<li>实现内存共享。——<strong>共享技术</strong>。</li>
</ul>
</li>
<li>存储管理的主要任务：<ul>
<li>地址变换(地址再定位)</li>
<li>存储资源的分配和回收</li>
<li>存储共享和保护</li>
<li>存储器扩充</li>
<li>覆盖技术</li>
<li>交换技术</li>
</ul>
</li>
</ul>
<h2 id="2-地址重定位"><a href="#2-地址重定位" class="headerlink" title="2 地址重定位"></a>2 地址重定位</h2><ul>
<li>程序——符号地址&#x2F;名地址</li>
<li>目标文件——相对地址&#x2F;逻辑地址&#x2F;虚拟地址&#x2F;程序地址</li>
<li>内存——物理地址&#x2F;绝对地址</li>
</ul>
<h3 id="常见的地址重定位技术"><a href="#常见的地址重定位技术" class="headerlink" title="常见的地址重定位技术"></a>常见的地址重定位技术</h3><ul>
<li>绝对装入（Absolute Loading）&#x2F;固定地址再定位（Fixed Address Relocation）：程序的地址再定位是在程序执行之前被确定的，也就是在<strong>编译连接时直接生成实际存储器地址</strong>(物理地址)。在此，程序地址空间和内存地址空间是一一对应的。<ul>
<li>优点：简单、快速。</li>
<li>缺点：与硬件结构耦合，不利于程序的移植。</li>
<li>单片机、MS-DOS等。</li>
</ul>
</li>
<li><strong>可重定位装入（Relocatable Loading）</strong>：程序的地址再定位是在程序执行时由操作系统完成的，也就是在<strong>装入时才生成实际存储器地址</strong>。<ul>
<li>此处重定位即指<strong>程序装入内存</strong>时，由于程序的逻辑地址和物理地址不一致，由逻辑地址到物理地址的映射过程。</li>
<li>优点：程序的移植性好。</li>
<li>缺点：装入时&#x2F;执行时需要进行地址映射，效率较低。</li>
<li>UNIX、Linux等。</li>
<li>静态重定位：指地址定位时修改程序的逻辑地址值，<strong>完成定位后，在程序的执行期间地址将不再发生变化</strong>。特点：在程序执行之前进行地址再定位。<ul>
<li><img src="/images/note3-1-1719279542522.png" alt="图 1"></li>
</ul>
</li>
<li>动态重定位：程序在<strong>装入内存时，不修改</strong>程序的逻辑地址值，程序在<strong>访问物理内存之前</strong>，再实时地将逻辑地址转换成物理地址。这个过程发生在程序执行的过程中。<ul>
<li><img src="/images/note3-1-1719279605864.png" alt="图 2"></li>
<li>动态重定位的优点在于程序<strong>在执行期间可以换入和换出内存</strong>，可以解决内存紧张状态；<strong>可以在内存中移动</strong>——把内存中的碎片集中起来，可以充分利用空间；<strong>不必给程序分配连续的内存空间</strong>，可以较好的利用较小的内存块；若干用户可以共享同一程序，实现共享。不过，也需要需要附加的硬件支持，实现存储管理的软件算法也比较复杂。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-作业存储调度"><a href="#3-作业存储调度" class="headerlink" title="3 作业存储调度"></a>3 作业存储调度</h2><p><img src="/images/note3-1-1719280776867.png" alt="图 8">  </p>
<ul>
<li>多队列法</li>
<li>单队列法</li>
</ul>
<h2 id="4-存储碎片"><a href="#4-存储碎片" class="headerlink" title="4 存储碎片"></a>4 存储碎片</h2><ul>
<li><strong>内部碎片</strong>：分配给作业的内存空间比作业实际需要的内存空间大，但是不能再分配给其他作业的空间。</li>
<li><strong>外部碎片</strong>：内存某存储区间容不下要运行的作业时。</li>
</ul>
<h2 id="5-分区存储管理方案"><a href="#5-分区存储管理方案" class="headerlink" title="5 分区存储管理方案"></a>5 分区存储管理方案</h2><ul>
<li>分区存储管理方案&#x2F;连续分配存储管理方式：<strong>连续分配存储空间，且要求程序一次性全部装入内存</strong>，这种方式的优点是简单、易于实现，但是会产生严重的内部碎片和外部碎片。</li>
<li>段式存储管理方式：<strong>将程序和数据分成若干段，每一段可以独立地进行管理</strong>，不过也要求程序一次性全部装入内存。有比较严重的外部碎片问题。</li>
<li>页式存储管理方式：<strong>将程序和数据分成若干页，每一页可以独立地进行管理</strong>，不要求程序一次性全部装入内存，可以实现程序的分页装入和分页换出，解决了内部碎片和外部碎片的问题，不过在作业的最后一页会产生内部碎片。</li>
<li>段页式存储管理方式：<strong>将程序和数据分成若干段，每一段再分成若干页</strong>，每一页可以独立地进行管理，不要求程序一次性全部装入内存，可以实现程序的分段装入和分页换出，克服了纯段式和纯页式存储管理方式的缺点。</li>
<li>交换与覆盖技术：<strong>交换技术是将整个进程从内存换出到外存，覆盖技术是将进程的一部分换出到外存</strong>。</li>
<li>虚拟存储管理方案</li>
</ul>
<h3 id="分区存储管理方案"><a href="#分区存储管理方案" class="headerlink" title="分区存储管理方案"></a>分区存储管理方案</h3><ul>
<li><strong>分区存储管理方案</strong>：是一种连续分配存储空间的管理方式。曾被广泛地应用于1960～1970年代的操作系统中。</li>
<li>主要思想：把内存分为一些大小相等或不等的<strong>分区(Partition)<strong>，装入时每个应用程序占用一个或几个分区，操作系统占用其中一个分区。</strong>适用于多道程序系统和分时系统</strong>，支持多个程序并发执行。</li>
<li>分类：<ul>
<li>单一连续分区存储管理方案</li>
<li>固定分区存储管理方案</li>
<li>可变分区存储管理方案</li>
</ul>
</li>
</ul>
<h3 id="单一连续分区存储管理方案"><a href="#单一连续分区存储管理方案" class="headerlink" title="单一连续分区存储管理方案"></a>单一连续分区存储管理方案</h3><p>通过一个界地址寄存器来划分用户区和系统区，用户区和系统区之间有一个界限，用户程序不能访问系统区。</p>
<p><img src="/images/note3-1-1719280087927.png" alt="图 3">  </p>
<ul>
<li><strong>越界检查机制</strong>：当用户程序访问系统区时，会触发异常，操作系统会终止用户程序的执行。</li>
</ul>
<p><img src="/images/note3-1-1719280136209.png" alt="图 4">  </p>
<p>其实就是将用户程序地址与界地址寄存器的值进行比较，如果小于等于寄存器中的值a，那么就会报错。</p>
<p>这种方案一次只能装载一个程序，程序会独占整个用户区，如果程序过大，就无法装入，如果程序过小，就会浪费内存。</p>
<p>比较适用于单用户、单任务的系统，不需要复杂的硬件支持。</p>
<h3 id="固定分区存储管理方案"><a href="#固定分区存储管理方案" class="headerlink" title="固定分区存储管理方案"></a>固定分区存储管理方案</h3><p><img src="/images/note3-1-1719280311987.png" alt="图 5">  </p>
<p>固定分区与单一连续分区的区别在于，固定分区将用户区分为若干个固定大小的分区，每个分区可以装入一个程序，这样可以同时装入多个程序。这个方案通过<strong>分区表</strong>来记录每个分区的使用情况，通过读入分区表指定表项来写入下界寄存器和上界寄存器，来确定用户程序的地址范围，通过越界检查机制来检查用户程序是否访问了对应的分区。</p>
<ul>
<li><strong>地址访问保护</strong><ul>
<li><strong>上下界寄存器与地址检查</strong>：通过上下界寄存器来限制用户程序的访问范围，当用户程序访问超出范围时，会触发异常。不过也要求作业程序的地址要是绝对地址或静态可浮动地址。<br><img src="/images/note3-1-1719280430378.png" alt="图 6">  </li>
<li><strong>基址寄存器、长度寄存器与地址检查</strong>：通过基址寄存器和长度寄存器来限制用户程序的访问范围，当用户程序访问超出范围时，会触发异常。不过也要求作业程序的地址要是相对地址&#x2F;动态可浮动地址。在这个方案里，会先检查长度寄存器，而不再检查基址寄存器。<br><img src="/images/note3-1-1719280541686.png" alt="图 7"></li>
</ul>
</li>
</ul>
<p>这种方案可以支持多道程序且实现简单，但是要求程序必须连续存放，一次装入。相比于单一连续分配方法，内存的利用率提高了。不过，也要求作业必须预先能够估计自己要占用多大的内存空间，有时候这是难以做到的；而且，这种方案会产生内部碎片；分区总数固定，限制了并发执行的程序数量。</p>
<h3 id="可变分区存储管理方案"><a href="#可变分区存储管理方案" class="headerlink" title="可变分区存储管理方案"></a>可变分区存储管理方案</h3><ul>
<li><strong>预先不划分内存，当作业需要时向系统申请</strong>，系统从其中挖出一块给该作业，其大小等于作业所需内存的大小，然后将剩下的部分再作为空表块，给下一次分配使用。</li>
</ul>
<p><img src="/images/note3-1-1719280919407.png" alt="图 9">  </p>
<ul>
<li><strong>多道连续可变分区法</strong>：多道、连续、但不固定划分内存。<ul>
<li>管理方法：系统设置一个空闲块队列，初始状态时队列中只有一个连续的空闲块。作业到达后，以某种策略分配空间。作业撤离时，将释放的空间加入空闲队列。</li>
<li>释放方法：相邻合并，否则插入<br><img src="/images/note3-1-1719281034137.png" alt="图 10">  </li>
<li>分配方法：<strong>首次适应、最佳适应、最坏适应</strong>（首次满足、最佳满足、最大满足），共同的思路是找到合适的空闲块后，从其中将作业大小的空间分给作业，而剩余部分挂入空闲队列。</li>
</ul>
</li>
</ul>
<h4 id="最先适应算法（First-Fit）"><a href="#最先适应算法（First-Fit）" class="headerlink" title="最先适应算法（First Fit）"></a>最先适应算法（First Fit）</h4><ul>
<li><strong>首次适应算法</strong>：将所有的空闲分区按照<strong>地址递增</strong>的顺序排列，按照分区的先后次序，从头开始查找，符合要求的第一个分区就是要找的分区。</li>
<li>优点：<ul>
<li>分配策略简单。</li>
<li>尽可能利用<strong>存储区低地址的空闲区</strong>，而在<strong>高地址部分保存较大的空闲区，容易满足大作业</strong>。</li>
<li>在释放内存分区时，如果有相邻的空白区就进行合并，使其成为一个较大的空白区。</li>
</ul>
</li>
<li>缺点：<ul>
<li>查找总是从表首开始，因此前面的空闲区往往被分割得很小时，查找次数增大。</li>
<li>会产生外碎片(指占用的分区之间难以利用的空闲分区)，这些碎片散布在存储器的各处，不能集中使用，因而降低了存储器的利用率。</li>
</ul>
</li>
</ul>
<h4 id="下次适应算法（Next-Fit，循环最先适应算法）"><a href="#下次适应算法（Next-Fit，循环最先适应算法）" class="headerlink" title="下次适应算法（Next Fit，循环最先适应算法）"></a>下次适应算法（Next Fit，循环最先适应算法）</h4><ul>
<li><strong>下次适应算法</strong>：是首次适应算法的改进，<strong>从上次分配的位置开始查找</strong>，找到符合要求的第一个分区就是要找的分区。释放方法同首次适应算法。</li>
<li>优点：<ul>
<li>使空闲分区分布得更均匀，提高了分配查找的速度。</li>
</ul>
</li>
<li>缺点：<ul>
<li>较大空闲区不容易保留，容易产生外碎片。</li>
</ul>
</li>
</ul>
<h4 id="最佳适应算法（Best-Fit）"><a href="#最佳适应算法（Best-Fit）" class="headerlink" title="最佳适应算法（Best Fit）"></a>最佳适应算法（Best Fit）</h4><ul>
<li><strong>最佳适应算法</strong>：将所有的空闲分区按照<strong>大小递增</strong>的顺序排列，按照分区的先后次序，从头开始查找，找到符合要求的最小分区就是要找的分区。</li>
<li><strong>释放方法</strong>：在整个链表中搜索地址相邻的空闲区，如果找到就合并。最后，将空闲区插入合适的位置。</li>
<li>优点：<ul>
<li>分配后所剩余的空白块会最小，较大的空闲分区会被保留。</li>
<li>平均只要查找一半的表格便能找到最佳适应的空白区；</li>
<li>如果有一个空白区的容量正好满足要求，则它必被选中。</li>
</ul>
</li>
<li>缺点：<ul>
<li>会产生外碎片，因为分配后的空白块会很小，不容易再利用。</li>
</ul>
</li>
</ul>
<h4 id="最坏适应算法（Worst-Fit）"><a href="#最坏适应算法（Worst-Fit）" class="headerlink" title="最坏适应算法（Worst Fit）"></a>最坏适应算法（Worst Fit）</h4><ul>
<li><strong>最坏适应算法</strong>：将所有的空闲分区按照<strong>大小递减</strong>的顺序排列，按照分区的先后次序，从头开始查找，找到符合要求的最大分区就是要找的分区。释放方法同最佳适应算法。</li>
<li>优点：<ul>
<li>分配的时候，只需查找一次，就可以成功，分配算法很快。</li>
</ul>
</li>
<li>缺点：<ul>
<li>最后剩余的分区会越来越小，不会保留较大的空闲分区，无法运行大程序。</li>
</ul>
</li>
</ul>
<h3 id="可用空间管理"><a href="#可用空间管理" class="headerlink" title="可用空间管理"></a>可用空间管理</h3><p>除用队列表示可用空闲块外,也可以用数组登记可用空闲块，数组项&#x3D;用户空间总量&#x2F;基本分配单位。</p>
<p><img src="/images/note3-1-1719281629873.png" alt="图 11">  </p>
<p>紧致：通过移动作业，使空闲区连续，减少外碎片。不过要求作业动态可浮动。</p>
<h3 id="可再定位式分区"><a href="#可再定位式分区" class="headerlink" title="可再定位式分区"></a>可再定位式分区</h3><ul>
<li>又称浮动分区分配，是解决碎片问题的简单而有效的办法。</li>
<li>采用可再定位式分区分配的系统，可以移动所有被分配的分区，使之成为一个连续区域，而留下一个较大的空白区。</li>
</ul>
<h2 id="6-分页存储管理方案-页式存储管理方式"><a href="#6-分页存储管理方案-页式存储管理方式" class="headerlink" title="6 分页存储管理方案&#x2F;页式存储管理方式"></a>6 分页存储管理方案&#x2F;页式存储管理方式</h2><p>前面提到的分区存储管理方案要求作业存储必须连续存放，页式存储管理方案的提出则是为了解决这个问题。</p>
<h3 id="不连续空间分配——页式管理"><a href="#不连续空间分配——页式管理" class="headerlink" title="不连续空间分配——页式管理"></a>不连续空间分配——页式管理</h3><p>作业(进程)分成页面，内存也划分成页面，将作业(进程)页面不连续地分布到内存页面。</p>
<p>空间安排：</p>
<ul>
<li>用户进程空间(地址)叫逻辑空间(地址)</li>
<li>内存空间(地址)叫物理空间(地址)</li>
<li>用<strong>相同长度为单位</strong>对逻辑空间<strong>等分出的每个区域叫页</strong>，对物理空间等分出的区域叫<strong>页帧（物理块）</strong>。——这其实也意味着，空闲队列中实际上存的是空闲的页帧。</li>
</ul>
<p><img src="/images/note3-1-1719281946007.png" alt="图 12">  </p>
<ul>
<li>分配：系统初始时，<strong>所有页帧都在空闲队列中</strong>，当用户进程被创建时，系统按需要量从空闲队列获得相应量的页帧。</li>
<li>回收：当用户进程终止时，系统将其占用的页帧归还到空闲队列。</li>
<li>动态地址转换：逻辑地址转换为物理地址的过程，通过页表实现。</li>
</ul>
<p>页式方法里面，我们只知道当前程序有哪些逻辑地址，有哪些页，但是不知道这些页在内存中的位置，这就需要页表来实现逻辑地址到物理地址的映射。</p>
<h4 id="什么是页表"><a href="#什么是页表" class="headerlink" title="什么是页表"></a>什么是页表</h4><ul>
<li><strong>页表</strong>：是一种特殊的数据结构，放在系统空间的页表区，存放逻辑页与物理页帧的对应关系。<strong>每一个进程都拥有一个自己的页表</strong>， PCB表中有指针指向页表。</li>
</ul>
<p><img src="/images/note3-1-1719284937767.png" alt="图 13">  </p>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p>而分页时的逻辑地址有如下结构：</p>
<p><code>P(页号)|.d(页内位移)</code></p>
<p>分页时的物理地址有如下结构：</p>
<p><code>f(页帧号)|.d(页内位移)</code></p>
<p>对于页号来说，它是由线性逻辑地址来决定的，起始页号为0.</p>
<p><code>P = 线性逻辑地址 / 页面大小；</code><br><code>d = 线性逻辑地址 - P*页面大小。</code></p>
<p><strong>页面大小的考虑：</strong></p>
<p>一般而言，我们都会将页面大小取成 2 的幂次方，这样的好处是：在我们获取页号和页内位移时，可以直接通过位运算来获取，而不需要进行除法和取余运算。</p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p><img src="/images/note3-1-1719285249017.png" alt="图 14">  </p>
<p>有了页号$P$和页内位移$d$，我们就可以通过页表来获取物理地址了。</p>
<p>在查找时，我们根据存放页表起始地址的寄存器，加上页号$P$的值，就可以得到页表中对应页号$P$的页表项的地址，从中读取页表项，得到页表项中的页帧号$f$，然后将页帧号$f$和页内位移$d$组合成物理地址$P.f|d$。</p>
<p>我们实际上会关注到，页内地址是没有变化的，只有页号会变化，所以我们可以将页表项中的页帧号和页内地址组合成一个新的地址。</p>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><ul>
<li><strong>快表</strong>：是页表的一个高速缓冲区，用于存放最近被访问的页表项，以减少对页表的访问次数，提高地址转换的速度。它由一组联想寄存器(TLB, Translation Lookaside Buffer，一种按内容进行并行查找的快速寄存器，访问速度比主存快得多)组成。</li>
</ul>
<p><img src="/images/note3-1-1719285490265.png" alt="图 15">  </p>
<p>快表对页号做了到页帧号的映射，当我们访问一个页号时，会先查找快表，如果快表中有这个页号，就直接得到页帧号，如果没有，就需要查找页表。</p>
<p>有了快表之后，在原先的地址转换流程的查页表起始地址寄存器之前，要先去查快表，如果快表中有这个页号，就直接得到页帧号，如果没有，就需要查找页表。</p>
<h5 id="快表的指标"><a href="#快表的指标" class="headerlink" title="快表的指标"></a>快表的指标</h5><ul>
<li><strong>命中率</strong>：快表中的页表项命中的概率，命中率越高，页表访问次数越少，地址转换速度越快。选用8-12项组成的快表，并采用适当的替换策略，在快表匹配成功的可能性可达80-90%。</li>
<li><strong>等效访问时间</strong>：<ul>
<li>设访存时间为$T_m$，快表查找时间为$T_t$，命中率为$h$，则等效访问时间$T_e &#x3D; h\times(T_m+T_t) + (1-h)\times(2T_m+T_t)$。</li>
<li>需要注意的是，即使有了快表，最后的访问内存时间也并没有发生变化，只是减少了去内存查找页表的时间。</li>
</ul>
</li>
<li>在进程被调度占用cpu时，将<strong>进程页表始地址装入页表始地址寄存器，同时作废掉快表中的原内容，用新的页表项替换</strong>。</li>
</ul>
<h3 id="可用空间管理——页帧"><a href="#可用空间管理——页帧" class="headerlink" title="可用空间管理——页帧"></a>可用空间管理——页帧</h3><ul>
<li>可用bitmap数组或空闲页帧链来管理可用页帧。</li>
</ul>
<h3 id="共享与保护"><a href="#共享与保护" class="headerlink" title="共享与保护"></a>共享与保护</h3><ul>
<li><strong>共享</strong>：通过页表实现多个进程的逻辑地址空间映射到同一个物理地址空间，实现共享。</li>
</ul>
<p><img src="/images/note3-1-1719285965285.png" alt="图 16">  </p>
<ul>
<li><strong>保护</strong>：通过页表实现对进程的访问权限控制，实现保护。</li>
</ul>
<h4 id="越界保护"><a href="#越界保护" class="headerlink" title="越界保护"></a>越界保护</h4><ul>
<li>设置一个页表长度寄存器，用于存放页表的长度，当页号超出页表长度时，会触发异常。</li>
</ul>
<p><img src="/images/note3-1-1719286022762.png" alt="图 17">  </p>
<h4 id="访问保护"><a href="#访问保护" class="headerlink" title="访问保护"></a>访问保护</h4><ul>
<li>在每个页表项中增设一存储保护域，用于说明对该页的访问权限，每一个对该页存储的访问都首先要比照是否满足该页访问权限的说明，满足则访问，否则报异常。保护域的形式类似于文件的访问权限(rwx&#x2F;rwe)。</li>
</ul>
<h3 id="页式存储管理的优缺点"><a href="#页式存储管理的优缺点" class="headerlink" title="页式存储管理的优缺点"></a>页式存储管理的优缺点</h3><ul>
<li>优点<ul>
<li>没有外碎片，每个内碎片不超过页大小。</li>
<li>程序不必连续存放。</li>
</ul>
</li>
<li>主要缺点：<ul>
<li>程序要一次全部装入内存才能执行。</li>
<li>采用动态地址变换机构会增加计算机的成本和降低处理机的速度。</li>
<li>各种数据结构(页表，空闲页表)要占用一定的内存空间，而且系统要花费一定的时间来建立和管理这些表格。</li>
<li>依然存在内碎片。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记2——进程</title>
    <url>/2024/06/22/note2-1/</url>
    <content><![CDATA[<h1 id="操作系统笔记2——进程"><a href="#操作系统笔记2——进程" class="headerlink" title="操作系统笔记2——进程"></a>操作系统笔记2——进程</h1><h2 id="1-进程的概念"><a href="#1-进程的概念" class="headerlink" title="1. 进程的概念"></a>1. 进程的概念</h2><h3 id="1-1-进程的定义"><a href="#1-1-进程的定义" class="headerlink" title="1.1 进程的定义"></a>1.1 进程的定义</h3><h4 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h4><ul>
<li>程序是一个 <strong>passive entity</strong>，它是一个静态的概念，是一个文件，是一个指令序列（也被称为可执行文件）。</li>
<li>在一个可执行文件被加载到内存中并被操作系统执行时，这个程序就变成了一个进程，是一个 <strong>active entity</strong>。</li>
<li>对于一个进程（process），会有一个对应的程序计数器（PC）来指示下一条要执行的指令。</li>
</ul>
<h5 id="Program-Counter"><a href="#Program-Counter" class="headerlink" title="Program Counter"></a>Program Counter</h5><ul>
<li>程序计数器（PC）是一个在CPU中的寄存器，它存储着下一条要执行的指令的地址。有时候也被称为指令计数器（IC）、指令指针（IP）、指令地址寄存器（IAR）等。</li>
<li>通常，CPU在取完一条指令后，会将PC的值加上这条指令的长度或是1，以便指向下一条指令的地址。</li>
</ul>
<h4 id="Process-In-Memory"><a href="#Process-In-Memory" class="headerlink" title="Process In Memory"></a>Process In Memory</h4><ul>
<li>在内存中，一个进程会被分为多个部分，包括：<ul>
<li>Text Section：存放着程序的指令。</li>
<li>Data Section：存放着程序的全局变量和静态变量。</li>
<li>Stack Section：存放着程序的局部变量和函数返回地址。</li>
<li>Heap Section：存放着程序运行时动态分配的内存。</li>
</ul>
</li>
<li>对于栈和堆，堆是从低地址向高地址增长的，而栈是从高地址向低地址增长的。</li>
</ul>
<h4 id="并发的进程"><a href="#并发的进程" class="headerlink" title="并发的进程"></a>并发的进程</h4><ul>
<li>Concurrency：同一个时间内两个或多个事件或活动发生或存在。</li>
<li>并行：同一时间，两个或多个事件或活动同时运行。</li>
</ul>
<p>产生的原因主要还是资源的有限性，比如CPU、内存、I&#x2F;O设备等。</p>
<h4 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h4><ul>
<li>并发进程无法一次性执行完毕，一个进程可能在执行过程中被中断，然后切换到另一个进程来替换占有CPU。</li>
</ul>
<h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ul>
<li>进程是一个程序的一次执行过程，能完成具体的功能，是在某个数据集合上完成的，执行过程是可并发的。</li>
<li>进程是<strong>资源分配、保护和调度</strong>的基本单位。（前提是没有引入线程的概念）</li>
</ul>
<h4 id="作业与进程"><a href="#作业与进程" class="headerlink" title="作业与进程"></a>作业与进程</h4><ul>
<li>作业（Job）：是一个用户提交的任务，是一个静态的概念，是用户对计算机的一次独立的使用过程。</li>
<li>进程（Process）：是分配计算机资源的单位，是用户任务运行的实体，**作业可包含多个进程(至少一个)**。</li>
</ul>
<p><strong>批处理系统作业与进程关系</strong>：作业调度程序每选择一道作业运行时，首先为该作业创建一个根进程，该进程执行作业控制语言解释器程序，在解释执行作业步时可根据需要创建多个子进程。 </p>
<h3 id="1-2-进程的状态"><a href="#1-2-进程的状态" class="headerlink" title="1.2 进程的状态"></a>1.2 进程的状态</h3><p>三种基本状态：</p>
<ul>
<li>运行态（Running）：进程正在CPU上执行。</li>
<li>就绪态（Ready）：进程已经准备好，等待CPU。</li>
<li>阻塞态（Blocked）：进程正在等待某个事件的发生。也被称为等待态（Waiting）。</li>
</ul>
<h4 id="进程何时离开CPU"><a href="#进程何时离开CPU" class="headerlink" title="进程何时离开CPU"></a>进程何时离开CPU</h4><ul>
<li>内部事件<ul>
<li>进程主动放弃CPU（yield），比如调用 <code>sleep()</code> 函数。</li>
<li>使用I&#x2F;O设备，比如读写文件，为非正常结束。</li>
</ul>
</li>
<li>外部事件<ul>
<li>进程被剥夺CPU使用权，进入就绪态。这个动作叫做抢占（Preemption）。</li>
<li>时间片到达，高优先级进程抢占CPU。</li>
</ul>
</li>
</ul>
<h4 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h4><ul>
<li><strong>创建（Create）</strong>：进程正在被创建。<ul>
<li>是操作系统为进程创建进程控制块（PCB）和分配地址空间的过程。</li>
<li>完成以下工作：<ul>
<li>为进程分配唯一的进程标识符（PID）。</li>
<li>为进程分配地址空间和其他资源。</li>
<li>初始化进程控制块。</li>
<li>初始化进程的状态为就绪态，加入就绪队列。</li>
</ul>
</li>
</ul>
</li>
<li><strong>就绪（Ready）</strong>：进程已经准备好，等待CPU。</li>
<li><strong>运行（Running）</strong>：进程正在CPU上执行。</li>
<li><strong>阻塞（Blocked）</strong>：进程正在等待某个事件的发生。</li>
<li><strong>结束（Terminate）</strong>：进程已经结束。</li>
</ul>
<table>
<thead>
<tr>
<th>状态转换</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>Ready -&gt; Running</td>
<td>CPU调度程序选择该进程占用CPU</td>
</tr>
<tr>
<td>Running -&gt; Ready</td>
<td>时间片用完或在中断机制下，有更高优先级的进程需要CPU，该进程进入就绪队列等待下一次被选中而占用CPU</td>
</tr>
<tr>
<td>Running -&gt; Blocked</td>
<td>进程出让CPU，等待系统分配资源或等待某个事件的发生，如暂时不能访问某一资源、操作系统尚未完成服务、等待用户输入等</td>
</tr>
<tr>
<td>Blocked -&gt; Ready</td>
<td>等待的事件发生或资源可用，进程进入就绪队列等待CPU</td>
</tr>
</tbody></table>
<p>其他可能的状态转换：</p>
<ul>
<li><strong>空-&gt;Create</strong>：进程被创建。</li>
<li><strong>Create-&gt;Ready</strong>：进程创建完毕，进入就绪态。</li>
<li><strong>Running-&gt;Terminate</strong>：进程执行完毕，结束。</li>
</ul>
<h5 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h5><ul>
<li>进程挂起（Suspend）：是指将一个进程从内存中移动到外存中，以释放内存资源。这意味着进程没有再占用内存资源，其进程映像在磁盘上。</li>
</ul>
<p><img src="/images/note2-1719052818993.png" alt="图 2">  </p>
<h4 id="进程状态的转换图"><a href="#进程状态的转换图" class="headerlink" title="进程状态的转换图"></a>进程状态的转换图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">[*] --&gt; Create</span><br><span class="line">Create --&gt; Ready</span><br><span class="line">Ready --&gt; Running</span><br><span class="line">Running --&gt; Ready</span><br><span class="line">Running --&gt; Blocked</span><br><span class="line">Blocked --&gt; Ready</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><strong>七态模型：</strong></p>
<p><img src="/images/note2-1719053752452.png" alt="图 5">  </p>
<h4 id="进程的创建与结束"><a href="#进程的创建与结束" class="headerlink" title="进程的创建与结束"></a>进程的创建与结束</h4><ul>
<li><p>进程的创建</p>
<ul>
<li>接收进程运行所需参数：如初始优先级，执行程序描述及输入参数，其它资源等参数。</li>
<li>请求分配进程描述块PCB空间，得到一个内部数字进程标识。<br>用传来的参数初始化PCB表。</li>
<li>产生用于描述进程空间的数据结构，用初始执行文件初始化进程空间，建立程序段，数据段、用户栈段等。</li>
<li>用进程运行输入参数等设置处理机现场保护区，造一个进程运行栈帧。</li>
<li>置好父进程等关系域。</li>
<li>将进程置成就绪状态。</li>
<li>将PCB表挂入就绪队列，等待时机被调度运行。</li>
</ul>
</li>
<li><p>进程的结束</p>
<ul>
<li>将进程状态改到结束状态；</li>
<li>关闭所有打开文件、设备；</li>
<li>释放进程程序文件和其他资源；</li>
<li>进行相关信息统计；</li>
<li>清理其相关进程的链接关系，如在Linux中，将该结束进程的所有- 子进程链到1号进程，作为1号进程的子进程，并通知父进程自己已结束；</li>
<li>释放进程映像空间；</li>
<li>释放进程控制块(PCB)；</li>
<li>调进程调度与切换程序。</li>
</ul>
</li>
</ul>
<h2 id="3-进程的描述"><a href="#3-进程的描述" class="headerlink" title="3. 进程的描述"></a>3. 进程的描述</h2><h3 id="3-1-进程的组成"><a href="#3-1-进程的组成" class="headerlink" title="3.1 进程的组成"></a>3.1 进程的组成</h3><p>进程由以下四个部分组成：</p>
<ul>
<li><strong>程序段</strong>：存放着程序的指令。</li>
<li><strong>数据段</strong>：存放着进程执行时所使用的数据，包括用户输入的数据、程序中的常量等。</li>
<li><strong>工作区</strong>：存放着进程执行时所使用的临时数据，比如函数调用时的参数、返回地址等。</li>
<li><strong>进程控制块</strong>（PCB）：存放着进程的描述信息，包括进程的标识符、状态、优先级、程序计数器、寄存器等。<strong>PCB是进程存在的唯一标志。</strong></li>
</ul>
<p>在上面的四个部分中，程序与数据是实体，工作区是临时的，PCB是进程的描述信息。</p>
<h3 id="3-2-进程控制块（PCB）"><a href="#3-2-进程控制块（PCB）" class="headerlink" title="3.2 进程控制块（PCB）"></a>3.2 进程控制块（PCB）</h3><ul>
<li>定义：是操作系统用来记录进程的详细状态和相关信息的基本数据结构，与进程一一对应。</li>
<li>作用：提高进程的各种信息，以便操作系统能够对进程进行管理和控制。</li>
</ul>
<h4 id="PCB的结构"><a href="#PCB的结构" class="headerlink" title="PCB的结构"></a>PCB的结构</h4><table>
<thead>
<tr>
<th>类型</th>
<th>内容</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标识信息</td>
<td>1. 进程标识符<br>2. 父进程标识符<br>3. 用户标识符</td>
<td>1. 区分进程<br>2. 父子关系<br>3. 用户标识</td>
</tr>
<tr>
<td>现场信息</td>
<td>1. CPU通用寄存器内容<br>2. CPU控制和状态寄存器内容<br>3. 堆栈指针</td>
<td>记录处理机现场信息，以备恢复之用</td>
</tr>
<tr>
<td>控制信息</td>
<td>1. 进程状态<br>2. 调度信息<br>3. 队列指针<br>4. 位置信息<br>5. 资源占用信息</td>
<td>用于进程的调度管理</td>
</tr>
</tbody></table>
<p>PCB中含有三大类信息描述：</p>
<ol>
<li><strong>进程标识信息</strong>：包括进程标识符、父进程标识符、用户标识符等。</li>
<li><strong>处理机状态信息保存区</strong>。</li>
<li><strong>进程控制信息</strong><ul>
<li>调度和状态信息，用于操作系统调度进程占用处理机。</li>
<li>进程间通讯信息，为支持进程间的通讯相关的各种标识，信号，信件等，这些信息存在接收方的进程控制块中。</li>
<li>存储管理信息。包含有指向本进程映像存储空间的数据结构。</li>
<li>进程所用资源。说明由进程打开，使用的系统资源，如打开的文件等。</li>
<li>有关数据结构链接信息，进程可以链接到一个进程队列中，或链接到相关的其它进程PCB。</li>
</ul>
</li>
</ol>
<p><img src="/images/note2-1719053633194.png" alt="图 3">  </p>
<h4 id="PCB的管理"><a href="#PCB的管理" class="headerlink" title="PCB的管理"></a>PCB的管理</h4><p>操作系统对PCB的管理采用集中统一管理。</p>
<p><img src="/images/note2-1719053704288.png" alt="图 4">  </p>
<h2 id="4-进程的组织"><a href="#4-进程的组织" class="headerlink" title="4. 进程的组织"></a>4. 进程的组织</h2><ul>
<li>线性表组织方式：把所有进程的PCB存放在一个<strong>数组</strong>中，系统通过数组下标访问每个PCB。</li>
<li>链表组织方式：把所有具有相同状态的进程的PCB存放在一个<strong>链表</strong>中，组成一个队列。<ul>
<li>处于就绪态的进程可以按照某种策略排成多个队列。</li>
<li>处于阻塞态的进程可以根据阻塞原因排成多个队列。</li>
</ul>
</li>
</ul>
<p>在下面的图中，当接收进程进入系统，系统会将其分配到对应的就绪队列，然后处理机从某个就绪队列中选择一个进程运行直到进程终止或因为时间片到移动到就绪队列。而在此过程中，可能发生进程的堵塞，此时进程会被移动到对应的阻塞队列中，等待事件发生后再次移动到就绪队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title 进程调度图</span><br><span class="line"></span><br><span class="line">actor 接收进程 as ReceivingProcess</span><br><span class="line"></span><br><span class="line">rectangle &quot;系统&quot; &#123;</span><br><span class="line">    rectangle &quot;就绪队列&quot; as ReadyQueue &#123;</span><br><span class="line">        node ReadyQueue1</span><br><span class="line">        node ReadyQueue2</span><br><span class="line">        node ReadyQueueN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rectangle &quot;阻塞队列&quot; as BlockedQueue &#123;</span><br><span class="line">        node BlockedQueue1</span><br><span class="line">        node BlockedQueue2</span><br><span class="line">        node BlockedQueueN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node Processor &#123;</span><br><span class="line">        node &quot;处理机&quot; as ProcessorState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReceivingProcess -&gt; ProcessorState : 进入系统</span><br><span class="line">ProcessorState --&gt; ReadyQueue : 分配到对应的就绪队列</span><br><span class="line">ReadyQueue1 --&gt; ProcessorState : 处理机选择进程运行</span><br><span class="line">ProcessorState -&gt; ReadyQueue1 : 时间片到，回到就绪队列</span><br><span class="line">ProcessorState --&gt; ReadyQueue1 : 进程终止</span><br><span class="line"></span><br><span class="line">ProcessorState -&gt; BlockedQueue : 进程阻塞</span><br><span class="line">BlockedQueue1 -&gt; ReadyQueue1 : 事件发生，回到就绪队列</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>系统也专门设置了一个指针指向<strong>当前正在运行的进程</strong>，以便于操作系统能够快速找到当前正在运行的进程。如UNIX系统的<code>CURPRO</code>指针。</p>
<ul>
<li>索引方式：系统根据进程的状态建立几张索引表，并将索引表在内存的首地址记录于内存中一些专用单元。</li>
</ul>
<h2 id="5-进程的控制"><a href="#5-进程的控制" class="headerlink" title="5. 进程的控制"></a>5. 进程的控制</h2><h3 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h3><p><strong>中断是指：</strong></p>
<ul>
<li>当发生某个事件时，CPU暂停正在执行的程序</li>
<li>引出该事件的处理程序执行</li>
<li>处理完毕后，返回源程序中断点继续执行</li>
</ul>
<p>与 <strong>Trap</strong> 机制很像，我们可以认为系统调用就是中断的一个特例。</p>
<p><strong>中断也分为：</strong></p>
<ul>
<li>Exception：由CPU内部产生的中断，如除零、溢出等。</li>
<li>Interrupt：由外部设备产生的中断，如I&#x2F;O设备的中断。</li>
</ul>
<h4 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h4><ul>
<li><strong>外部中断</strong>：来自处理器之外的硬件中断信号，如时钟中断、I&#x2F;O中断等。这些中断均是 <strong>异步中断</strong> ——随机。</li>
<li><strong>内部中断</strong>（Exception）：来自处理器内部的中断信号。这些中断均是 <strong>同步中断</strong> 。<ul>
<li>硬件异常：掉电、奇偶校验错误等。</li>
<li>程序异常：除零、溢出等。</li>
<li>系统调用：用户程序请求操作系统服务。</li>
</ul>
</li>
</ul>
<h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><ul>
<li><strong>context</strong>： 上下文信息，包括程序计数器、寄存器等。</li>
</ul>
<ol>
<li><p><strong>保护现场</strong>：将当前程序的上下文信息保存到内存中。</p>
</li>
<li><p><strong>中断处理</strong>：根据中断类型，执行相应的中断处理程序。</p>
<ul>
<li>确定中断源</li>
<li>处理中断</li>
</ul>
</li>
<li><p><strong>恢复现场</strong>；</p>
<ul>
<li>选择一个进程来restore（恢复）和resume（继续）。</li>
<li>从内存中恢复上下文信息。</li>
<li>继续执行。</li>
</ul>
</li>
</ol>
<h3 id="特权指令与非特权指令"><a href="#特权指令与非特权指令" class="headerlink" title="特权指令与非特权指令"></a>特权指令与非特权指令</h3><ul>
<li><strong>特权指令</strong>：只能在内核态下执行的指令。<ul>
<li>I&#x2F;O 指令和停机（Halt）指令。</li>
<li>关闭中断指令。</li>
<li>设置Timer（定时器）指令。</li>
<li>进程切换</li>
</ul>
</li>
<li><strong>非特权指令</strong>：只能在用户态下执行的指令。</li>
</ul>
<h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><ul>
<li>中断是用户态向核心态转换的<strong>唯一途径</strong>。系统调用实质上也是一种中断。</li>
<li>OS提供<code>Load PSW</code>指令，用于装载用户进程，返回用户态。</li>
</ul>
<h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><ul>
<li>进程的控制是指系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各个状态之间的转换。</li>
<li>以上过程由操作系统内核完成，用户程序不能直接控制进程。同时，也是原语一级的操作，不可被打断。</li>
</ul>
<h3 id="原语（Primitive）"><a href="#原语（Primitive）" class="headerlink" title="原语（Primitive）"></a>原语（Primitive）</h3><ul>
<li>由若干条机器指令构成的完成特定功能的程序段。原语作为一个整体，要么全部执行，要么全部不执行。原语主要是通过屏蔽中断来保证其执行的完整性（原子性）。</li>
<li>分类：<ul>
<li><strong>进程控制原语</strong>：创建、撤销等。</li>
<li><strong>进程通信原语</strong>：发送、接收等。</li>
<li><strong>进程管理原语</strong>：挂起、唤醒等。</li>
<li><strong>其他方面的原语</strong></li>
</ul>
</li>
</ul>
<h4 id="创建原语"><a href="#创建原语" class="headerlink" title="创建原语"></a>创建原语</h4><p>引起创建进程的事件：</p>
<ul>
<li>系统初始化</li>
<li>用户登陆</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ul>
<p>在创建进程时，创建原语会做以下工作：</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配资源（程序、数据、工作区——用户栈分配）</li>
<li>初始化PCB，将调用者参数（进程名、进程优先级、实体所在主存起始位置、所需资源清单以及进程家族关系等）填入PCB</li>
<li>将新进程插入就绪队列</li>
</ul>
<p>在UNIX系统中，创建进程的系统调用是<code>fork()</code>。而Windows系统中，创建进程的系统调用是<code>CreateProcess()</code>。</p>
<p><img src="/images/note2-1719058851071.png" alt="图 6">  </p>
<p>以下是一段C语言代码，用于创建一个新的进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// fork()函数会返回两次，一次是在父进程中，一次是在子进程中</span></span><br><span class="line">    <span class="comment">// 在父进程中，pid会返回子进程的PID，而在子进程中，pid会返回0</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;This is child process!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process!&quot;</span>);</span><br><span class="line">        wait(<span class="literal">NULL</span>);<span class="comment">//等待子进程结束,wait函数会将子进程的退出状态传递给父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="撤销原语"><a href="#撤销原语" class="headerlink" title="撤销原语"></a>撤销原语</h4><p>引起撤销进程的事件：</p>
<ul>
<li>进程正常结束——任务完成、用户退出</li>
<li>进程异常结束——运行错误、资源不足、I&#x2F;O异常</li>
<li>外界干预——死锁情况下，系统强制撤销；父进程终止</li>
</ul>
<p>在撤销进程时，撤销原语会做以下工作：</p>
<ul>
<li>根据被终止进程的标识符（PID）从PCB集合中找到对应的PCB，读出进程的状态。</li>
<li>如果被终止进程处于运行态，立即停止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。</li>
<li>如果该进程还有子孙进程，将其所有子孙进程也一并终止，以防子孙进程成为不可控进程。</li>
<li>释放该进程占用的资源，包括内存、文件、I&#x2F;O设备等。被释放的资源会归还给父进程或系统。</li>
<li>将该进程的PCB从所在队列中删除，等待其他程序来搜集信息。</li>
</ul>
<p>在UNIX系统中，撤销进程的系统调用是<code>exit()</code>。子进程调用<code>exit()</code>后，处于<code>zombie</code>状态，进程管理器在父进程被告知子进程结束前，会一直保留子进程的PCB。在父进程执行<code>wait()</code>后，子进程的PCB会被释放。Windows则用<code>ExitProcess()</code>。</p>
<h4 id="阻塞原语"><a href="#阻塞原语" class="headerlink" title="阻塞原语"></a>阻塞原语</h4><p>引起阻塞进程的事件：</p>
<ul>
<li>请求系统服务</li>
<li>启动某种操作——I&#x2F;O处理完成</li>
<li>新数据未到达——等待其他进程发送信息</li>
</ul>
<p>在阻塞进程时，阻塞原语会做以下工作：</p>
<ul>
<li>进程通过调用阻塞原语把自己阻塞，由运行态转变为阻塞态。</li>
<li>中断CPU，将其运行现场保存到PCB中。</li>
<li>置状态为阻塞态，将PCB插入阻塞队列。</li>
<li>转进程调度程序，选择另一个进程运行。</li>
</ul>
<h4 id="唤醒原语"><a href="#唤醒原语" class="headerlink" title="唤醒原语"></a>唤醒原语</h4><p>引起唤醒进程的事件：</p>
<ul>
<li>等待的事件发生——在中断处理程序中，将进程从阻塞队列中移动到就绪队列。</li>
<li>等待某进程发信息——由发送进程发出唤醒信号，使被阻塞进程转为就绪态</li>
</ul>
<p>UNIX 阻塞&#x2F;唤醒：</p>
<ul>
<li>阻塞：<code>pause()</code>，<code>sleep()</code>，<code>wait()</code>，分别等待信号、等待时间、等待子进程结束。</li>
<li>唤醒：<code>kill()</code>，<code>Wakeup()</code>，分别发送信号、唤醒进程。</li>
</ul>
<h4 id="挂起原语"><a href="#挂起原语" class="headerlink" title="挂起原语"></a>挂起原语</h4><p>对于不同的操作系统，挂起原语的实现方式不同。</p>
<ul>
<li>实时系统中，根据实时现场需要，会将正在执行或没有执行的进程挂起。被挂起的进程由活动状态变为<strong>静止状态</strong>，若<br>被挂起的进程正在执行，则转向调度程序重新调度。 </li>
<li>分时系统中，把进程从内存中移动到外存中，以释放内存资源，进程于是处于静止状态。</li>
</ul>
<h4 id="解挂原语"><a href="#解挂原语" class="headerlink" title="解挂原语"></a>解挂原语</h4><p>当挂起进程的原因被解除时，系统调用解挂<strong>原语</strong>将<strong>指定的进程解</strong>挂，使其由<strong>静止状态</strong>变为<strong>活动状态</strong>。<br>当被解挂的进程变为<strong>活动就绪</strong>时，通常立即转进程调度。</p>
<h3 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h3><ul>
<li><strong>系统模型</strong>：内核程序嵌入进程运行。</li>
<li><strong>执行模式（态）</strong>：进程可在用户态和核心态下运行。</li>
<li><strong>进程模式切换</strong>：一个进程既运行用户态程序，在系统调用和中断转换到核心态时运行操作系统核心程序。</li>
<li><strong>进程切换</strong>：指进程进入操作系统核心后因为自身等事件或有更迫切需要运行的进程就绪而让出处理机，处理机转去运行其它进程。</li>
</ul>
<h2 id="6-进程的调度"><a href="#6-进程的调度" class="headerlink" title="6. 进程的调度"></a>6. 进程的调度</h2><p><img src="/images/note2-1719059908315.png" alt="图 7">  </p>
<h3 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a>进程切换过程</h3><h4 id="PlantUML-绘图"><a href="#PlantUML-绘图" class="headerlink" title="PlantUML 绘图"></a>PlantUML 绘图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title 进程切换过程</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">:保存处理机的上下文;</span><br><span class="line">note right: 包括程序计数器PC、处理机状态字PS、其它寄存器</span><br><span class="line">:修改当前运行进程的进程控制块内容;</span><br><span class="line">note right: 将进程状态从运行态改成其它状态</span><br><span class="line">:选择另一个进程执行;</span><br><span class="line">note right: 按照调度算法</span><br><span class="line">:修改被调度进程的进程控制块;</span><br><span class="line">note right: 将其状态改变到运行态</span><br><span class="line">:修改存储管理数据结构;</span><br><span class="line">note right: 修改进程内存起始地址</span><br><span class="line">:恢复被选进程上次切换出处理机时的处理机现场;</span><br><span class="line">note right: 按原保护的程序计数器值重置程序计数器，运行新选进程</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="实例解释"><a href="#实例解释" class="headerlink" title="实例解释"></a>实例解释</h4><h5 id="示例：从进程A切换到进程B"><a href="#示例：从进程A切换到进程B" class="headerlink" title="示例：从进程A切换到进程B"></a>示例：从进程A切换到进程B</h5><p>假设我们有两个进程A和B，它们各自有自己的虚拟地址空间。当从进程A切换到进程B时，需要更新存储管理数据结构，以确保进程B能够正确访问其内存。</p>
<ol>
<li><p><strong>保存处理机的上下文</strong>：</p>
<ul>
<li>保存进程A的程序计数器（PC）、处理机状态字（PS）、和其他寄存器。</li>
</ul>
</li>
<li><p><strong>修改当前运行进程的进程控制块内容</strong>：</p>
<ul>
<li>更新进程A的进程控制块（PCB），将其状态从运行态改为等待态或就绪态。</li>
</ul>
</li>
<li><p><strong>选择另一个进程执行</strong>：</p>
<ul>
<li>按照调度算法选择进程B来执行。</li>
</ul>
</li>
<li><p><strong>修改被调度进程的进程控制块</strong>：</p>
<ul>
<li>更新进程B的进程控制块，将其状态改为运行态。</li>
</ul>
</li>
<li><p><strong>修改存储管理数据结构</strong>：</p>
<ul>
<li>更新页表：将当前页表从进程A的页表切换到进程B的页表。页表是虚拟地址到物理地址的映射。</li>
<li>例如：<ul>
<li>进程A的页表可能将虚拟地址0x0000映射到物理地址0x1000。</li>
<li>进程B的页表可能将虚拟地址0x0000映射到物理地址0x2000。</li>
</ul>
</li>
<li>切换页表意味着更新处理器中的页表基址寄存器，使其指向进程B的页表。</li>
</ul>
</li>
<li><p><strong>恢复被选进程上次切换出处理机时的处理机现场</strong>：</p>
<ul>
<li>恢复进程B的上下文，包括程序计数器、处理机状态字和其他寄存器。</li>
<li>根据保存的程序计数器值，设置程序计数器，使处理器从上次进程B切换出去时的位置继续执行。</li>
</ul>
</li>
</ol>
<p>通过这种方式，处理器能够正确访问进程B的内存地址，确保进程B的正常运行。</p>
<h3 id="调度的含义"><a href="#调度的含义" class="headerlink" title="调度的含义"></a>调度的含义</h3><p>特指<strong>选择进程占用处理机</strong>的过程。</p>
<h4 id="什么是调度"><a href="#什么是调度" class="headerlink" title="什么是调度"></a>什么是调度</h4><ul>
<li><strong>调度</strong>：是指操作系统管理了系统的有限资源，当有<strong>多个进程（或多个进程发出的请求）</strong>要使用这些资源时，因为资源的有限性，必须按照一定的原则选择进程（请求）来占用资源。这就是调度。 </li>
<li>调度的目的：控制资源使用者的数量，选取资源使用者许可占用资源。</li>
</ul>
<h4 id="几个不同的调度例子"><a href="#几个不同的调度例子" class="headerlink" title="几个不同的调度例子"></a>几个不同的调度例子</h4><ul>
<li><strong>高级调度</strong>：选取输入井中的作业（仅限于批作业调度），生成根进程，开始执行作业步。目的是控制使用系统资源的进程数。</li>
<li><strong>中级调度</strong>：选取进程占用内存或有资格占用内存，又称进程滚入滚出。</li>
<li><strong>低级调度</strong>：选取进程占用处理机，又称进程调度。</li>
<li><strong>I&#x2F;O请求调度</strong>：选取进程占用I&#x2F;O设备，执行I&#x2F;O请求。</li>
</ul>
<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul>
<li><strong>进程调度</strong>：是指操作系统根据某种算法，从就绪队列中选择一个进程，将处理机分配给它，使其执行。目的是提高处理机的利用率，使各进程能够公平地得到处理机资源。</li>
</ul>
<h3 id="进程调度的功能"><a href="#进程调度的功能" class="headerlink" title="进程调度的功能"></a>进程调度的功能</h3><ol>
<li>记录系统中各进程的执行状况。- 进程控制块</li>
<li>选择就绪队列中的一个进程，将处理机分配给它。- 进程调度程序</li>
<li>进行进程上下文切换。- 进程切换程序，保存和恢复进程的上下文</li>
</ol>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><ol>
<li><strong>用户级上下文</strong>：用户程序的执行环境，包括用户程序的代码、数据、堆栈等。</li>
<li><strong>寄存器级上下文</strong>：CPU寄存器的内容，包括程序计数器、通用寄存器、状态寄存器、PSW（程序状态字）等。</li>
<li><strong>系统级上下文</strong>：操作系统的执行环境，包括进程PCB、内核栈、内核数据结构等。</li>
</ol>
<p><strong>关于栈和栈帧的概念：</strong></p>
<ul>
<li><strong>栈</strong>：是一种数据结构，遵循先进后出（FILO）的原则。在操作系统中用于记录进程的执行历程。</li>
<li><strong>栈帧</strong>：用于存放有关的输入参数、局部变量、返回地址等信息。</li>
</ul>
<p>通常，每个进程会调用不同的过程，从而有一个各自不同的执行历程。</p>
<h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><ul>
<li><strong>非剥夺式调度</strong>：进程在运行时不会被强制中断，直到进程自己放弃CPU。用于<strong>批处理系统</strong>。主要优点在于简单，系统开销小。</li>
<li><strong>剥夺式调度</strong>：进程在运行时可能被强制中断，以便让其他进程占用CPU。用于<strong>分时系统</strong>和<strong>实时系统</strong>。主要优点在于提高系统的响应速度。</li>
</ul>
<p>进程调度在核心态下执行，因为进程调度需要访问进程控制块，而进程控制块是操作系统的数据结构，只有在核心态下才能访问。</p>
<p><img src="/images/note2-1719062136501.png" alt="图 8">  </p>
<h3 id="引起进程调度因素"><a href="#引起进程调度因素" class="headerlink" title="引起进程调度因素"></a>引起进程调度因素</h3><ol>
<li>进程主动放弃处理机<ul>
<li>正在执行的进程执行完毕</li>
<li>正在执行的进程发出I&#x2F;O请求</li>
<li>正在执行的进程发出等待信号。等待其它进程或系统发出的事件</li>
<li>正在执行的进程暂时得不到所要的系统资源</li>
</ul>
</li>
<li>为支持可剥夺的进程调度方式，有新进程就绪时——<strong>新就绪的进程可能会按某种调度原则剥夺正运行的进程，因此也应申请进行进程调度</strong><ul>
<li>当中断处理程序处理完中断，引起新进程就绪</li>
<li>当进程释放独占资源，引起等待该资源的进程就绪</li>
<li>当进程发系统调用，引起某个等待事件的进程就绪</li>
<li>其它任何原因引起有进程从其它状态变成就绪状态</li>
</ul>
</li>
<li>为支持可剥夺的进程调度方式，即使没有新就绪进程，为了让所有就绪进程轮流占用处理机，也应申请进行进程调度<ul>
<li>当<strong>时钟中断</strong>发生,时钟中断处理程序调用有关时间片的处理程序，发现正运行进程时间片到，应请求重新调度。以便让其他进程占用处理机</li>
<li>在按<strong>优先级调度</strong>时，当有进程的优先级发生变化，应请求重新调度</li>
</ul>
</li>
</ol>
<h3 id="进程调度与切换时机"><a href="#进程调度与切换时机" class="headerlink" title="进程调度与切换时机"></a>进程调度与切换时机</h3><ul>
<li><strong>当发生引起调度条件，且当前进程无法继续运行下去时</strong>（如发生各种进程放弃处理机的条件）可以马上进行调度与切换。</li>
<li><strong>当中断处理结束或自陷处理结束返回被中断进程的用户态程序执行前，若请求调度标志置上</strong>，即可马上进行进程调度与切换。<strong>如果操作系统支持这种情况下运行调度程序，即实现了剥夺方式的调度</strong>。</li>
<li>实时系统还有其他调度与切换时机。</li>
</ul>
<p><img src="/images/note2-1719063319664.png" alt="图 10">  </p>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li>要求：高资源利用率、低系统开销、公平性、响应时间短、吞吐量大。</li>
<li>与整个系统的设计目的相一致：<ul>
<li><strong>批处理系统</strong>：高资源利用率、高吞吐量。</li>
<li><strong>分时系统</strong>：响应时间短、公平性。</li>
<li><strong>实时系统</strong>：保证任务在规定时间内完成。</li>
</ul>
</li>
</ul>
<h4 id="调度算法评价因素"><a href="#调度算法评价因素" class="headerlink" title="调度算法评价因素"></a>调度算法评价因素</h4><ol>
<li>吞吐量：单位时间内CPU完成的作业数量。<ul>
<li>如果在10s内完成了10个作业，那么吞吐量为1个作业&#x2F;秒。</li>
</ul>
</li>
<li>CPU利用率<ul>
<li>CPU利用率 &#x3D; CPU繁忙时间 &#x2F; （CPU繁忙时间 + CPU空闲时间）</li>
</ul>
</li>
<li>周转时间：从作业提交到作业完成所经历的时间。是评价批处理系统性能的重要指标。<ul>
<li>周转时间 &#x3D; 完成时间 - 到达时间<br>  $T_i &#x3D; C_i - A_i$</li>
<li>例如，作业A 8:00提交，执行1小时，完成时间为10:00，则周转时间为2小时。</li>
<li>平均周转时间 &#x3D; 所有作业的周转时间之和 &#x2F; 作业数<br>  $\bar{T} &#x3D; \sum_{i&#x3D;1}^{n} T_i &#x2F; n$</li>
</ul>
</li>
</ol>
<p><img src="/images/note2-1719063791898.png" alt="图 11">  </p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><table>
<thead>
<tr>
<th>算法</th>
<th>公平性</th>
<th>吞吐量</th>
<th>及时性</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务（FCFS）</td>
<td>优</td>
<td>低</td>
<td>差</td>
<td>长</td>
</tr>
</tbody></table>
<h5 id="先来先服务（FCFS）——First-Come-First-Served"><a href="#先来先服务（FCFS）——First-Come-First-Served" class="headerlink" title="先来先服务（FCFS）——First Come First Served"></a>先来先服务（FCFS）——First Come First Served</h5><ul>
<li>含义：按照作业提交的先后顺序进行调度。</li>
</ul>
<p><img src="/images/note2-1719063853880.png" alt="图 12">  </p>
<p>优点：简单、可靠；容易理解；非抢占式。<br>缺点：平均等待时间长；不适合分时系统。</p>
<p>例如，对于同时到达的三个作业 $j_1$、$j_2$、$j_3$，它们的到达时间分别为0、1、2，执行时间分别为20、20、4。则它们的周转时间分别为20、40、42。平均周转时间为34。这明显增长了平均周转时间。</p>
<p>对于进程的调度，可以采用甘特图来描述：</p>
<p><img src="/images/note2-1719064558945.png" alt="图 13">  </p>
<h5 id="短进程优先（SPF）——Shortest-Process-First"><a href="#短进程优先（SPF）——Shortest-Process-First" class="headerlink" title="短进程优先（SPF）——Shortest Process First"></a>短进程优先（SPF）——Shortest Process First</h5><ul>
<li>含义：按照作业的执行时间长短进行调度。也可以采用剥夺调度方式（Shortest Remaining Time First）。这种方式可以使平均等待时间最小。</li>
</ul>
<p><img src="/images/note2-1719064756679.png" alt="图 14">  </p>
<p>对于上图中的四个作业：</p>
<ul>
<li>若采用非剥夺方式，可先画出甘特图，然后计算平均周转时间。各个进程等待时间为：0、6、3、7，平均等待时间为4。</li>
<li>若采用剥夺方式，可先画出甘特图，然后计算平均周转时间。各个进程等待时间为：9、1、0、2，平均等待时间为3。</li>
</ul>
<p>虽然短进程优先算法可以减少平均等待时间，提高吞吐量，但是对长进程不公平，可能会导致长进程饥饿，也没有考虑到作业的优先级。同时，我们也需要考虑到进程的执行时间是难以预测的。</p>
<h5 id="优先级调度（PS）——Priority-Scheduling"><a href="#优先级调度（PS）——Priority-Scheduling" class="headerlink" title="优先级调度（PS）——Priority Scheduling"></a>优先级调度（PS）——Priority Scheduling</h5><ul>
<li>含义：按照作业的优先级进行调度。优先级高的作业先执行。具有相同优先级的作业按照FCFS的方式进行调度。</li>
<li>优先级的确定：<ul>
<li>运行前：根据作业的重要性、紧迫性、资源需求等确定优先级。</li>
<li>运行中：<ul>
<li>动态优先级：根据作业的等待时间、执行时间等动态调整优先级。</li>
<li>静态优先级：作业提交时确定优先级，不再改变。一般赋予系统进程较高的优先级。</li>
</ul>
</li>
</ul>
</li>
<li>优点：灵活、适应性强、实现简单、通过优先级动态调整可以平衡系统性能。</li>
<li>问题：静态优先级法会导致无穷阻塞问题，即优先级高的进程会一直占用CPU，导致优先级低的进程无法执行。</li>
<li>进程占用CPU的方式：<ul>
<li><strong>非抢占式</strong>：进程一旦占用CPU，直到进程自己放弃CPU。FCFS。</li>
<li><strong>抢占式</strong>：进程在运行时可能被强制中断，以便让其他进程占用CPU。会使进程频繁调度，增加系统开销。</li>
</ul>
</li>
</ul>
<p><img src="/images/note2-1719065275315.png" alt="图 15">  </p>
<p>上述平均等待时间为：**(6+0+16+18+1)&#x2F;5&#x3D;8.2**</p>
<p><img src="/images/note2-1719065376932.png" alt="图 16">  </p>
<p>上述平均等待时间为：**((1+5)+0+14+15+0)&#x2F;5&#x3D;7**</p>
<h5 id="时间片轮转调度（RR）——Round-Robin"><a href="#时间片轮转调度（RR）——Round-Robin" class="headerlink" title="时间片轮转调度（RR）——Round Robin"></a>时间片轮转调度（RR）——Round Robin</h5><ul>
<li>含义：按照时间片的方式进行调度。每个进程被分配一个时间片，当时间片用完后，进程被剥夺CPU，放回就绪队列，等待下一次调度。</li>
</ul>
<p><img src="/images/note2-1719065451457.png" alt="图 17">  </p>
<ul>
<li><strong>时间片</strong>：是指CPU分配给进程的最小时间单位。时间片的大小会影响进程的响应时间和系统的吞吐量。<ul>
<li>固定时间片：所有进程都分配相同的时间片。</li>
<li>动态时间片：根据进程的优先级、历史运行时间等动态调整时间片。</li>
</ul>
</li>
<li><strong>时间片轮转调度</strong>的优点：<ul>
<li>公平性：每个进程都有机会占用CPU。</li>
<li>响应时间短：每个进程都有机会在一个时间片内执行。</li>
<li>适用于分时系统：适用于多用户的分时系统，可以保证每个用户都有机会占用CPU。</li>
</ul>
</li>
<li><strong>时间片轮转调度</strong>的缺点：<ul>
<li>时间片过大：会导致进程响应时间长，退化为FCFS。</li>
<li>时间片过小：会导致进程切换频繁，增加系统开销。</li>
</ul>
</li>
</ul>
<p><img src="/images/note2-1719065539671.png" alt="图 18">  </p>
<p>上述平均等待时间为：**((57+24)+20+(37+40+17)+(57+40))&#x2F;4&#x3D;73**</p>
<h5 id="多级反馈队列调度（MFQ）——Multilevel-Feedback-Queue"><a href="#多级反馈队列调度（MFQ）——Multilevel-Feedback-Queue" class="headerlink" title="多级反馈队列调度（MFQ）——Multilevel Feedback Queue"></a>多级反馈队列调度（MFQ）——Multilevel Feedback Queue</h5><ul>
<li>含义：按照多个队列的方式进行调度。每个队列有不同的优先级，不同的时间片。当进程在一个队列中等待时间过长时，会被移到下一个队列中。进程<strong>被调度执行</strong>后，在<strong>被剥夺或放弃处理机</strong>后而在就绪时可以<strong>改变其就绪队列</strong>。</li>
</ul>
<p><img src="/images/note2-1719065607216.png" alt="图 19">  </p>
<p>设计另一个多级反馈队列调度算法的例子：</p>
<ul>
<li>以<strong>优先级</strong>设置多队列。</li>
<li>各队列的调度算法采用<strong>FCFS+时间片</strong>。</li>
<li>进程优先级升降原则是：<strong>等待CPU过久升，I&#x2F;O完成插入就绪队列时升，运行完一个完整时间片降</strong>…</li>
<li>进程最初进入就绪队列以用户初置优先级为参数。</li>
</ul>
<h5 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h5><ul>
<li>时钟驱动法：各任务的调度安排通常是在系统运行前就确定了。硬实时系统的任务是固定的和可知的。系统以规则的间隔时间调度任务执行。一个定时器被周期性地设置，时间到期后，系统启动要执行的任务。</li>
<li>加权轮转法：进程的权就是分配给它的一小部分处理机时间。轮转时，不同的进程可以获得不同的处理机时间。广泛用在高速开关网的实时控制中。</li>
</ul>
<h5 id="作业调度算法——FIFO、SJF和最高响应比优先（HRRN）"><a href="#作业调度算法——FIFO、SJF和最高响应比优先（HRRN）" class="headerlink" title="作业调度算法——FIFO、SJF和最高响应比优先（HRRN）"></a>作业调度算法——FIFO、SJF和最高响应比优先（HRRN）</h5><p><img src="/images/note2-1719065913022.png" alt="图 20"> </p>
<p><strong>响应比R</strong>定义如下： <strong>R &#x3D;(W+T)&#x2F;T &#x3D; 1+W&#x2F;T</strong>（W为作业等待时间，T作业估计运行时间）</p>
<p>优点：结合了先来先服务、短作业优先的方法。优先运行短作业和等待时间足够长的长作业。</p>
<h2 id="7-线程"><a href="#7-线程" class="headerlink" title="7. 线程"></a>7. 线程</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><h4 id="轻权进程（Lightweight-Process）"><a href="#轻权进程（Lightweight-Process）" class="headerlink" title="轻权进程（Lightweight Process）"></a>轻权进程（Lightweight Process）</h4><ul>
<li>在前文中，提到引入进程实际上是为了实现作业内的作业步并发执行。但是同一作业进程之间会存在许多协作，需要进行频繁的数据交换。但是，每个进程都有自己独立的存储空间，互不干扰，会导致如果需要进行进程间的数据交换，那么就会调用系统调用，增加系统开销。</li>
<li>为了方便进程间的数据交换，一种共享存储空间的机制被引入，即轻权进程。</li>
</ul>
<h4 id="线程的引入"><a href="#线程的引入" class="headerlink" title="线程的引入"></a>线程的引入</h4><ul>
<li>随着共享内存多CPU计算机的发展，迫切需要加速单个作业步的运行速度，事实上同一个作业步的工作也是有可并行成份的。因为进程内程序执行的顺序性，不可能实现<strong>进程内可并行成分的并行执行</strong>。为此，线程的概念呼之欲出。在一个进程中可以包含多个可以并发（并行）执行的线程。系统按<strong>进程</strong>分配所有<strong>除CPU以外的系统资源</strong>（如内存，外设，文件等），而程序则依赖于线程运行，系统<strong>按线程分配CPU资源</strong>。</li>
</ul>
<h4 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h4><ul>
<li><strong>线程</strong>：也叫轻权进程，是操作系统能够进行运算（处理机）调度的最小单位，是一个<strong>可执行实体</strong>。它被包含在进程之中，是进程中的实际运作单位。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。</li>
<li>在引入线程后，线程便成为进程的组成成分，由进程创建，一个进程中至少有一个线程，即主线程。线程是进程的执行单元，一个进程中的多个线程共享进程的资源。</li>
<li>进程仍然是系统资源分配的基本单位，线程只能在进程的上下文（地址空间）中运行。</li>
<li>一个例子是，我们可以有一个进程，其中包含一个GUI线程、一个网络线程、一个I&#x2F;O线程等。它们分别处理不同的任务，但是共享进程的资源（如内存、文件等）。</li>
<li>由于线程共享进程的资源（地址空间、可用数据），附带资源不多，创建和撤销线程的开销小，线程切换速度快。</li>
</ul>
<h4 id="线程的结构与特点"><a href="#线程的结构与特点" class="headerlink" title="线程的结构与特点"></a>线程的结构与特点</h4><p><img src="/images/note2-1719129457138.png" alt="图 21">  </p>
<ul>
<li>线程作为基本的调度单位，有与进程相似的状态：<strong>就绪、运行、阻塞</strong>等。</li>
<li>同一进程中的所有线程都共享进程的存储空间和分配资源。</li>
</ul>
<p>线程由以下几部分组成：</p>
<ul>
<li><strong>线程ID</strong>：线程的唯一标识符。</li>
<li><strong>寄存器组</strong>：表示处理机状态和运行现场的一组寄存器。</li>
<li><strong>两个堆栈</strong>：分别用于用户态和核心态调用时进行参数传递。</li>
<li><strong>程序计数器</strong>：指向下一条要执行的指令。</li>
<li><strong>关联的进程和其他线程</strong>：线程是进程的一部分，一个进程中至少有一个线程。</li>
</ul>
<p>线程的优势：</p>
<ul>
<li>创建和撤消线程的开销非常小。不需要向系统请求独立的地址空间及进行相关的地址空间复制(例如父子进程)，因此创建和撤销线程系统的开销要远小于进程。</li>
<li>切换迅速。线程的上下文环境要比进程简单的多，因此线程间的切换远比进程快的多。</li>
<li>通信效率高。同一进程中的线程由于共享同一地址空间，通信时不需要借助内核功能。</li>
<li>并发度高。在多处理机系统中，对进程的个数是有所限制的，但对线程的个数理论上不存在限制，更发挥了多处理机系统的优势。</li>
</ul>
<h4 id="与进程的比较"><a href="#与进程的比较" class="headerlink" title="与进程的比较"></a>与进程的比较</h4><ul>
<li>拥有的资源：进程拥有独立的地址空间，线程共享进程的地址空间。</li>
<li>调度：进程是系统资源分配的基本单位，线程是CPU调度的基本单位。</li>
<li>并发性：进程之间、进程内的多线程之间可并发执行。</li>
<li>安全性：同一进程的多线程共享进程的所有资源，一个线程可以改变另一个线程的数据，共享方便。</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><img src="/images/note2-1719129925322.png" alt="图 22">  </p>
<p>完全由用户来管理线程的切换，处理机在两个线程间切换时不用进入到核心态执行，节省了用户态与核心态之间切换的开销。不过，用户级线程的缺点是，当一个线程阻塞时，整个进程都会阻塞。</p>
<h4 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h4><p><img src="/images/note2-1719130157061.png" alt="图 23">  </p>
<p>核心可以调度一个进程中的多个线程同时运行，当某线程发生阻塞，可以调度其它线程执行。</p>
<p>优点是充分发挥了多处理机的并行工作能力，但是在同一进程间线程控制权转移时，用户态和核心态之间的切换开销较大。</p>
<p>与用户级线程的区别主要在于线程表的位置，用户级线程的线程表在用户空间，核心级线程的线程表在内核空间。</p>
<h4 id="系统对于线程的支持"><a href="#系统对于线程的支持" class="headerlink" title="系统对于线程的支持"></a>系统对于线程的支持</h4><ul>
<li><strong>用户级线程</strong>：线程的创建、撤销、切换等操作都由用户程序完成，系统不支持线程的调度。内核以进程为单位进行调度。一个线程阻塞，其依附的进程也阻塞。<ul>
<li><strong>运行时系统</strong>：一个管理线程的过程集合，包括：thread_create、thread_exit、thread_wait。对于用户级线程，运行时系统是用户程序的一部分。</li>
</ul>
</li>
<li><strong>核心级线程</strong>：有关线程的管理工作都由内核完成。应用程序通过系统调用来创建或撤销线程。Windows、Linux等操作系统支持核心级线程。</li>
<li><strong>混合级线程</strong>：既支持用户级线程，也支持核心级线程。用户级多个线程对应核心级多个线程。当内核了解到一个线程阻塞后，通知运行时系统，重新调度其他线程。<ul>
<li><img src="/images/note2-1719130563270.png" alt="图 26">  </li>
<li>在这种模式下，处理机的调度程序看到的核心级线程可能对应着多个用户级线程。当一个用户级线程及对应核心级线程阻塞时，处理机的调度程序可以选择另一个核心级线程执行。</li>
</ul>
</li>
<li>由于线程拥有较少的资源，又具有传统进程的许多特性，因此有的把线程叫做<strong>轻型进程</strong>。把传统的进程叫做<strong>重型进程</strong>。 <ul>
<li>Linux，线程就是**轻量级进程(LightWeight Process)**。一个进程拥有一组共享其地址空间和资源的轻量级进程。Clone()函数创建进程时，系统同时为进程创建第一个线程。进程中的其它线程是通过调用线程创建原语显式创建的。</li>
<li>Windows, 创建线程的函数 CreateThread(…,lpStartAddress,… )</li>
</ul>
</li>
</ul>
<h2 id="8-进程的通信"><a href="#8-进程的通信" class="headerlink" title="8. 进程的通信"></a>8. 进程的通信</h2><ul>
<li>什么是进程通信？<ul>
<li>进程通信是指进程之间的信息交换和共享资源的过程。进程通信是操作系统中的一个重要概念，是多进程协作完成任务的基础。</li>
</ul>
</li>
<li>分类：<ul>
<li>按照交换信息量的多少：<ul>
<li>低级通信：只能传递状态和整数值（控制信息）<ul>
<li><img src="/images/note2-1719131093294.png" alt="图 27">  </li>
<li>不过只能传递少量信息，效率低，如果需要传递大量信息，需要多次通信。同时，也会导致编程复杂，用户直接实现通信细节。</li>
</ul>
</li>
<li>高级通信：提高信号通信效率，传递大量数据，减轻程序编制的复杂度<ul>
<li><img src="/images/note2-1719132135194.png" alt="图 28"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高级通信的三种方式：<ul>
<li><strong>共享内存</strong>：多个进程共享同一块内存区域，进程间通过读写共享内存来实现通信。</li>
<li><strong>消息传递</strong>：进程间通过发送消息来实现通信。</li>
<li><strong>共享文件</strong>：多个进程共享同一文件，进程间通过读写文件来实现通信。</li>
</ul>
</li>
</ul>
<h3 id="两种基本进程通讯方法"><a href="#两种基本进程通讯方法" class="headerlink" title="两种基本进程通讯方法"></a>两种基本进程通讯方法</h3><ul>
<li><strong>共享存储</strong>：相互通讯的进程有共享存储区.进程间可以通过直接读写共享存储区的变量来交互数据，同步与互斥在并发程序设计时安排进入程序。操作系统提供这样的共享存储区及同步互斥工具。</li>
<li><strong>消息传递</strong>：通过操作系统的相应系统调用进行消息传递通讯。</li>
</ul>
<h4 id="共享内存模式-间接通信"><a href="#共享内存模式-间接通信" class="headerlink" title="共享内存模式(间接通信)"></a>共享内存模式(间接通信)</h4><ul>
<li><strong>共享内存</strong>：是指两个或多个进程共享一个给定的存储区。这种通信方式是最快的一种通信方式，因为进程可以直接读写共享内存，不需要操作系统的介入。<ul>
<li><img src="/images/note2-1719133007134.png" alt="图 29"></li>
</ul>
</li>
<li>内存共享区的互斥要通过其它机制实现；数据的发送方不关心数据由谁接收，数据的接收方也不关心数据是由谁发送的，存在安全隐患。</li>
</ul>
<h4 id="消息传递模式"><a href="#消息传递模式" class="headerlink" title="消息传递模式"></a>消息传递模式</h4><ul>
<li><strong>消息传递</strong>：<ul>
<li>直接通信方式：点到点的发送<ul>
<li>Send (DestProcessName, Message)；<br>Receive (SourceProcessName, Message)；</li>
<li>进程在发送和接收消息时直接指明接收者或发送者进程ID。</li>
<li>必须指定接收者或发送者的ID，不适合多对多通信。</li>
</ul>
</li>
<li>间接通信方式：通过消息队列传递消息（信箱）<ul>
<li>Send (MailBox, Message)；<br>Receive (MailBox, Message)；</li>
<li>系统为每个信箱设一个消息队列，消息发送和接收都指向该消息队列。</li>
<li>很容易建立双向通讯链(只要对信箱说明为读写打开)。；不过必须有一个通讯双方共享的一个<strong>逻辑消息队列</strong>（ UNIX的PIPE，FIFO及IPC消息传递机制都属于这种形式），使用时消息发送者约定写方式打开信箱,消息接收者约定读方式打开信箱或同时读写打开。</li>
<li><img src="/images/note2-1719133445875.png" alt="图 30"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="进程消息传递通信实现"><a href="#进程消息传递通信实现" class="headerlink" title="进程消息传递通信实现"></a>进程消息传递通信实现</h5><p>直接通信消息系统，两个基本操作为：</p>
<ul>
<li><p><strong>Send(&amp;A)：&amp;A</strong>指向含接收者pid和消息正文的空间。</p>
</li>
<li><p><strong>Receive(&amp;A)：&amp;A</strong>指向缓冲区用于接收消息，该系统调用函数返回值是消息发送者pid。</p>
</li>
<li><p>实现：</p>
<ul>
<li>系统有一空闲缓冲区池，每个进程有一个消息缓冲队列。缓冲区用于存放消息及消息发送者pid和消息链(用pid定位进程PCB表)。</li>
<li>每个进程的消息队列存放发送给该进程的消息，队列头存于<strong>PCB</strong>中，同时在PCB中设一互斥信号量<strong>mutex(初值为1)<strong>和</strong>信号量Sm（初值为0）</strong>，Sm用于记录消息队列中的消息数。</li>
<li><img src="/images/note2-1719133730050.png" alt="图 31">  </li>
<li><img src="/images/note2-1719133784108.png" alt="图 32">  </li>
<li>实际流程是，发送进程使用发送原语向接收进程发送消息，发送的消息会被放入接收进程的消息队列中，接收进程使用接收原语接收消息。这里面存在的临界资源是<strong>消息队列</strong>，需要使用互斥信号量进行保护。</li>
</ul>
</li>
<li><p>发送原语类C伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Send(&amp;A): </span><br><span class="line">  &#123;</span><br><span class="line">    New(&amp;p)；从空缓冲区队列得一个buffer</span><br><span class="line">    ...</span><br><span class="line">    置sender’s pid；</span><br><span class="line">    将A中消息送buffer p；</span><br><span class="line">    获得A中Receiver’s pid；</span><br><span class="line">    P(mutex)；</span><br><span class="line">    将buffer p挂入相应的消息队列；</span><br><span class="line">    V(Sm)；</span><br><span class="line">    V(mutex)；</span><br><span class="line">  &#125;；</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收原语类C伪代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Receive(&amp;A)：</span><br><span class="line">  &#123;</span><br><span class="line">    P(Sm)；<span class="comment">//消耗一个消息</span></span><br><span class="line">    P(mutex)；<span class="comment">//互斥信号量</span></span><br><span class="line">    从本进程的消息队列取一个buffer f；</span><br><span class="line">    V(mutex)；<span class="comment">//释放互斥信号量</span></span><br><span class="line">    从buffer f中取得消息正文送A,并得到   </span><br><span class="line">    sender’s pid作为Receive( )的返回值；</span><br><span class="line">    ...</span><br><span class="line">    dispose(f)；#释放buffer f到空缓冲队列</span><br><span class="line">    …</span><br><span class="line">  &#125;；</span><br></pre></td></tr></table></figure></li>
</ul>
<p>需要注意的是，上面提到的<strong>new,dispose</strong>函数对<strong>空缓冲<br>区池</strong>的访问也需要互斥。</p>
<h5 id="提高并发性：将一个共享资源分解为多个更小的共享资源"><a href="#提高并发性：将一个共享资源分解为多个更小的共享资源" class="headerlink" title="提高并发性：将一个共享资源分解为多个更小的共享资源"></a>提高并发性：将一个共享资源分解为多个更小的共享资源</h5><p>将原来的生产者消费者问题的共享资源–缓冲池（含满、空缓冲区队列），变为n（n个进程满缓冲区队列）+1（空缓冲区队列）个共享资源。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>是一种信息流缓冲机构， UNIX系统中管道基于<strong>文件系统</strong>，在内核中通过<strong>文件描述符</strong>表示。管道以<strong>先进先出(FIFO)方式</strong>组织数据传输。</p>
<p><img src="/images/note2-1719134308101.png" alt="图 33">  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用pipe()函数创建管道</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>; </span><br><span class="line">  <span class="comment">// fd[0]为管道里的读取端</span></span><br><span class="line">  <span class="comment">// fd[1]则为管道的写入端。 </span></span><br><span class="line"><span class="comment">//通过write()函数写入信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span> <span class="params">(<span class="type">int</span> handle,<span class="type">char</span> *buf,<span class="type">unsigned</span> len)</span></span><br><span class="line"><span class="comment">//进程通过read()函数读取信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span> <span class="params">(<span class="type">int</span> handle,<span class="type">void</span> *buf,<span class="type">unsigned</span> len)</span></span><br></pre></td></tr></table></figure>

<h4 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h4><ul>
<li>管道是一种<strong>半双工通信</strong>方式，数据只能单向流动，只能在一个方向上进行通信。如果进程间要进行双向通信，通常需要定义两个管道。</li>
<li>管道通过<strong>文件描述符</strong>进行通信，因此可以使用**read()<strong>和</strong>write()**函数进行通信。</li>
</ul>
<h4 id="管道的分类"><a href="#管道的分类" class="headerlink" title="管道的分类"></a>管道的分类</h4><ul>
<li><strong>匿名管道</strong>：只能用于具有<strong>亲缘关系</strong>的进程间通信，通常在一个进程创建子进程后使用。管道能够把信息从一个进程的地址空间拷贝到另一个进程的地址空间。</li>
<li><strong>命名管道</strong>：允许无亲缘关系的进程间通信，也称为FIFO。FIFO是一种文件类型，它在文件系统中有对应的文件名。FIFO可以通过文件系统调用来创建和打开。命名管道有自己的名字和访问权限的限制，就像一个文件一样。它可以用于不相关进程间的通信，进程通过使用管道的名字获得管道。</li>
</ul>
<h4 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h4><p>管道的工作原理如下：</p>
<ol>
<li>创建管道：操作系统提供了创建管道的系统调用。当一个管道被创建时，它会创建两个文件描述符：一个用于读取，另一个用于写入。</li>
<li>数据传输：写进程可以通过写文件描述符向管道中写入数据，而读进程则可以通过读文件描述符从管道中读取数据。写入管道的数据会被缓存，直到被读取。</li>
<li>数据拷贝：当数据被写入管道时，操作系统会将数据从写进程的地址空间拷贝到内核缓冲区；当读进程从管道读取数据时，操作系统再将数据从内核缓冲区拷贝到读进程的地址空间。这样，就实现了从一个进程的地址空间到另一个进程的地址空间的数据传输。</li>
<li>管道的关闭：当不再需要通信时，进程可以关闭管道的读写文件描述符。如果写端被关闭，读端读取完所有数据后会接收到文件结束符（EOF）；如果读端被关闭，写端写入数据时会收到一个SIGPIPE信号。</li>
</ol>
<h2 id="9-易错点"><a href="#9-易错点" class="headerlink" title="9. 易错点"></a>9. 易错点</h2><ol>
<li><p>并发进程执行的相对速度与进程调度策略有关，因为进程调度策略决定了哪些进程可以获得处理机，以及获得处理机的时间长短，从而影响进程执行的速度和效率。</p>
</li>
<li><p>一个进程可以顺序地执行一个或多个程序，只要在执行过程中改变其CPU状态和内存空间即可，但不能同时执行多个程序</p>
</li>
<li><p>用户登录时，操作系统会为用户创建一个登录进程，用于验证用户身份和提供用户界面。<strong>高级调度即作业调度</strong>，会从后备队列上选择一个作业调入内存，并为之创建相应的进程。<strong>操作系统响应用户提出的请求时，通常会为用户创建一个子进程，用于执行用户指定的任务或程序。</strong>用户打开一个浏览器程序时，也是一种操作系统响应用户请求的情况，同样会创建一个新进程。</p>
</li>
<li><p>I&#x2F;O操作完成之前进程在等待结果，状态为阻塞态：完成后进程等待事件就绪，变为就绪态。</p>
</li>
<li><p>线程的优点有提高系统并发性、节约系统资源、便于进程通信等，但线程并不能增强进程安全性，因为线程共享进程的地址空间和资源，若一个线程出错，则可能影响整个进程的运行。</p>
</li>
<li><p>在内核级线程中，同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。不能认为使用了内核级线程就可以提高系统性能。</p>
</li>
<li><p><strong>一对一模型</strong>和<strong>多对多模型</strong>能充分利用内核级线程，发挥多处理机的优势，能同时调度同一个进程中的多个线程并发执行，具有较好的并发性。</p>
</li>
<li><p>普通管道只允许<strong>单向通信</strong>，数据只能往一个方向流动，要实现双向数据传输，就需要定义两个方向相反的管道。<strong>管道是一种存储在内存中的、固定大小的缓冲区，管道的大小通常为内存的一页</strong>，其大小并不是受磁盘容量大小的限制。由于管道的读&#x2F;写操作都可能遇到缓冲区满或空的情况，当管道满时，写操作会被阻塞，直到有数据读出；而当管道空时，读操作会被阻塞，直到有数据写入。<strong>一个管道可以有多个读进程或多个写进程对其进行操作</strong>，但是这会增加数据竞争和混乱的风险，为了避免这种情况，<strong>应使用互斥锁或信号量等同步机制</strong>来保证每次只有一个进程对管道进行读或写操作。</p>
</li>
<li><p>为何进程之间的通信必须借助操作系统的内核功能？</p>
<ul>
<li>每个进程有自己<strong>独立的地址空间</strong>。在操作系统和硬件的地址保护机制下，进程无法访问其他进程的地址空间，必须借助于系统调用函数实现进程之间的通信。</li>
</ul>
</li>
<li><p>什么是多线程？与多任务由什么区别？</p>
<ul>
<li>多线程是指在<strong>一个程序中可以定义多个线程并同时运行它们</strong>，每个线程可以执行不同的任务。<strong>多线程与多任务的区别：</strong>多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数：多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。</li>
</ul>
</li>
<li><p>为什么要进行CPU调度？</p>
<ul>
<li>如果没有CPU调度，那么一个进程会一直占用CPU直到进程结束，这样会导致其他进程无法获得CPU资源，从而无法执行。而在该进程执行过程中，还可能会发生I&#x2F;O操作等等产生阻塞，这样会导致CPU资源的浪费。因此，CPU调度是为了合理分配CPU资源，提高CPU的利用率。</li>
</ul>
</li>
<li><p>设计调度算法时应考虑的指标有很多，比较常见的有公平性、资源利用率、平均周转时间平均等待时间、平均响应时间。<strong>互斥性不是调度算法设计时需要考虑的指标，而是一种同步机制，用来保证多个进程访问临界资源时不会发生冲突。</strong></p>
</li>
<li><p>处于临界区的进程也可能因中断或抢占而导致调度。此外，若进程在临界区内请求的是一个需要等待的资源，比如打印机，则它主动放弃CPU,让其他进程运行。</p>
</li>
<li><p><strong>FCFS</strong>调度算法比较有利于<strong>长作业</strong>，而不利于短作业。CPU繁忙型作业是指该类作业需要占用很长的CPU时间，而很少请求I&#x2F;O操作，因此<strong>CPU繁忙型作业类似于长作业</strong>，采用FCFS可从容完成计算。<strong>I&#x2F;O繁忙型作业</strong>是指作业执行时需频繁请求I&#x2F;O操作，即<strong>可能频繁放弃CPU</strong>,所以占用CPU的时间不会太长，一旦放弃CPU,则必须重新排队等待调度，故采用SJF比较适合。时间片轮转法对于短作业和长作业的时间片都一样，所以地位也几乎一样。优先级调度有利于优先级高的进程，而优先级和作业时间长度是没有必然联系的。</p>
</li>
<li><p>实时系统必须能足够及时地处理某些紧急的外部事件，因此普遍用高优先级，并用“可抢占”来确保实时处理。</p>
</li>
<li><p><strong>优先级算法中，I&#x2F;O繁忙型作业要优于计算繁忙型作业</strong>，系统进程的优先权应高于用户进程的优先权。作业的优先权与长作业、短作业或系统资源要求的多少没有必然的关系。在动态优先权中，<strong>随着进程执行时间的增加其优先权随之降低，随着作业等待时间的增加其优先权相应上升。</strong></p>
</li>
<li><p><strong>多级反馈队列调度算法能较好地满足各种类型用户的需要</strong>。对<strong>终端型作业</strong>用户而言，由于它们提交的作业大多属于交互型作业，作业通常比较短小，系统只要能使这些作业在第1级队列所规定的时间片内完成，便可使终端型作业用户感到满意：对于<strong>短批处理作业</strong>用户而言，它们的作业开始时像终端型作业一样，若仅在第1级队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间，对于稍长的作业，通常也只需要在第2级队列和第3级队列中各执行一个时间片即可完成，其周转时间仍然较短：对于<strong>长批处理作业</strong>用户而言，它们的长作业将依次在第1,2，…，级队列中运行，然后按时间片轮转方式运行，用户不必担心其作业长期得不到处理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记2——进程并发、同步与互斥</title>
    <url>/2024/06/23/note2-2/</url>
    <content><![CDATA[<h1 id="进程并发、同步与互斥"><a href="#进程并发、同步与互斥" class="headerlink" title="进程并发、同步与互斥"></a>进程并发、同步与互斥</h1><h2 id="1-进程并发执行的问题"><a href="#1-进程并发执行的问题" class="headerlink" title="1. 进程并发执行的问题"></a>1. 进程并发执行的问题</h2><blockquote>
<p>在本部分，要了解可并行程序的高级语言表示和操作系统的支持；了解并发执行引起的同步和互斥问题；了解进程的同步和互斥的基本概念。</p>
</blockquote>
<h3 id="1-1-并发的需求"><a href="#1-1-并发的需求" class="headerlink" title="1.1 并发的需求"></a>1.1 并发的需求</h3><ul>
<li>程序设计上，要利用操作系统对于并发的支持（进程&#x2F;线程），安排可并行事务并发执行</li>
<li>操作系统的核心程序也要尽可能并发的执行</li>
</ul>
<h3 id="1-2-并发编程"><a href="#1-2-并发编程" class="headerlink" title="1.2 并发编程"></a>1.2 并发编程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">fork</span><br><span class="line">  :Task1;</span><br><span class="line">fork again</span><br><span class="line">  :Task2;</span><br><span class="line">fork again</span><br><span class="line">  :Task3;</span><br><span class="line">end fork</span><br><span class="line">:Task4;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="/images/note2-2-1719152050658.png" alt="图 0">  </p>
<ul>
<li><p>三种并发编程的方法</p>
<ul>
<li>程序员写顺序程序，用自动识别工具识别可并行成分，组织使用操作系统的进程或线程实现并发。</li>
<li>由程序员识别可并行成分，用并发程序设计语言设计并发程序，由编译系统安排使用进程或线程；</li>
<li>在传统语言基础上，利用操作系统的进程或线程系统调用设计并发程序。</li>
</ul>
</li>
</ul>
<h3 id="1-3-并发设计语言"><a href="#1-3-并发设计语言" class="headerlink" title="1.3 并发设计语言"></a>1.3 并发设计语言</h3><h4 id="并发语句"><a href="#并发语句" class="headerlink" title="并发语句"></a>并发语句</h4><p>语法形式：<br>    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    S1; S2; ...; Sn</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure></p>
<p>在上面的语法中，S1; S2; …; Sn 是并发执行的语句序列，Parbegin 和 Parend 是并发执行的开始和结束标志。</p>
<p>例如，下面的程序段中的语句 S1 和 S2 是并发执行的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    S1;</span><br><span class="line">    S2;</span><br><span class="line">Parend</span><br><span class="line">S3;</span><br></pre></td></tr></table></figure>

<p>但是，仍然存在着用Parbegin&#x2F;Parend语句无法描述的并发优先关系。</p>
<p><img src="/images/note2-2-1719152276700.png" alt="图 1">  </p>
<p>而对于这样的并发优先关系，就有必要引入其他的并发控制语句，如：并发信号量机制。</p>
<h3 id="1-4-并发执行实现"><a href="#1-4-并发执行实现" class="headerlink" title="1.4 并发执行实现"></a>1.4 并发执行实现</h3><ul>
<li>实现并发执行，需要通过操作系统支持的<strong>进程</strong>或<strong>线程</strong>机制来实现。</li>
<li>操作系统提供进程（线程）<strong>创建</strong>、<strong>结束</strong>、<strong>同步</strong>的系统调用，可直接提供给用户编写并行程序；或由并行语言编译器将并发语言的语句转化为对操作系统的系统调用。</li>
</ul>
<p>例如，Linux提供了<code>fork()</code>和<code>exec()</code>等系统调用，可以用于创建进程和执行程序。</p>
<ul>
<li><code>fork()</code>：创建一个新进程。该系统调用执行完成后，系统已创建了一个子进程，该子进程逻辑复制（共享）了父进程的程序，复制了父进程的数据段和栈段。也就是说不管是父进程还是子进程，在占有处理机后，都从系统调用的返回点开始运行，父进程系统调用的返回值是子进程的进程标识<code>pid</code>；子进程的返回值是<code>0</code>，子进程从<code>trap</code>指令后一条指令开始运行。<br>  <img src="/images/note2-2-1719152517272.png" alt="图 2">  </li>
<li><code>exec()</code>：执行一个程序。该系统调用执行完成后，系统已经用新的程序替换了当前进程的程序，新程序的代码段、数据段和栈段都已经加载到内存中，当前进程的程序已经被新程序替换，新程序从<code>trap</code>指令后一条指令开始运行。</li>
<li><code>exit(status)</code>：结束一个进程。该系统调用执行完成后，系统已经结束了当前进程，进程的资源已经被释放，进程的状态已经被设置为<code>ZOMBIE</code>状态，进程的退出状态为<code>status</code>。然后，操作系统会将进程的退出状态传递给父进程，父进程可以通过<code>wait()</code>系统调用来获取子进程的退出状态。</li>
<li><code>wait(&amp;status)</code>：等待一个进程结束。该系统调用执行完成后，系统已经等待了一个子进程结束，当子进程结束后，系统会将子进程的退出状态传递给父进程，父进程可以通过<code>status</code>参数来获取子进程的退出状态。</li>
<li><code>waitpid(pid, &amp;status, options)</code>：等待一个指定的进程结束。该系统调用执行完成后，系统已经等待了一个指定的子进程结束，当指定的子进程结束后，系统会将子进程的退出状态传递给父进程，父进程可以通过<code>status</code>参数来获取子进程的退出状态。</li>
</ul>
<p>如下是使用Linux原语实现的一个简单的并发程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    S2;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    S1;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    S3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-进程同步与互斥"><a href="#1-5-进程同步与互斥" class="headerlink" title="1.5 进程同步与互斥"></a>1.5 进程同步与互斥</h3><ul>
<li>进程同步：多个进程之间的协调，以便使进程按照一定的顺序执行。同步关系是指完成同一任务的伙伴进程间，因需要在某些位置上协调它们的工作而等待、传递信息所产生的制约关系，亦称<strong>直接制约关系</strong>。</li>
<li>进程互斥：多个进程之间的互斥关系，以便使进程之间不会相互干扰。互斥关系是指进程间因相互竞争使用<strong>独占型资源</strong>（互斥资源）所产生的制约关系,亦称<strong>间接制约关系</strong>。</li>
</ul>
<h3 id="1-6-同步-互斥与临界段问题"><a href="#1-6-同步-互斥与临界段问题" class="headerlink" title="1.6 同步&#x2F;互斥与临界段问题"></a>1.6 同步&#x2F;互斥与临界段问题</h3><h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><ul>
<li>例：如果一个进程P1执行S1，S3，进程P2执行S2，则P1在执行S3之前必须等待P2执行完S2。<ul>
<li><img src="/images/note2-2-1719152818483.png" alt="图 3"></li>
</ul>
</li>
</ul>
<h4 id="互斥问题（独占型资源）"><a href="#互斥问题（独占型资源）" class="headerlink" title="互斥问题（独占型资源）"></a>互斥问题（独占型资源）</h4><ul>
<li>例：P1、P2两进程使用同一打印机，如果不互斥使用会交叉输出。</li>
</ul>
<h4 id="互斥问题（共享数据）"><a href="#互斥问题（共享数据）" class="headerlink" title="互斥问题（共享数据）"></a>互斥问题（共享数据）</h4><ul>
<li>例：P1、P2两进程对共享变量X进行操作，如果不互斥使用会导致数据不一致。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">   <span class="title function_">A</span><span class="params">(amount)</span>&#123;</span><br><span class="line">    R1=balance;</span><br><span class="line">    R2=amount;</span><br><span class="line">    R1=R1+R2;</span><br><span class="line">    balance=R1;</span><br><span class="line">    &#125;;</span><br><span class="line">   B(amount) &#123;</span><br><span class="line">    R1=balance;</span><br><span class="line">    R2=amount;</span><br><span class="line">    R1=R1-R2;</span><br><span class="line">    balance=R1;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>在上面这段程序中，我们是要求两个进程A和B对共享变量<code>balance</code>进行操作的时候应该是互斥的，否则会导致数据不一致。</p>
<h4 id="有限缓冲区的生产者-消费者问题（生产者和消费者共享一个产品缓冲链）"><a href="#有限缓冲区的生产者-消费者问题（生产者和消费者共享一个产品缓冲链）" class="headerlink" title="有限缓冲区的生产者&#x2F;消费者问题（生产者和消费者共享一个产品缓冲链）"></a>有限缓冲区的生产者&#x2F;消费者问题（生产者和消费者共享一个产品缓冲链）</h4><p><img src="/images/note2-2-1719152998209.png" alt="图 4">  </p>
<ul>
<li>生产者进程：生产者进程是一个周期性进程，它的任务是生产产品并将产品放入缓冲区。</li>
<li>消费者进程：消费者进程是一个周期性进程，它的任务是从缓冲区中取出产品并消费产品。</li>
<li>缓冲区：缓冲区是一个有限的产品链，生产者和消费者共享这个产品链。</li>
</ul>
<p>数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; item;   <span class="comment">// 消息类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span> <span class="title">inst</span>;</span><span class="comment">//产品</span></span><br><span class="line">&#125; buffer;   <span class="comment">// 缓冲类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">P</span>, *<span class="title">C</span>, *<span class="title">First</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> <span class="title">nextp</span>, <span class="title">nextc</span>;</span></span><br><span class="line">First = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>对于如上的数据结构，我们可以定义如下的生产者和消费者的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">Producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            produce(nextp);<span class="comment">//生产产品</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            new(P); <span class="comment">// 申请一个新的缓冲区</span></span><br><span class="line">            P-&gt;inst = nextp;</span><br><span class="line">            P-&gt;next = First;</span><br><span class="line">            First = P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Consumer() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (First != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果为空，那么就循环等待</span></span><br><span class="line">                C = First;</span><br><span class="line">                first = first-&gt;next;</span><br><span class="line">                nextc = C-&gt;inst;</span><br><span class="line">                dispose(C);<span class="comment">//释放缓冲区</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                consume(nextc);<span class="comment">//消费产品</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>对于如下一个序列，会导致生产者加入的产品丢失：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T0: consumer C=First;</span><br><span class="line">T1: producer P.next=First; First=P;</span><br><span class="line">T2: consumer first=fist-&gt;next;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们可以看到，如果在T0时刻，消费者C取出了First，然后在T1时刻，生产者P将First指向了新的缓冲区，那么在T2时刻，消费者first指向了First的下一个缓冲区，那么First就丢失了。</p>
<h3 id="1-7-临界段问题"><a href="#1-7-临界段问题" class="headerlink" title="1.7 临界段问题"></a>1.7 临界段问题</h3><ul>
<li>临界段（Critical Section）：指的是一段程序片段，这段程序片段中的代码是对共享资源进行访问的代码，这段代码是一个临界资源，多个进程同时访问这段代码会导致数据不一致。这一段代码要求各进程必须互斥地访问，即同一时刻只能有一个进程访问这段代码。</li>
<li>临界资源（Critical Resource）：指的是一种共享资源，多个进程需要访问这个资源，但是这个资源只能被一个进程访问，否则会导致数据不一致。</li>
</ul>
<h2 id="2-进程同步与互斥实现方法"><a href="#2-进程同步与互斥实现方法" class="headerlink" title="2. 进程同步与互斥实现方法"></a>2. 进程同步与互斥实现方法</h2><blockquote>
<p>在本部分，了解解决互斥问题的软件算法;理解互斥问题的硬件实现方法；掌握信号量机制及使用它解决进程同步互斥问题的方法。 </p>
</blockquote>
<h3 id="2-1-并发进程进入临界区需要遵循的四个准则"><a href="#2-1-并发进程进入临界区需要遵循的四个准则" class="headerlink" title="2.1 并发进程进入临界区需要遵循的四个准则"></a>2.1 并发进程进入临界区需要遵循的四个准则</h3><ul>
<li><strong>互斥使用</strong>：在任一时刻，只允许一个进程进入临界区执行；</li>
<li><strong>让权等待</strong>：等待进入临界区的进程，应释放处理机后阻塞等待；</li>
<li><strong>有空让进</strong>：在临界区外运行的进程不可阻止其他进程进入临界区；</li>
<li><strong>有限等待</strong>：进程进入临界区的等待时间应有限，不应该使要进入临界区的进程无限等待。</li>
</ul>
<p><img src="/images/note2-2-1719154478754.png" alt="图 5">  </p>
<h3 id="2-2-解决进程之间互斥的方法"><a href="#2-2-解决进程之间互斥的方法" class="headerlink" title="2.2 解决进程之间互斥的方法"></a>2.2 解决进程之间互斥的方法</h3><h4 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h4><h5 id="实现互斥的软件算法"><a href="#实现互斥的软件算法" class="headerlink" title="实现互斥的软件算法"></a>实现互斥的软件算法</h5><ul>
<li>进入临界段之前要<strong>申请</strong>，获得批准方可进入；</li>
<li>退出临界段之后要<strong>声明</strong>，以便其他进程进入。</li>
</ul>
<p>算法应该满足以下几个条件：</p>
<ul>
<li><strong>准则1：</strong>不能虚设硬件指令或假设处理机数目。</li>
<li><strong>准则2：</strong>不能假设n个进程的相对速度。</li>
<li><strong>准则3：</strong>当一个进程未处于其临界段时，不应阻止其它进程进入临界段。</li>
<li><strong>准则4：</strong>当若干进程欲进入临界段时，应能在有限时间内选出一个进程进入其临界段。</li>
</ul>
<p>协调各进程入临界段的调度原则：</p>
<ul>
<li>当<strong>无进程</strong>处于临界段时，允许一个进程立即<strong>进入</strong>临界段。</li>
<li>当<strong>已有进程</strong>进入临界段时， 其它试图进入的进程必须<strong>等待</strong>。</li>
<li>当某进程<strong>退出临界段</strong>时，若有等待进入临界段的进程，则应选取一个进入临界段。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">repeat</span><br><span class="line">    &#123;</span><br><span class="line">    Entry Section</span><br><span class="line">    Critical Section</span><br><span class="line">    Exit Section</span><br><span class="line">    Remainder Section</span><br><span class="line">    &#125;</span><br><span class="line">until <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Dekker算法"><a href="#Dekker算法" class="headerlink" title="Dekker算法"></a>Dekker算法</h5><ul>
<li>Dekker算法首先有一个初步构想：定义全局变量turn，值0、1分别标志进程P0和P1可以进入CS：</li>
</ul>
<p><img src="/images/note2-2-1719154869681.png" alt="图 6">  </p>
<p>而以上过程可能会导致某个进程一直在等待，也叫<strong>忙等待（busy waiting）</strong>。</p>
<p>而以上过程也违背了准则4，即<strong>有限等待</strong>。</p>
<p>同时，即使临界区此时为空，由于turn的值为1，P0也无法进入临界区。这违反了准则3——<strong>有空让进</strong>。</p>
<p>因此，引出了第一个改进：使用全局共享数组flag，flag[0]和flag[1]分别标志进程P0和P1是否占用临界区，如果数组中的值全部为0&#x2F;false，那么临界区为空。</p>
<p>有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>但是，这个算法仍然存在问题，即<strong>忙等待</strong>。会发现，如果某个进程在临界区内失败且对应的flag为true，那么其他进程会一直在忙等待。</p>
<p>因此，引出了第二个改进：使用一个标志位，哪个进程需要使用临界区，谁就要举手声明。</p>
<p>有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 举手声明</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 举手声明</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>但是，上面的算法依然不能实现<strong>有空让进</strong>，即如果某个进程在临界区内失败或者两个进程同时举手声明，那么其他进程会一直在忙等待，而这两个进程也会一直在忙等待。</p>
<p>因此，引出了第三个改进：</p>
<ul>
<li>为两个进程Pi和Pj分别设置布尔变量，即boolean flag[2]，其初值为flag[i] &#x3D; flag[j]&#x3D; false ，若flag[i]&#x3D;&#x3D;true，则表示进程 Pi要求进入临界区 </li>
<li>为两个进程Pi和Pj设置共享整型变量turn指示应该由哪个进程进入临界区。turn&#x3D;&#x3D;i时，表示允许进程Pi进入临界区，反之允许进程Pj进入临界区</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 举手声明</span></span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (turn == <span class="number">1</span>) &#123; <span class="comment">// 如果是P1的轮次，那么就等待</span></span><br><span class="line">                    flag[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 举手放弃</span></span><br><span class="line">                    <span class="keyword">while</span> (turn == <span class="number">1</span>) &#123;</span><br><span class="line">                        do_nothing();</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 直到P1放弃轮次，才能再次举手</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            turn = <span class="number">1</span>;<span class="comment">// 轮到P1</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (turn == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (turn == <span class="number">0</span>) &#123;</span><br><span class="line">                        do_nothing();</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>上面的算法类似于令牌的传递，即只有拿到令牌的进程才能进入临界区。</p>
<h5 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h5><p>Peterson算法是Dekker算法的改进，Peterson算法的基本思想是：在进入临界区之前，进程必须先申请进入临界区，然后等待对方放弃进入临界区的权利。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            turn = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>在上面的Peterson算法中，<code>flag[0] = 1; turn = 1;</code>这一步是实现两个进程间互斥访问临界区的关键。</p>
<ul>
<li><p><code>flag[0] = 1;</code> 表示进程P0想要进入临界区。<code>flag</code>数组用于标记每个进程是否有意进入临界区，其中<code>flag[0]</code>对应进程P0，<code>flag[1]</code>对应进程P1。</p>
</li>
<li><p><code>turn = 1;</code> 表示当两个进程都想进入临界区时，优先权给进程P1。<code>turn</code>变量用于解决两个进程都想进入临界区时的冲突，通过轮流给予每个进程优先权。</p>
</li>
</ul>
<p>这两步操作共同实现了以下目的：</p>
<ol>
<li><p><strong>表达意图</strong>：通过设置<code>flag[0] = 1</code>，进程P0表明它想要进入临界区。这是告知系统及其他进程其意图的方式。</p>
</li>
<li><p><strong>决定优先权</strong>：通过设置<code>turn = 1</code>，算法在两个进程都想进入临界区时提供了一种决策机制。这里，将优先权给了另一个进程（P1），这是一种礼让机制，确保了公平性。</p>
</li>
</ol>
<p>接下来的<code>while (flag[1] &amp;&amp; turn == 1)</code>循环是检查条件，确保当另一个进程（P1）也想进入临界区且当前的优先权不在自己（P0）时，进程P0会等待。这样，只有当另一个进程不想进入临界区（<code>flag[1] == 0</code>）或者优先权转回自己（<code>turn != 1</code>）时，进程P0才会进入临界区。</p>
<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>主要是利用处理机提供的特殊指令来实现临界区加锁。</p>
<h5 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h5><p>例如存取balance：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">(amount)</span> &#123;</span><br><span class="line">        disable_interrupt();</span><br><span class="line">        R1 = balance;</span><br><span class="line">        R2 = amount;</span><br><span class="line">        R1 = R1 + R2;</span><br><span class="line">        balance = R1;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">    &#125;;</span><br><span class="line">    B(amount) &#123;</span><br><span class="line">        disable_interrupt();</span><br><span class="line">        R1 = balance;</span><br><span class="line">        R2 = amount;</span><br><span class="line">        R1 = R1 - R2;</span><br><span class="line">        balance = R1;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>上面的程序非常简单，但是限制了处理机交叉执行的能力，并且把禁止中断的<strong>权力交给用户进程</strong>是不明智的，同时若是<strong>多处理机系统</strong>，则禁止中断<strong>仅仅对执行本指令的那个CPU有效</strong>。其他CPU仍将继续运行，并可以访问临界资源。</p>
<h5 id="“Test-and-Set”指令"><a href="#“Test-and-Set”指令" class="headerlink" title="“Test_and_Set”指令"></a>“Test_and_Set”指令</h5><ul>
<li>“Test_and_Set”指令是一个原子操作，它可以在一个操作中读取一个存储器单元的值，并将该单元的值设置为一个新值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boolean <span class="title function_">Test_and_Set</span><span class="params">(boolean *lock)</span> &#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如下是一个使用”Test_and_Set”指令的互斥算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boolean lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (Test_and_Set(&amp;lock)) &#123;</span><br><span class="line">            do_nothing();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        lock = <span class="literal">false</span>;<span class="comment">//释放锁</span></span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="“Swap”指令"><a href="#“Swap”指令" class="headerlink" title="“Swap”指令"></a>“Swap”指令</h5><ul>
<li>“Swap”指令是一个原子操作，它可以在一个操作中交换两个存储器单元的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boolean <span class="title function_">Swap</span><span class="params">(boolean *a, boolean *b)</span> &#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面的函数也可以采用引用方式描述。</p>
<p>而如下是一个使用”Swap”指令的互斥算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boolean lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (key) &#123;</span><br><span class="line">            Swap(&amp;lock, &amp;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        lock = <span class="literal">false</span>;<span class="comment">//释放锁</span></span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的使用中，一开始<code>lock</code>为<code>false</code>，<code>key</code>为<code>true</code>，那么<code>Swap(&amp;lock, &amp;key);</code>会将<code>lock</code>设置为<code>true</code>，<code>key</code>设置为<code>false</code>，那么<code>while (key)</code>就会退出循环，进入临界区。而如果<code>lock</code>为<code>true</code>，那么<code>Swap(&amp;lock, &amp;key);</code>会将<code>lock</code>设置为<code>false</code>，<code>key</code>设置为<code>true</code>，那么<code>while (key)</code>就会继续循环，等待<code>lock</code>为<code>false</code>。</p>
<h3 id="2-3-信号量-Semaphore-和PV操作"><a href="#2-3-信号量-Semaphore-和PV操作" class="headerlink" title="2.3 信号量(Semaphore)和PV操作"></a>2.3 信号量(Semaphore)和PV操作</h3><ul>
<li><strong>信号量</strong>：1965年由荷兰计算机科学家Dijkstra提出的一种用于进程间通信和同步的机制。信号量是一个整型变量，可以对其进行两种操作：增加和减少。信号量的值大于等于0时，表示可用资源的数目；小于0时，表示等待使用资源的进程数目。也就是说，每个信号量与一个资源相关联，信号量的值就是资源的数目。同时，其值只能通过初始化、P操作和V操作来访问。</li>
<li>信号量的类型：<ul>
<li>公用信号量：用于进程间的互斥，<strong>初始值为1</strong>；</li>
<li>私用信号量：用于进程间的同步，<strong>初始值为0或n</strong>。</li>
</ul>
</li>
</ul>
<h4 id="信号量机制实现"><a href="#信号量机制实现" class="headerlink" title="信号量机制实现"></a>信号量机制实现</h4><ul>
<li><p>假设信号量S为一个整型变量，可以对其进行两种操作：增加和减少。</p>
</li>
<li><p><strong>P操作</strong>：如果S的值大于0，则将S减1。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        do_nothing();</span><br><span class="line">    &#125;</span><br><span class="line">    S=S<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>V操作</strong>：将S的值加1。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">V(S) &#123;</span><br><span class="line">    S=S+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在上面的程序中，P、V操作是两条原语，P、V操作对变量S的访问是互斥的。</p>
<h4 id="原语的概念与实现"><a href="#原语的概念与实现" class="headerlink" title="原语的概念与实现"></a>原语的概念与实现</h4><ul>
<li><strong>原语</strong>：指完成某种功能且不被分割或不被逻辑上中断执行的操作序列。原语可通过<strong>硬件</strong>实现不可中断性；或通过<strong>实现临界段的元方法</strong>达到不被逻辑上中断。</li>
<li>实现临界段的元方法：屏蔽中断&#x2F;加硬锁。</li>
</ul>
<h5 id="屏蔽中断实现的原语"><a href="#屏蔽中断实现的原语" class="headerlink" title="屏蔽中断实现的原语"></a>屏蔽中断实现的原语</h5><ul>
<li><strong>屏蔽中断</strong>：在进入临界区之前，关闭中断；在退出临界区之后，开启中断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(S) &#123;</span><br><span class="line">    disable_interrupt();</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">        disable_interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    S=S<span class="number">-1</span>;</span><br><span class="line">    enable_interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是一个实现信号量P操作（等待操作）的例子，其中涉及到中断的禁用和启用。在<code>while (S &lt;= 0)</code>循环中，重新打开中断（<code>enable_interrupt();</code>）再关闭中断（<code>disable_interrupt();</code>）的原因主要是为了避免死锁和提高系统的响应性。</p>
<ol>
<li><p><strong>避免死锁</strong>：当<code>S &lt;= 0</code>时，表示没有可用资源，当前进程需要等待。如果在等待期间一直禁用中断，那么系统将无法响应任何中断，包括那些可能释放资源（使<code>S</code>变为正值）的中断。这样会导致死锁，因为当前进程在等待资源变为可用状态，而系统又无法处理那些可能释放资源的操作。</p>
</li>
<li><p><strong>提高系统响应性</strong>：通过在等待循环中临时重新启用中断，系统可以处理其他中断请求，这样可以保证系统对其他重要事件的响应不会被当前等待操作阻塞。一旦处理完中断，再次禁用中断并检查条件，这样既保证了对资源访问的互斥性，又提高了系统的整体响应性和效率。</p>
</li>
</ol>
<p>简而言之，这种在等待循环中临时启用中断的做法是一种权衡，它旨在避免在等待资源时造成系统响应的完全阻塞，同时又能在资源变为可用时及时恢复执行。这种方法在实际操作系统和并发编程中是一种常见的实践，用于处理资源等待和中断响应之间的平衡。</p>
<h5 id="加硬锁实现的原语"><a href="#加硬锁实现的原语" class="headerlink" title="加硬锁实现的原语"></a>加硬锁实现的原语</h5><p>使用硬件锁实现原语的方法通常依赖于硬件提供的特定指令或机制，这些指令或机制能够原子地测试并设置锁变量，从而实现互斥。一个常见的硬件锁实现是使用“测试并设置”（Test-and-Set）指令或“比较并交换”（Compare-and-Swap，CAS）指令。</p>
<ol>
<li><p><strong>定义锁变量</strong>：首先，定义一个锁变量，通常是一个整型或布尔型变量，用于表示锁的状态（加锁或未加锁）。</p>
</li>
<li><p><strong>加锁（Lock）操作</strong>：</p>
<ul>
<li>使用CAS指令原子地检查锁变量的值。</li>
<li>如果锁变量为0（未加锁状态），则将其设置为1（加锁状态），并进入临界区。</li>
<li>如果锁变量已经为1（加锁状态），则循环等待，直到锁变量变为0。</li>
</ul>
</li>
<li><p><strong>解锁（Unlock）操作</strong>：</p>
<ul>
<li>完成临界区的操作后，将锁变量设置回0，表示锁已释放。</li>
</ul>
</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设lock是一个共享变量，初始化为0（未加锁状态）</span></span><br><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 循环等待，直到成功将lock从0改为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    lock = <span class="number">0</span>; <span class="comment">// 直接将lock设置为0，释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是不需要禁用中断，因此可以在多核处理器环境中使用，而且避免了因禁用中断导致的系统响应性问题。然而，它可能导致忙等（busy waiting），特别是在锁竞争激烈的情况下，这会浪费CPU资源。为了缓解这个问题，可以引入退避（backoff）策略或使用更高级的同步机制，如队列锁。</p>
<h4 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h4><ul>
<li><p><strong>互斥</strong>：信号量S的初值为1，表示资源可用，进程P执行P(S)操作，进入临界区后执行V(S)操作，释放资源。一般而言这个信号量也被命名为 <strong>mutex</strong> 。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex = <span class="number">1</span>;</span><br><span class="line">Process <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步</strong>：信号量S的初值为0，表示资源不可用，进程P执行P(S)操作，等待资源可用，进程Q执行V(S)操作，释放资源。这个信号量也常被命名为 <strong>synch</strong> 。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">synch = <span class="number">0</span>;</span><br><span class="line">Parbegin</span><br><span class="line">    Process <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        V(synch);</span><br><span class="line">    &#125;</span><br><span class="line">    Process <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">        P(synch);</span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  那么，在上面的情况下，P0进程中的临界区会在P1进程中的余下区之前执行。</p>
</li>
</ul>
<h5 id="信号量机制的应用举例"><a href="#信号量机制的应用举例" class="headerlink" title="信号量机制的应用举例"></a>信号量机制的应用举例</h5><p><img src="/images/note2-2-1719211390686.png" alt="图 7">  </p>
<p>在如上的图中，语句S1在S2和S3之前执行，而S2和S3是并发执行的，S4在S2后执行，S5在S4后执行，S6在S3和S4之后执行，S7在S5和S6之后执行。我们可以设置如下的信号量机制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s1 = <span class="number">1</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        P(s1);</span><br><span class="line">        S1;</span><br><span class="line">        V(s2);</span><br><span class="line">        S2;</span><br><span class="line">        S4;</span><br><span class="line">        V(s3);</span><br><span class="line">        S5;</span><br><span class="line">        V(s4);</span><br><span class="line">    &#125;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        P(s2);</span><br><span class="line">        S3;</span><br><span class="line">        P(s3);</span><br><span class="line">        s6;</span><br><span class="line">        P(s4);</span><br><span class="line">        S7;</span><br><span class="line">    &#125;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<h5 id="消除忙等待的信号量机制"><a href="#消除忙等待的信号量机制" class="headerlink" title="消除忙等待的信号量机制"></a>消除忙等待的信号量机制</h5><ul>
<li><strong>忙等待</strong>：在等待资源时，进程不断循环检查资源是否可用，这种方式会浪费CPU资源。我们需要在使用信号量机制的同时，与进程调度机制结合，避免忙等待。</li>
<li><strong>原则</strong>：在P操作循环等待的地方加入<strong>放弃处理机&#x2F;挂入等待队列</strong>动作，在V操作时，从等待队列中摘取进程变为就绪态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改进后的信号量声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 信号量值，代表资源可用数目</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 等待队列，存放等待进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore *s)</span> &#123;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        保存现场;</span><br><span class="line">        将本进程挂入s-&gt;<span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore *s)</span> &#123;</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        从s-&gt;<span class="built_in">list</span>中取出一个进程;</span><br><span class="line">        将该进程放入就绪队列;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用两个线程实现共享数组的data-1000-累加"><a href="#用两个线程实现共享数组的data-1000-累加" class="headerlink" title="用两个线程实现共享数组的data[1000]累加"></a>用两个线程实现共享数组的data[1000]累加</h5><ul>
<li>采用互斥量实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 也可以仅是一个整型变量</span></span><br><span class="line"></span><br><span class="line">Thread1() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 首先获取互斥量，保证只有一个线程能够访问data数组</span></span><br><span class="line">        P(mutex);<span class="comment">//实际这里应该是&amp;mutex</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            sum += data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果i&gt;=1000，说明data数组已经遍历完，释放互斥量并退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread1 sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread2() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 首先获取互斥量，保证只有一个线程能够访问data数组</span></span><br><span class="line">        P(mutex);<span class="comment">//实际这里应该是&amp;mutex</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            sum += data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果i&gt;=1000，说明data数组已经遍历完，释放互斥量并退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread2 sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用同步机制计算data[1000]的和：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;<span class="comment">//两个线程的累加和</span></span><br><span class="line">semaphore synch = <span class="number">0</span>;<span class="comment">//信号量，也可以是一个整型变量</span></span><br><span class="line"></span><br><span class="line">Thread1() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">        sum1 += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    P(synch);</span><br><span class="line">    sum1 += sum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread1 sum = %d\n&quot;</span>, sum1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread2() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">500</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum2 += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    V(synch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-进程同步与互斥举例"><a href="#3-进程同步与互斥举例" class="headerlink" title="3. 进程同步与互斥举例"></a>3. 进程同步与互斥举例</h2><blockquote>
<p>在本部分，通过实例了解进程同步与互斥的应用。</p>
</blockquote>
<h3 id="3-1-生产者-消费者问题（有限缓冲区）"><a href="#3-1-生产者-消费者问题（有限缓冲区）" class="headerlink" title="3.1 生产者&#x2F;消费者问题（有限缓冲区）"></a>3.1 生产者&#x2F;消费者问题（有限缓冲区）</h3><ul>
<li>问题描述：设有n个缓冲区，一组生产者进程往缓冲区写数据，一组消费者进程从缓冲区取数据，写、取以一个缓冲区为单位。</li>
<li><strong>生产者</strong>：生产者进程是一个周期性进程，它的任务是生产产品并将产品放入缓冲区。</li>
<li><strong>消费者</strong>：消费者进程是一个周期性进程，它的任务是从缓冲区中取出产品并消费产品。</li>
<li><strong>说明</strong>：<ul>
<li>将缓冲区看作共享数据，对缓冲区的访问应该是互斥的。</li>
<li>如果缓冲区全满，生产者进程应该等待，直到有空缓冲区。</li>
<li>如果缓冲区为空，消费者进程应该等待，直到有产品可取。</li>
</ul>
</li>
</ul>
<p><img src="/images/note2-2-1719212407468.png" alt="图 10">  </p>
<ul>
<li><strong>数据结构</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; item;   <span class="comment">// 消息类型</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex: 互斥量，用于对缓冲区的访问进行互斥</span></span><br><span class="line"><span class="comment"> * empty: 信号量，表示空缓冲区的数目</span></span><br><span class="line"><span class="comment"> * full: 信号量，表示满缓冲区的数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 下一个生产者和消费者的产品</span></span><br><span class="line">item nextp, nextc;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Producer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        produce(nextp);<span class="comment">//生产产品</span></span><br><span class="line">        P(empty);<span class="comment">//等待空缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        get_empty_buffer();</span><br><span class="line">        buffer-&gt;inst = nextp;<span class="comment">//将产品放入缓冲区</span></span><br><span class="line">        add_to_full_buffer_queue(buffer);</span><br><span class="line">        V(mutex);<span class="comment">//退出临界区</span></span><br><span class="line">        V(full);<span class="comment">//增加满缓冲区数目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的P(empty)操作中，如果empty的值小于等于0，那么生产者就会等待，直到有空缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (empty &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    do_nothing();</span><br><span class="line">&#125;</span><br><span class="line">empty--;<span class="comment">//empty = empty - 1;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(full);<span class="comment">//等待满缓冲区，消耗一个缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        <span class="comment">// 从缓冲区取出产品</span></span><br><span class="line">        buffer = get_full_buffer();</span><br><span class="line">        nextc = buffer-&gt;inst;</span><br><span class="line">        dispose(buffer);<span class="comment">//释放缓冲区</span></span><br><span class="line">        V(mutex);<span class="comment">//退出临界区</span></span><br><span class="line">        V(empty);<span class="comment">//增加空缓冲区数目</span></span><br><span class="line">        consume(nextc);<span class="comment">//消费产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上的生成者和消费者代码，其中的<code>full</code>和<code>empty</code>的P和V操作是不能省略的，同时这些操作的位置也是有严格要求的，不能随意替换位置。</p>
<ol>
<li><p><strong>为什么不能省略</strong>：</p>
<ul>
<li><code>empty</code>信号量用于表示空缓冲区的数量。生产者在生产新产品之前需要确保有空缓冲区可用，这是通过P(empty)操作来保证的。如果省略这一步，生产者可能会在没有空缓冲区的情况下尝试生产产品，导致数据覆盖或其他错误。</li>
<li><code>full</code>信号量用于表示满缓冲区的数量。消费者在消费产品之前需要确保有产品可消费，这是通过P(full)操作来保证的。如果省略这一步，消费者可能会在缓冲区为空的情况下尝试消费产品，导致错误。</li>
</ul>
</li>
<li><p><strong>为什么操作的位置不能替换</strong>：</p>
<ul>
<li>**P(empty)<strong>操作必须在</strong>P(mutex)**之前。这是因为生产者需要先确保有空缓冲区可用，然后再进入临界区放置产品。如果先进入临界区，可能会导致所有生产者都在临界区内等待空缓冲区，而没有生产者能够释放临界区，从而造成死锁。</li>
<li>同样，**P(full)<strong>操作必须在</strong>P(mutex)**之前。消费者需要先确保有产品可消费，然后再进入临界区取出产品。如果先进入临界区，可能会导致所有消费者都在临界区内等待产品，而没有消费者能够释放临界区，从而造成死锁。</li>
<li>**V(mutex)<strong>操作须在</strong>V(full)或V(empty)**之后。这是因为生产者或消费者完成操作后，需要先退出临界区，释放对缓冲区的互斥访问权，然后再通过V操作增加满或空缓冲区的数量，这样可以让其他等待的生产者或消费者得到通知并开始执行。这样可以减少其他进程等待的时间，提高系统的效率。</li>
</ul>
</li>
</ol>
<p>总之，<code>full</code>和<code>empty</code>的P和V操作是实现生产者和消费者问题同步机制的关键部分，不能省略；同时，这些操作的顺序设计是为了避免死锁和确保系统的正确性，因此也不能随意更改位置。</p>
<h3 id="3-2-读者-写者问题"><a href="#3-2-读者-写者问题" class="headerlink" title="3.2 读者&#x2F;写者问题"></a>3.2 读者&#x2F;写者问题</h3><ul>
<li>问题描述：存在共享数据A，那些对它进行只读访问进程叫Reader；对它进行了写操作的进程叫Writer。</li>
<li>两类读者写者问题：<ul>
<li><strong>第一类——并发极大化</strong>：读者优先，Reader和Writer争夺访问共享数据A时，如果已经有Reader访问A，后续Reader与后续Writer比有较高优先权。</li>
<li><strong>第二类-数据时效优先</strong>：写者优先，Reader和Writer争夺访问共享数据A时，Writer有较高优先权。</li>
</ul>
</li>
</ul>
<h4 id="第一类读者写者问题"><a href="#第一类读者写者问题" class="headerlink" title="第一类读者写者问题"></a>第一类读者写者问题</h4><ol>
<li>如果当前无进程访问A，则Reader&#x2F; Writer欲访问即可访问。</li>
<li><strong>如果已存在一个Reader正在访问数据，其它欲访问Reader可马上访问（这体现Reader有较高优先权）；而欲访问的Writer必须等待。</strong></li>
<li>若某个Writer正访问数据，则欲访问的Reader&#x2F; Writer都必须等待。</li>
<li><strong>当最后一个结束访问数据的Reader发现有Writer正在等待时，则将其中一个唤醒。</strong></li>
<li>当某个Writer结束访问时，若只有Writer在等待，则唤醒某个Writer，若既有Writer也有Reader；则按FIFO或其它原则唤醒一个Writer或所有Reader。</li>
</ol>
<p>那么对于以上问题描述，我们可以设定一个写的互斥量<code>wrt</code>，一个读的互斥量<code>mutex</code>，一个读者计数器<code>readcount</code>。需要注意的点是，在这里，我们使用了一个mutex来保护读者计数器，防止因为多个读者同时访问而导致计数器的错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>, wrt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex);<span class="comment">// 保护readcount</span></span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>) &#123;</span><br><span class="line">            P(wrt);<span class="comment">// 第一个读者等待写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        read();</span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wrt);<span class="comment">// 最后一个读者唤醒写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(wrt);<span class="comment">// 写者等待</span></span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        write();</span><br><span class="line">        V(wrt);<span class="comment">// 写者释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二类读者写者问题"><a href="#第二类读者写者问题" class="headerlink" title="第二类读者写者问题"></a>第二类读者写者问题</h4><p>第二类读者写者问题中，要求保证写者优先，即写者有较高优先权。在这种情况下，如果有写者在等待访问共享数据A，那么后续的读者和写者都必须等待，直到当前的写者完成访问。或者在当前访问结束后，优先唤醒写者。</p>
<p>在读者优先的基础上，增加信号量 r ，初值是 1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。同时，我们增加一个记数器，即整型变量 writecount ，记录写者数，初值是 0。为多个写者共享的变量，是临界资源。用互斥信号量 mutex2 控制。</p>
<p>除此之外，我们也需要一个互斥量 mutex3，用于确保在 r 这个信号量上，只有一个读进程在排队等待。</p>
<ul>
<li><strong>数据结构</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>, wrt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex2 = <span class="number">1</span>, mutex3 = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> writecount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先获取mutex3，保证只有一个读进程在r信号量上排队等待</span></span><br><span class="line">        P(mutex3);</span><br><span class="line">        <span class="comment">// 然后获取r信号量，如果有写者在等待，那么读者需要等待</span></span><br><span class="line">        P(r);</span><br><span class="line">        <span class="comment">// 获取mutex，保护readcount</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读者在读进程中，写者不能进入</span></span><br><span class="line">            P(wrt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次释放mutex、r信号量和mutex3</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(r);</span><br><span class="line">        V(mutex3);</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        read();</span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读完毕，唤醒写者</span></span><br><span class="line">            V(wrt);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先获取mutex2，保证只有一个写进程在排队等待</span></span><br><span class="line">        P(mutex2);</span><br><span class="line">        writecount++;</span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求r信号量，禁止所有的读进程</span></span><br><span class="line">            P(r);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        <span class="comment">// 写者请求写操作</span></span><br><span class="line">        P(wrt);</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        write();</span><br><span class="line">        V(wrt);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        writecount--;</span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 最后一个写者唤醒r信号量上的唯一读者</span></span><br><span class="line">            V(r);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的读者-写者问题实现中，通过使用信号量和计数器的方式确保了写者优先。这是通过以下几个关键步骤实现的：</p>
<ol>
<li><p><strong>写者计数器（<code>writecount</code>）</strong>：用于跟踪当前等待写操作的写者数量。当第一个写者到来时，它会通过<code>P(r)</code>操作阻止新的读者开始读取，从而确保写者可以优先进行写操作。而后续，只要还有写者准备写，那么这个r信号量就会一直被占用，从而阻止新的读者开始读取。</p>
</li>
<li><p><strong>读者信号量（<code>r</code>）</strong>：当有写者等待时，通过<code>P(r)</code>操作阻止新的读者开始，这样只要有写者在等待，新的读者就不能开始读取。这确保了一旦有写者准备写入，读者将不会开始新的读操作，从而给予写者优先权。</p>
</li>
<li><p><strong>互斥信号量（<code>mutex2</code>，<code>mutex3</code>，<code>mutex</code>）</strong>：用于保护写者计数器和读者计数器的修改，确保在任何时刻只有一个写者或读者可以修改计数器。mutex3稍微特殊，用于确保在r信号量上只有一个读进程在排队等待。</p>
</li>
</ol>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p>假设系统中有多个读者和写者同时请求访问共享资源。</p>
<ul>
<li><strong>情景一</strong>：当没有写者时，多个读者可以同时访问资源，因为读操作不会相互影响。</li>
<li><strong>情景二</strong>：一旦有一个写者请求写操作，它会增加<code>writecount</code>并通过<code>P(r)</code>操作阻止新的读者开始。这时，即使读者请求访问，也会因为<code>r</code>信号量被占用而等待。</li>
<li><strong>情景三</strong>：当前的读者完成读操作后，不会有新的读者开始，因为<code>r</code>信号量已经被第一个等待的写者占用。这时，写者完成<code>P(mutex2)</code>操作后，会执行<code>P(wrt)</code>进行写操作。在写操作完成之前，所有其他操作都会等待。</li>
<li><strong>情景四</strong>：写操作完成后，如果没有其他写者等待（<code>writecount</code>为0），则通过<code>V(r)</code>操作允许读者开始读操作。如果还有其他写者，那么下一个写者会继续写操作，直到没有写者等待。</li>
</ul>
<p>通过这种方式，一旦有写者准备写入，它会通过阻止新的读者开始并等待当前读者完成来确保写操作可以优先进行，从而实现了写者优先的策略。</p>
<p><strong>上面的 <code>mutex3</code> 主要作用是什么？</strong></p>
<p>我们可以发现，<code>r</code> 是读者和写者都需要获取的信号量，而如果我们仅使用一个 <code>r</code> 来控制写者的优先性，那么会导致在多个读者与一个写者的情况下，写者可能会被多个读者阻塞。因此，我们需要一个额外的互斥量 <code>mutex3</code> 来保证在 <code>r</code> 上只有一个读进程在排队等待，这样可以确保写者至少在一个读者写的时候才会被阻塞，而不是在一个读者写完之后还需要继续等待其他比它到的早的读者。</p>
<h3 id="3-3-哲学家就餐问题"><a href="#3-3-哲学家就餐问题" class="headerlink" title="3.3 哲学家就餐问题"></a>3.3 哲学家就餐问题</h3><ul>
<li>问题描述：五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。</li>
</ul>
<p><img src="/images/note2-2-1719217315316.png" alt="图 11">  </p>
<h4 id="初步设想"><a href="#初步设想" class="headerlink" title="初步设想"></a>初步设想</h4><ul>
<li>我们可以为每个筷子设置一个信号量，表示筷子是否被占用。当一个哲学家需要用筷子时，他会先检查左右两只筷子是否都可用，如果可用，就分别获取左右筷子，然后开始吃饭。吃完后，他会释放左右两只筷子，然后继续思考。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个构想是存在问题的，因为在这种情况下，可能会出现死锁。比如，如果每个哲学家都先拿左边的筷子，再拿右边的筷子，那么他们可能会同时拿到左边的筷子，然后都在等待右边的筷子，从而导致死锁。</p>
<p>这个常用来演示多线程同步（Synchrnization），用来解释死锁和资源耗尽的问题。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>设置一个取筷子的信号量，每个时刻只有一个哲学家可以取筷子。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种解决方案是，破坏死锁的循环等待，让一次只能有4名哲学家坐下，这样就不会形成循环等待的条件，也就构不成死锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore seat = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(seat);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        V(seat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-吸烟者问题（补充）"><a href="#3-4-吸烟者问题（补充）" class="headerlink" title="3.4 吸烟者问题（补充）"></a>3.4 吸烟者问题（补充）</h3><ul>
<li>问题描述：有三个吸烟者和一个供应者，吸烟者需要烟草、纸和火柴才能吸烟，供应者有这三种物品。吸烟者循环做着思考和吸烟的动作，供应者循环做着提供三种物品的动作。三个吸烟者分别拥有烟草、纸和火柴，他们需要等待供应者提供其他两种物品。供应者会无限制地提供这三种物品，每次会将其中两种物品放在桌子上，然后唤醒一个拥有对应剩下一种物品的吸烟者来卷起香烟吸烟，该吸烟者吸完后会给供应者发信号，供应者继续提供物品。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore tobacco = <span class="number">0</span>, paper = <span class="number">0</span>, match = <span class="number">0</span>;</span><br><span class="line">semaphore finished = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 供应者</span></span><br><span class="line">Supplier() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 提供纸和火柴</span></span><br><span class="line">        supply_paper_and_match();</span><br><span class="line">        <span class="comment">// 唤醒有烟草的吸烟者</span></span><br><span class="line">        V(tobacco);</span><br><span class="line">        <span class="comment">// 如果烟草已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">        <span class="comment">// 提供烟草和火柴</span></span><br><span class="line">        supply_tobacco_and_match();</span><br><span class="line">        <span class="comment">// 唤醒有纸的吸烟者</span></span><br><span class="line">        V(paper);</span><br><span class="line">        <span class="comment">// 如果纸已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">        <span class="comment">// 提供烟草和纸</span></span><br><span class="line">        supply_tobacco_and_paper();</span><br><span class="line">        <span class="comment">// 唤醒有火柴的吸烟者</span></span><br><span class="line">        V(match);</span><br><span class="line">        <span class="comment">// 如果火柴已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟者</span></span><br><span class="line">Smoker() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待供应者提供纸和火柴</span></span><br><span class="line">        P(tobacco);</span><br><span class="line">        <span class="comment">// 吸烟</span></span><br><span class="line">        smoke();</span><br><span class="line">        <span class="comment">// 通知供应者</span></span><br><span class="line">        V(finished);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他两个吸烟者类似</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个生产者-消费者问题的变种，我们会发现我们用同步的方式来实现了互斥的访问，也确保了供应者和吸烟者之间的同步。</p>
<p>但是，如果在这一期间存在别的进程，会来干扰我们的桌子上的物品，而它与现有进程不存在同步关系，那么我们显然需要更多的信号量来保证这一点（例如添加一个互斥量来保证每次只有一个人在桌子上操作）。</p>
<h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><blockquote>
<p>在本部分，我们将介绍管程的概念和实现。</p>
</blockquote>
<h3 id="4-1-管程的概念"><a href="#4-1-管程的概念" class="headerlink" title="4.1 管程的概念"></a>4.1 管程的概念</h3><h4 id="为什么提出管程的概念"><a href="#为什么提出管程的概念" class="headerlink" title="为什么提出管程的概念"></a>为什么提出管程的概念</h4><p>采用P-V同步机制来编写并发程序，对于共享变量及信号量变量的操作将被分散于各个进程中，主要缺点：</p>
<ul>
<li>（１）<strong>易读性差</strong>，因为要了解对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序；</li>
<li>（２）<strong>不利于修改和维护</strong>，因为程序的局部性很差，所以任一组变量或一段代码的修改都可能影响全局；</li>
<li>（３）<strong>正确性难以保证</strong>，因为操作系统或并发程序通常很大，要保证复杂系统没有逻辑错误非常困难。</li>
</ul>
<p>于是，提出用共享数据结构来表示并发程序中的共享数据和对共享数据的操作，这种数据结构称为管程。我们<strong>把分散的临界段集中于管程</strong>，管程中的临界程序一次只能被一个进程执行，这样就避免了多个进程同时访问共享数据的问题。思想与Java中的synchronized类似。</p>
<h4 id="管程的定义与构成"><a href="#管程的定义与构成" class="headerlink" title="管程的定义与构成"></a>管程的定义与构成</h4><ul>
<li><strong>管程</strong>：管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并且提供了一个方便的阻塞和唤醒进程的机制。它是一种用于并发编程的抽象数据类型，用于管理共享资源和协调多个进程之间的同步和通信。</li>
<li><strong>构成</strong>：共享数据结构；对共享结构操作的一组函数；对数据结构的初始化程序。</li>
<li><strong>特点</strong>：管程的局部变量只能由该管程的过程存取；系统保证进程只能互斥地调用管程中的过程。</li>
</ul>
<h3 id="4-2-管程的实现"><a href="#4-2-管程的实现" class="headerlink" title="4.2 管程的实现"></a>4.2 管程的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Monitor monitor_name &#123;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    shared_data_type shared_data;</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    condition_variable_type condition_variable;</span><br><span class="line">    <span class="comment">// 本管程内定义的过程名</span></span><br><span class="line">    define some_procedures;</span><br><span class="line">    <span class="comment">// 引用的外部模块的说明</span></span><br><span class="line">    use external_modules;</span><br><span class="line">    <span class="comment">// 过程1</span></span><br><span class="line">    procedure1() &#123;</span><br><span class="line">        <span class="comment">// 过程1的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过程2</span></span><br><span class="line">    procedure2() &#123;</span><br><span class="line">        <span class="comment">// 过程2的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为本管程内共享变量赋初值</span></span><br><span class="line">    initialization() &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如有一个管程定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Monitor  mutexshow &#123; </span><br><span class="line">   boolean busy=<span class="literal">false</span>; <span class="comment">//临界资源是否可用标志</span></span><br><span class="line">   condition nonbusy; <span class="comment">//等待队列的条件变量</span></span><br><span class="line">   define request, release; <span class="comment">//管程中的过程说明</span></span><br><span class="line">   use wait, signal;  <span class="comment">//引用外部模块</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>调用wait()的进程会阻塞在条件变量nonbusy的等待队列上。调用signal()会启动一个阻塞进程，<strong>若无阻塞进程则signal()不起作用</strong>，这也意味着signal()其实与V操作有所不同，它并一定会使信号量增加。</p>
<h4 id="申请管程临界资源"><a href="#申请管程临界资源" class="headerlink" title="申请管程临界资源"></a>申请管程临界资源</h4><ul>
<li><strong>申请管程临界资源</strong>：进程在进入管程时，需要申请管程的临界资源，以确保只有一个进程可以访问共享数据。这通常通过调用管程中的过程来实现，这些过程会对共享数据进行操作，并在操作完成后释放资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">procedure <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (busy) &#123;</span><br><span class="line">        <span class="comment">// 资源忙则在nonbusy等待队列上等待，并立即退出该管程。</span></span><br><span class="line">        wait(nonbusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请成功，置资源已经占用标志busy为真。</span></span><br><span class="line">    busy = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放管程临界资源"><a href="#释放管程临界资源" class="headerlink" title="释放管程临界资源"></a>释放管程临界资源</h4><ul>
<li><strong>释放管程临界资源</strong>：进程在退出管程时，需要释放管程的临界资源，以便其他进程可以访问共享数据。这通常通过调用管程中的过程来实现，这些过程会对共享数据进行操作，并在操作完成后释放资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">procedure <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置资源未占用</span></span><br><span class="line">    busy = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个进程</span></span><br><span class="line">    signal(nonbusy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过上述设置资源未占用的步骤实际上会更为复杂，需要考虑到当前进程是否有设置资源的权限，以及如何唤醒等待队列上的进程等问题。</p>
<h3 id="4-3-管程的应用"><a href="#4-3-管程的应用" class="headerlink" title="4.3 管程的应用"></a>4.3 管程的应用</h3><h4 id="生产者-消费者问题的管程实现"><a href="#生产者-消费者问题的管程实现" class="headerlink" title="生产者&#x2F;消费者问题的管程实现"></a>生产者&#x2F;消费者问题的管程实现</h4><ul>
<li><strong>管程定义</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Monitor  prod_conshow &#123; </span><br><span class="line">    <span class="type">char</span> buffer[n]; <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//缓冲区中产品数目</span></span><br><span class="line">    <span class="type">int</span> nextempty=<span class="number">0</span>, nextfull=<span class="number">0</span>; <span class="comment">//下一个空缓冲区和满缓冲区</span></span><br><span class="line">    condition notfull, notempty; <span class="comment">//等待队列的条件变量</span></span><br><span class="line">    define produce, consume; <span class="comment">//管程中的过程说明</span></span><br><span class="line">    use <span class="title function_">wait</span><span class="params">()</span>, <span class="title function_">signal</span><span class="params">()</span>;  <span class="comment">//引用外部模块</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">procedure <span class="title function_">produce</span><span class="params">(<span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        <span class="comment">// 缓冲区已满，等待非满条件</span></span><br><span class="line">        wait(notfull);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[nextempty] = item;</span><br><span class="line">    count=count+<span class="number">1</span>;</span><br><span class="line">    nextempty = (nextempty + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个消费者</span></span><br><span class="line">    signal(notempty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">procedure <span class="title function_">consume</span><span class="params">(<span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓冲区为空，等待非空条件</span></span><br><span class="line">        wait(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">    item = buffer[nextfull];</span><br><span class="line">    count = count - <span class="number">1</span>;</span><br><span class="line">    nextfull = (nextfull + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个生产者</span></span><br><span class="line">    signal(notfull);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>而在实际的生产者和消费者代码中，我们可以通过调用管程中的过程来实现生产者和消费者的操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Producer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> item = produce_item();</span><br><span class="line">        prod_conshow.produce(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> item;</span><br><span class="line">        prod_conshow.consume(item);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读者-写者问题的管程实现"><a href="#读者-写者问题的管程实现" class="headerlink" title="读者&#x2F;写者问题的管程实现"></a>读者&#x2F;写者问题的管程实现</h4><p>TODO</p>
<h3 id="4-4-管程的特征和与进程的区别"><a href="#4-4-管程的特征和与进程的区别" class="headerlink" title="4.4 管程的特征和与进程的区别"></a>4.4 管程的特征和与进程的区别</h3><h4 id="管程的特征"><a href="#管程的特征" class="headerlink" title="管程的特征"></a>管程的特征</h4><ul>
<li>模块化：一个管程是一个基本程序单位，可以单独编译；</li>
<li>抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码，是对数据和操作的封装。</li>
<li>信息掩蔽：管程如何实现其功能相对于外部程序是半透明的。</li>
</ul>
<h4 id="管程的优点"><a href="#管程的优点" class="headerlink" title="管程的优点"></a>管程的优点</h4><ul>
<li>安全性：共享变量外部不可见，只能由管程中的操作存取</li>
<li>互斥性：管程确保任何一个时刻只能有一个进程进入；</li>
<li>等待机制：设置有等待队列及相应的操作，对资源进行管理。</li>
</ul>
<h4 id="管程与进程的区别"><a href="#管程与进程的区别" class="headerlink" title="管程与进程的区别"></a>管程与进程的区别</h4><ul>
<li>设置目的不同：管程是对共享资源进行管理，进程是资源分配和执行的基本单位。</li>
<li>数据结构不同：管程定义公用数据结构，进程定义私有数据结构。</li>
<li>存在方式不同：进程有生命周期，管程是操作系统固有的部分，没有生命周期。</li>
<li>执行方式不同：管程被进程调用，没有并发性，进程具有并发执行性。</li>
</ul>
<h2 id="5-some-questions"><a href="#5-some-questions" class="headerlink" title="5. some questions"></a>5. some questions</h2><h3 id="5-1-概念相关"><a href="#5-1-概念相关" class="headerlink" title="5.1 概念相关"></a>5.1 概念相关</h3><ol>
<li>进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的临界区，就应允许其运行，即分配CPU。该进程所锁定的临界区是不允许其他进程访问的，其他进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交给它。</li>
<li>共享程序段可能同时被多个进程使用，所以必须可重入编码，否则无法实现共享的功能。而PCB是进程的控制块，是进程的唯一标识，不可能被多个进程共享，所以不需要可重入编码。</li>
<li>如果两个线程分别对两个不同的互斥锁<strong>先后加锁</strong>，但<strong>顺序相反</strong>，那么可能导致死锁，这是典型的循环等待现象。例如，线程1先对互斥锁A加锁，然后尝试对互斥锁B加锁：同时，线程2先对B加锁，然后尝试对A加锁，两个线程都在等待对方释放资源，从而无法继续推进。而对于一个进程给一个互斥锁加锁但没有解锁，这是不会导致死锁的，因为并没出现循环等待的情况。</li>
<li>管程的<strong>signal</strong>操作与信号量机制中的<strong>V操作</strong>不同，信号量机制中的V操作一定会改变信号量的值S&#x3D;S+1。而管程中的signal操作是针对某个条件变量的，若不存在因该条件而阻塞的进程，则signal不会产生任何影响。</li>
<li>所谓互斥使用某临界资源，是指在同一时间段只允许一个进程使用此资源，所以互斥信号量的初值都为1。即使某个临界资源的容量大于1，也要保证在同一时间段只允许一个进程使用，所以互斥信号量的初值都为1。</li>
<li>进程并发带来问题不仅包括同步互斥问题，而且包括死锁等其他问题。<strong>生产者-消费者问题用于解决进程的同步和互斥问题</strong>。共享一个数据对象仅涉及互斥访问的问题。</li>
<li>在生产者-消费者问题中，每次只能有一个生产者或消费者进入缓冲区，需要用一个<strong>互斥信号量</strong>来控制，当有一个生产者或消费者进入缓冲区时，其他申请进入缓冲区的消费者会被阻塞。对应的，存在满缓冲区和空缓冲区<strong>并非互斥信号量</strong>。</li>
</ol>
<h3 id="5-2-算法设计相关"><a href="#5-2-算法设计相关" class="headerlink" title="5.2 算法设计相关"></a>5.2 算法设计相关</h3><ol>
<li><p>在一个仓库中可以存放A和B两种产品，要求：</p>
<ol>
<li>每次只能存入一种产品。</li>
<li>A产品数量-B产品数量&lt;M,其中M是正整数。</li>
<li>B产品数量-A产品数量&lt;N,其中N是正整数。<br> 假设仓库的容量是无限的，试用P,V操作描述产品A和B的入库过程。</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count_a = <span class="number">0</span>, count_b = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>, mutex2 = <span class="number">1</span>, mutex3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(mutex1);</span><br><span class="line">            P(mutex2);</span><br><span class="line">            <span class="keyword">if</span> (count_a+<span class="number">1</span>-count_b&lt;M)</span><br><span class="line">            &#123;</span><br><span class="line">                P(mutex3);</span><br><span class="line">                count_a=count_a+<span class="number">1</span>;</span><br><span class="line">                put_a();</span><br><span class="line">                V(mutex3);</span><br><span class="line">            &#125;</span><br><span class="line">            V(mutex2);</span><br><span class="line">            V(mutex1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(mutex2);</span><br><span class="line">            P(mutex1);</span><br><span class="line">            <span class="keyword">if</span> (count_b+<span class="number">1</span>-count_a&lt;N)</span><br><span class="line">            &#123;</span><br><span class="line">                P(mutex3);</span><br><span class="line">                count_b=count_b+<span class="number">1</span>;</span><br><span class="line">                put_b();</span><br><span class="line">                V(mutex3);</span><br><span class="line">            &#125;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            V(mutex2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>

<p> 另一种实现：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore Sa=M<span class="number">-1</span>,Sb=N<span class="number">-1</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(Sa);</span><br><span class="line">            P(mutex);</span><br><span class="line">            put_a();</span><br><span class="line">            V(Sb);</span><br><span class="line">            V(mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(Sb);</span><br><span class="line">            P(mutex);</span><br><span class="line">            put_b();</span><br><span class="line">            V(Sa);</span><br><span class="line">            V(mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>
</li>
<li><p>面包师有很多面包，由多名销售人员推销。每名顾客进店后按序取一个号，并且等待叫号，当一名销售人员空闲时，就按序叫下一个号。可以用两个整型变量来记录当前的取号值和叫号值，试设计一个使销售人员和顾客同步的算法。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> getnum = <span class="number">0</span>, callnum = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1, mutex2;</span><br><span class="line">semaphore forhead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">seller() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证叫到的号已经被取了</span></span><br><span class="line">        P(forhead);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        call();</span><br><span class="line">        callnum++;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        get();</span><br><span class="line">        getnum++;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        V(forhead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不过上面的算法实际上可以稍微更改一下，不采用forhead量来保证 <code>callnum&lt;getnum</code> ，而是在获得数值之后，再进行判断，同时如果不满足条件可以释放锁，休息片刻，而不是一直让seller忙等待。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> getnum = <span class="number">0</span>, callnum = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1, mutex2;</span><br><span class="line"></span><br><span class="line">seller() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex1);</span><br><span class="line">        <span class="keyword">if</span> (callnum&lt;getnum) &#123;</span><br><span class="line">            call();</span><br><span class="line">            callnum++;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        get();</span><br><span class="line">        getnum++;</span><br><span class="line">        P(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某工厂有两个生产车间和一个装配车间，两个生产车间分别生产A,B两种零件，装配车间的任务是把A,B两种零件组装成产品。两个生产车间每生产一个零件后，都要分别把它们送到专配车间的货架F1,F2上。F1存放零件A,F2存放零件B,F1,和F2的容量均可存放10个零件。装配工人每次从货架上取一个零件A和一个零件B后组装成产品。请用PV操作进行正确管理。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a_full = <span class="number">0</span>, b_full = <span class="number">0</span>;</span><br><span class="line">semaphore a_empty = <span class="number">10</span>, b_empty = <span class="number">10</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">producer_a ()&#123;</span><br><span class="line">    produce_a();</span><br><span class="line">    P(a_empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    put_a();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(a_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer_b ()&#123;</span><br><span class="line">    produce_b();</span><br><span class="line">    P(b_empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    put_b();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(b_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker ()&#123;</span><br><span class="line">    P(a_full);</span><br><span class="line">    P(b_full);</span><br><span class="line">    P(mutex);</span><br><span class="line">    get_ab();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(a_empty);</span><br><span class="line">    V(b_empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的过程略有问题，没仔细看题——两个货架，应当采用两个 <code>mutex</code> 。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore a_full = <span class="number">0</span>, b_full = <span class="number">0</span>;</span><br><span class="line">semaphore a_empty = <span class="number">10</span>, b_empty = <span class="number">10</span>;</span><br><span class="line">semaphore mutex_a = <span class="number">1</span>, mutex_b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">producer_a ()&#123;</span><br><span class="line">    produce_a();</span><br><span class="line">    P(a_empty);</span><br><span class="line">    P(mutex_a);</span><br><span class="line">    put_a();</span><br><span class="line">    V(mutex_a);</span><br><span class="line">    V(a_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer_b ()&#123;</span><br><span class="line">    produce_b();</span><br><span class="line">    P(b_empty);</span><br><span class="line">    P(mutex_b);</span><br><span class="line">    put_b();</span><br><span class="line">    V(mutex_b);</span><br><span class="line">    V(b_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker ()&#123;</span><br><span class="line">    P(a_full);</span><br><span class="line">    P(mutex_a);</span><br><span class="line">    get_a();</span><br><span class="line">    V(mutex_a);</span><br><span class="line">    V(a_empty);</span><br><span class="line">    P(b_full);</span><br><span class="line">    P(mutex_b);</span><br><span class="line">    get_b();</span><br><span class="line">    V(mutex_b);</span><br><span class="line">    V(b_empty);</span><br><span class="line">    produce();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某寺庙有小和尚、老和尚若干，有一水缸，由小和尚提水入缸供老和尚饮用。水缸可容 10桶水，水取自同一井中。水井径窄，每次只能容一个桶取水。水桶总数为3个。每次入缸取水仅为1桶水，且不可同时进行。试给出有关从缸取水、入水的算法描述。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    ```</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 如下图所示，三个合作进程P1,P2,P3,它们都需要通过同一设备输入各自的数据a,b,c,该输入设备必须互斥地使用，而且其第一个数据必须由P1进程读取，第二个数据必须由P2进程读取，第三个数据必须由P3进程读取。然后，三个进程分别对输入数据进行下列计算：P1:x=a+b; P2:y=a*b; P3:z=y+c-a;最后，P1进程通过所连接的打印机将计算结果x,y,z的值打印出来。请用信号量实现它们的同步。</span><br><span class="line"></span><br><span class="line">    ![图 <span class="number">12</span>](images/note2<span class="number">-2</span><span class="number">-1719234457173.</span>png)  </span><br><span class="line"></span><br><span class="line">    ```c</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
