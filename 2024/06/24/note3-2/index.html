<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统笔记3——存储管理——段页式与虚存 | Leeee's Blog</title><meta name="author" content="Lee"><meta name="copyright" content="Lee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统笔记3——存储管理——段页式与虚存  了解段&#x2F;段页式管理，掌握虚存管理。  页式管理简单粗暴的将内存划分为大小相等的页，而段式管理则是将内存划分为大小不等的段。段页式管理则是将内存划分为大小不等的段，每个段再划分为大小相等的页。段式管理更符合程序的逻辑结构，而页式管理更符合硬件的实际操作。段页式管理则是将两者结合起来，既能满足程序的逻辑结构，又能满足硬件的实际操作。 1. 段式管理  段式">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记3——存储管理——段页式与虚存">
<meta property="og:url" content="https://lazybearlee.github.io/2024/06/24/note3-2/index.html">
<meta property="og:site_name" content="Leeee&#39;s Blog">
<meta property="og:description" content="操作系统笔记3——存储管理——段页式与虚存  了解段&#x2F;段页式管理，掌握虚存管理。  页式管理简单粗暴的将内存划分为大小相等的页，而段式管理则是将内存划分为大小不等的段。段页式管理则是将内存划分为大小不等的段，每个段再划分为大小相等的页。段式管理更符合程序的逻辑结构，而页式管理更符合硬件的实际操作。段页式管理则是将两者结合起来，既能满足程序的逻辑结构，又能满足硬件的实际操作。 1. 段式管理  段式">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lazybearlee.github.io/img/header.jpeg">
<meta property="article:published_time" content="2024-06-24T13:09:11.000Z">
<meta property="article:modified_time" content="2024-07-07T04:05:38.212Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="存储管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lazybearlee.github.io/img/header.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lazybearlee.github.io/2024/06/24/note3-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统笔记3——存储管理——段页式与虚存',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-07 12:05:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Leeee's Blog"><span class="site-name">Leeee's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统笔记3——存储管理——段页式与虚存</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-07T04:05:38.212Z" title="更新于 2024-07-07 12:05:38">2024-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/Note/">Note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统笔记3——存储管理——段页式与虚存"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统笔记3-存储管理-段页式与虚存">操作系统笔记3——存储管理——段页式与虚存</h1>
<blockquote>
<p>了解段/段页式管理，掌握虚存管理。</p>
</blockquote>
<p>页式管理简单粗暴的将内存划分为大小相等的页，而段式管理则是将内存划分为大小不等的段。段页式管理则是将内存划分为大小不等的段，每个段再划分为大小相等的页。段式管理更符合程序的逻辑结构，而页式管理更符合硬件的实际操作。段页式管理则是将两者结合起来，既能满足程序的逻辑结构，又能满足硬件的实际操作。</p>
<h2 id="1-段式管理">1. 段式管理</h2>
<ul>
<li>段式管理是按作业的自然段将其逻辑空间分成若干段，作业以段为单位分配内存。</li>
<li><strong>空间安排</strong>：
<ul>
<li>用户作业逻辑空间为二维空间，由若干自然段组成。</li>
<li><strong>逻辑地址</strong>：段号.段内偏移，记作S,d。编译及装配时把所有地址记成(S,d)的形式。</li>
<li>物理内存空间管理：与多道可变划分法一样，系统以段为单位分配物理内存。</li>
</ul>
</li>
</ul>
<p><img src="/images/note3-2-1719286576376.png" alt="图 0"></p>
<p>虽然多道可变划分是连续分配的，但是由于段式分配会将程序拆分为多个段然后再按段进行内存分配，因此段式分配是一种非连续分配。与页式管理类似，段式管理需要一个段表来记录每个段的信息，包括段的起始地址、长度、权限等。</p>
<p>至于物理地址空间的分配，可用采用首次适应算法、最佳适应算法等。</p>
<h3 id="动态地址转换-段式">动态地址转换——段式</h3>
<ul>
<li><strong>段表</strong>：<br>
<img src="/images/note3-2-1719286753575.png" alt="图 1"></li>
<li>段表放于系统空间，进程PCB表中存有段表始地址、段表长度。</li>
<li>系统会启用两个寄存器：段表始地址寄存器、段表长度寄存器</li>
</ul>
<p><img src="/images/note3-2-1719286802741.png" alt="图 2"></p>
<p>当我们拿到一个逻辑地址时，我们首先会将其分解为段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>和段内偏移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>，然后我们首先会检查段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>是否越界（与段表长度寄存器中的值进行比较），如果越界则会产生段越界异常，否则我们会根据段号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>在段表中找到对应的段表项，然后我们会检查段表项中的权限位，如果权限位不满足要求则会产生段访问异常，否则我们会将段表项中的基址加上段内偏移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>得到物理地址。</p>
<p>注意！<strong>做题的时候一定要记得先进行段越界检查</strong>，再进行段访问权限检查。如果出错，就不应该再继续进行后续操作。</p>
<h3 id="段式存储管理的优缺点">段式存储管理的优缺点</h3>
<ul>
<li>优点：
<ul>
<li>没有内碎片，外碎片可以通过<strong>内存紧致</strong>来消除。</li>
<li>便于实现共享，即允许若干个进程共享一个或者多个段。</li>
</ul>
</li>
</ul>
<p><img src="/images/note3-2-1719287050326.png" alt="图 3"></p>
<h2 id="2-段页式管理">2. 段页式管理</h2>
<ul>
<li>段页式管理是将内存划分为大小不等的段，每个段再划分为大小相等的页。段页式管理既能满足程序的逻辑结构，又能满足硬件的实际操作。</li>
<li>在这种情况下，对于用户来说，管理与段式相同，逻辑地址只涉及到段号和段内偏移；而对于系统来说，管理与页式相同，物理地址涉及到页号和页内偏移。</li>
<li>逻辑地址：
<ul>
<li>段号.段内偏移（页号.页内偏移）</li>
<li>编译及装配时把所有地址记成(S,P,W)的形式。</li>
<li><img src="/images/note3-2-1719287188826.png" alt="图 4"></li>
</ul>
</li>
</ul>
<p>在这种管理方案中，页式与段式的相关寄存器都会被启用。</p>
<p>而这时，如果不采用快表，为了获取一条指令或者数据，我们需要先通过段号找到段表项，然后再通过页号找到页表项，最后才能得到物理地址。这里需要<strong>访问内存三次</strong>。</p>
<p>而如果采用快表，假设访存时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> ，快表查找时间为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，快表命中率为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> ，则访问内存的平均时间为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mtext>average</mtext></msub><mo>=</mo><mi>h</mi><mo>×</mo><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>h</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>3</mn><mi>t</mi><mo>+</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_{\text{average}} = h\times(t+t_1) + (1-h)\times(3t+t_1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">average</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>保护实现的方式与段式管理类似，而共享可以以段为单位，也可以以页为单位，也可以共享页表。</p>
<p><img src="/images/note3-2-1719287474661.png" alt="图 5"></p>
<h2 id="3-虚存管理-内存扩充技术">3. 虚存管理（内存扩充技术）</h2>
<h3 id="3-1-提出背景">3.1 提出背景</h3>
<ul>
<li>在基本的存储管理系统中，当一个作业的程序地址空间大于内存可以使用的空间时，该作业就不能装入运行，并发运行进程数受到了内存空间的限制。</li>
<li>而内存扩充技术就是借助大容量的辅存在逻辑上实现内存的扩充，来解决内存容量不足的问题。</li>
</ul>
<h3 id="3-2-虚存管理的前置技术">3.2 虚存管理的前置技术</h3>
<h4 id="覆盖技术-overlay">覆盖技术（Overlay）</h4>
<ul>
<li>目标：在较小的可用内存中运行较大的程序。</li>
<li>原理：将用户空间划分成一个固定区和多个覆盖区。主程序放固定区，依次调用的子程序则放在同一个覆盖区。操作系统提供覆盖系统调用函数，由用户编程序显式调用。</li>
</ul>
<p><img src="/images/note3-2-1719287631601.png" alt="图 6"></p>
<p>例如，当上图中的B段允许结束后，我们就可以将C段覆盖在B段上，然后执行C段的程序。我们会发现，这样的执行方式天生的与前文提到的段页式管理匹配。</p>
<h5 id="覆盖技术的优缺点">覆盖技术的优缺点</h5>
<ul>
<li>优点：
<ul>
<li>适用于大型程序，可以将程序分成多个模块，每次只装入一个模块。</li>
<li>可以减少内存的浪费，提高系统并发性。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>程序员需要手动调用覆盖系统调用函数，增加了编程的复杂性。</li>
<li>从外存装入覆盖文件，是以时间延长来换取空间节省的；</li>
<li>覆盖区仍然存在着碎片（分区固定）。</li>
</ul>
</li>
</ul>
<h4 id="交换技术">交换技术</h4>
<ul>
<li>最早应用于MIT的CTSS系统。</li>
<li>原理：将处于等待状态(等I/O结束)或就绪(等CPU)状态的作业从主存换出到辅存，把将要执行的进程移入主存。</li>
</ul>
<p><img src="/images/note3-2-1719287831344.png" alt="图 7"></p>
<h5 id="交换技术的优缺点">交换技术的优缺点</h5>
<ul>
<li>优点：
<ul>
<li>增加并发运行的程序数目</li>
<li>可以提供优先级服务</li>
</ul>
</li>
<li>缺点：
<ul>
<li>对换入和换出的控制增加处理机开销；</li>
<li>程序换入时的重定位问题。</li>
</ul>
</li>
</ul>
<h4 id="覆盖技术与交换技术的比较">覆盖技术与交换技术的比较</h4>
<p><img src="/images/note3-2-1719287904111.png" alt="图 8"></p>
<h3 id="3-3-虚存管理技术">3.3 虚存管理技术</h3>
<ul>
<li>虚存管理技术是一种<strong>逻辑上扩充内存容量</strong>的技术，它将内存和外存结合起来，使得用户程序在运行时，可以不必全部装入内存，而是根据需要，将程序的一部分装入内存，另一部分留在外存，这样就可以运行比内存大的程序。</li>
<li>基础
<ul>
<li>程序中不是每一条指令都会在程序的一次运行过程中执行到。
<ul>
<li>错误处理子程序</li>
<li>条件语句(if…else…)</li>
</ul>
</li>
<li>程序中有的指令可能只执行一次
<ul>
<li>一次性初始化</li>
<li>一次性处理</li>
</ul>
</li>
<li>程序执行的局部性原理
<ul>
<li>时间局部性：一个指令执行后，接下来执行的可能还是这个指令</li>
<li>空间局部性：一个指令执行后，接下来执行的可能是附近的指令</li>
</ul>
</li>
</ul>
</li>
<li>原理：
<ul>
<li>在程序装入时，不必一次将其全部读入到内存，而只需将当前需要执行的某些区域读入到内存，然后程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存，则由处理器通知操作系统将相应的区域调入内存，然后继续执行。</li>
</ul>
</li>
<li>好处：
<ul>
<li>程序的大小可以突破内存容量限制，使得用户感觉到系统好像提供了一个容量极大的“主存”。</li>
<li>内存中容纳更多程序并发执行。</li>
</ul>
</li>
<li>分类：
<ul>
<li>虚拟页式存储管理<br>
纯页式管理 ＋ 请求调页</li>
<li>虚拟段式存储管理<br>
纯段式管理 ＋ 请求调段</li>
<li>虚拟段页式存储管理<br>
虚拟页式管理 ＋ 虚拟段式管理</li>
</ul>
</li>
</ul>
<h4 id="虚拟页式管理技术">虚拟页式管理技术</h4>
<ul>
<li>基本思想：<br>
在页式管理基础上，仅将进程的一部分页放于主存。页表项中注明该页是否在主存。<br>
程序执行时，如果访问的页不存主存，根据页表项的指示，将其从外存调入主存，如果此时无可用的内存空间，则先淘汰若干页帧。</li>
</ul>
<p><img src="/images/note3-2-1719298452588.png" alt="图 9"></p>
<p>在上面的过程中，如果内存没有空闲页面，而要调入的页面又不在内存中，那么就需要进行页面置换。页面置换算法有很多种，例如最佳置换算法、先进先出置换算法、最近最久未使用置换算法、最近最少使用置换算法等。这将在后续的内容中详细介绍。</p>
<p><img src="/images/note3-2-1719298525631.png" alt="图 10"></p>
<h5 id="交换区-swap">交换区（SWAP）</h5>
<ul>
<li>进程刚建立时，<strong>进程页面所在辅存</strong>即程序文件所在的辅存位置。</li>
<li>程序文件中一般包含有程序的二进制目标码及数据初始值和初值为0的工作区。后两者在回写时不能写入程序文件，在需要让其让出内存时将内存原数据写入交换区中。</li>
</ul>
<p>当这个程序运行时，其数据可能会发生变化。如果程序或进程需要被暂时从物理内存中移除（比如为了释放内存给其他进程使用），那么这些变化过的数据不能简单地写回原始的程序文件中，因为程序文件需要保持不变，以确保程序的正确性和重用性。</p>
<p>在这种情况下，操作系统会使用一个特殊的存储区域，称为交换区（SWAP）。交换区用于临时存储那些从物理内存中移除的进程的数据。这样，当进程再次需要运行时，操作系统可以从交换区中读取之前的数据状态，恢复到内存中，使得进程可以从之前中断的地方继续执行。</p>
<h5 id="页表项结构">页表项结构</h5>
<p><img src="/images/note3-2-1719298646008.png" alt="图 11"></p>
<ul>
<li>合法位：表示该页是否在主存中。</li>
<li>修改位：表示该页在主存中是否被修改过，在释放或淘汰时需要根据此位决定是否将其写回外存。</li>
<li>页类型：零页时：表示该页在分配物理页帧时应清0页帧空间;回写swap区页时:表示回写swap区。</li>
<li>保护码：表示该页的访问权限（RWE）。</li>
<li>外存块号：表示该页在外存中的位置。</li>
<li>页帧号：当合法位置上时代表该页所在内存的页帧号。</li>
</ul>
<h4 id="页表建立">页表建立</h4>
<ul>
<li>在<strong>进程创建时建立页表</strong>，页表项在初始时，合法位、修改位及页帧号都未置上。</li>
<li><strong>初始化页表</strong>：
<ol>
<li>部分复制父进程页表 (如UNIX的fork())
<ul>
<li>分配pid给子进程，分配PCB空间;</li>
<li>初始化PCB（进程标识，调度信息）;</li>
<li>分配子进程页表空间;</li>
<li>拷贝父进程的<strong>程序区</strong>页表项，使程序共享;</li>
<li>复制父进程的数据区和栈区，<strong>为数据区和栈区分配swap空间</strong>，复制并修改数据区和栈区页表项内容;</li>
<li>继承父进程对其他资源的访问接口;</li>
<li>用父进程PCB中现场区初始化子进程的现场区，且保证子进程恢复现场从fork（）返回处开始运行，且fork()返回值为0;</li>
<li>将子进程挂到就绪队列;</li>
<li>返回子进程pid给父进程，fork()返回值为子进程pid。</li>
</ul>
</li>
<li>用一个可执行文件初始化页表
<ul>
<li>为执行程序页面建页表项，保护码为<strong>可执行</strong>，外存块号即<strong>该页所在的文件的外存块号</strong>。（不必回写）</li>
<li>为所有初始数据页建页表项，保护码为可读写，页类型说明回写swap页，<strong>外存块号</strong>即该页所在文件的物理块号，<strong>待该页回写时，再分配swap区空间，改外存块号栏并清除页类型</strong>。</li>
<li><strong>为所有临时数据页建页表项，保护码为可读写</strong>，页类型说明成零页，外存块号栏空，当第一次访问该页时，分配页帧并清0页帧，回写时，再分配swap区空间，填外存块号栏并清除页类型。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="动态地址转换-虚存管理">动态地址转换——虚存管理</h4>
<p>在执行虚存访问指令时,由硬件合成物理地址:</p>
<ul>
<li>首先若能<strong>在联想存储器中获得该虚页的物理页帧号</strong>，则访问之(联想存储器中的页表项都是合法页的页表项)。</li>
<li>若要查当前进程页表，须<strong>先检查该页页表项的合法位</strong>，若置上，则从页表项中获得页帧号，得物理地址访问之。</li>
<li>否则要<strong>发一个页故障(page fault)或叫缺页中断（异常）</strong>，当缺页中断处理完后，返回。</li>
<li>重新执行访存指令。</li>
</ul>
<h4 id="缺页处理">缺页处理</h4>
<p>当硬件执行访存指令产生一个缺页中断时进入缺页中断处理程序：</p>
<ol>
<li>根据发生页故障的虚地址得到页表项；</li>
<li>申请一个可用的页帧(根据所采用的替换策略可能需要引起淘汰某一页);</li>
<li>检查页类型，若为<strong>零页，则将页帧清0</strong>，将页帧号填入页表项的页帧号一栏，置合法位为1。若非零页，则调用I/O子系统将外存块号所指的数据读到可用页帧，将页帧号填入页表项中，合法位置1，结束。</li>
</ol>
<h4 id="页淘汰">页淘汰</h4>
<ul>
<li>页淘汰是指当内存中没有空闲页帧时，需要将内存中的某些页帧替换出去，以便为新的页帧腾出空间。</li>
<li>淘汰所需要完成的工作：
<ol>
<li>查P页表项的修改位，若未修改，则清0合法位，将页帧送回空闲页帧队列。</li>
<li>若已修改，则检查类型栏。</li>
<li>若是零页或回写swap区页，则申请一块swap区空间，将P的外存块号置上并清除页类型。</li>
<li>调用I/0子系统将页帧上的数据写到外存块号所指的外存空间。清0合法位，将页帧送回空闲页帧队列。</li>
</ol>
</li>
</ul>
<h4 id="页类型">页类型</h4>
<p>在虚拟内存管理中，页表项中的页类型通常指的是该页在内存中的状态或内容类型。主要的页类型包括：</p>
<ol>
<li>
<p><strong>零页（Zero Page）</strong>：零页是一种特殊类型的页，其内容全为0。操作系统在分配新的内存页时，如果发现是零页，会直接将该页内容清零，而不是从磁盘读取数据填充该页。这种页类型常用于初始化新分配的内存区域，确保应用程序获得的是干净、未使用的内存空间。</p>
</li>
<li>
<p><strong>常规页</strong>：这是最常见的页类型，包含实际的数据或代码。当进程访问这些页时，如果它们不在物理内存中，则会触发缺页中断，操作系统随后会从磁盘（或其他辅助存储设备）中将数据读入内存。</p>
</li>
<li>
<p><strong>修改过的页（Dirty Page）</strong>：当进程对某个内存页进行了写操作，该页的内容就与磁盘上的副本不同，这种页被标记为修改过的页。如果需要将这个页从物理内存中移除（比如在页面替换过程中），操作系统需要先将其写回磁盘，以确保数据的一致性。</p>
</li>
<li>
<p><strong>共享页</strong>：在某些情况下，不同的进程可能会共享相同的代码或数据页，这些页被标记为共享页。共享页可以提高内存使用效率，因为它避免了相同内容的多份拷贝。</p>
</li>
</ol>
<p>零页是上述类型中特殊的一种，主要用于优化内存分配和初始化过程。通过使用零页，操作系统可以快速为应用程序提供清零后的内存空间，而无需逐个字节地清零或从磁盘读取特定内容填充。这种方法不仅提高了内存分配的效率，还保证了新分配的内存区域不会包含旧数据，从而增强了程序的安全性。</p>
<h2 id="4-页面替换策略">4. 页面替换策略</h2>
<blockquote>
<p>前情提要，虚存被引入，用以解决内存空间不足的问题。但是，当内存空间不足时，我们就需要进行页面替换，以便为新的页面腾出空间。页面替换策略是指在内存空间不足时，操作系统如何选择哪些页面被替换出去，以便为新的页面腾出空间。常见的页面替换策略包括先进先出（FIFO）、最近最少使用（LRU）、最不常用（LFU）等。</p>
</blockquote>
<ul>
<li><strong>页面置换策略</strong>：页面置换算法决定在需要调入页面时，选择内存中哪个物理页面被置换。出发点是希望<strong>把未来不再使用的或者短时期内较少使用的页面</strong>调出。</li>
<li>评价标准：
<ul>
<li><strong>缺页率</strong>：缺页率越低，说明页面置换算法好。我们必须防止系统发生抖动（频繁地发生缺页中断）。</li>
<li><strong>算法本身复杂度</strong>：算法越复杂，实现难度越大，效率越低。</li>
</ul>
</li>
</ul>
<h3 id="颠簸-抖动-thrashing">颠簸/抖动(thrashing)</h3>
<ul>
<li>页面<strong>在内存与外存之间频繁调度</strong>，以至于调度页面所需时间比进程实际运行的时间还多，此时系统效率急剧下降，甚至导致系统崩溃。这种现象称为<strong>颠簸或抖动</strong>。</li>
<li><strong>颠簸的原因</strong>：页面淘汰算法不合理。分配给进程的物理页面数太少。</li>
</ul>
<h3 id="基本概念">基本概念</h3>
<ul>
<li><strong>驻留集</strong>：在内存中的页面集合。（合法页集合）</li>
<li><strong>访问串</strong>：进程在执行过程中访问的页面序列。（进程访问虚空间的地址踪迹。）</li>
</ul>
<p>举例：某进程依次访问如下地址，0100，0432，0101，0612，0102，0103，…</p>
<p>而<strong>页式虚存管理以页为基本单位</strong>，只需页号即可。设页面大小为100，上述访问串可简化为1，4，1，6，1，1，…</p>
<p>而按照驻留集大小，我们可以将页面置换算法分为<strong>固定驻留集大小</strong>和<strong>可变驻留集大小</strong>。</p>
<p>其中，<strong>固定驻留集大小</strong>的页面置换算法有：</p>
<ul>
<li>先进先出（FIFO）</li>
<li>最近最少使用（LRU）</li>
<li>最佳算法（OPT）</li>
<li>时钟置换算法（CLOCK）</li>
</ul>
<p>而<strong>可变驻留集大小</strong>的页面置换算法有：</p>
<ul>
<li>工作集模型(WS)</li>
<li>SWS</li>
</ul>
<h3 id="先进先出-fifo">先进先出（FIFO）</h3>
<ul>
<li><strong>置换最先进入内存的页面</strong>。</li>
</ul>
<p>举例：驻留集大小为3，访问串为 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2…</p>
<p><img src="/images/note3-2-1719300140037.png" alt="图 12"></p>
<ul>
<li>FIFO方法的特点：
<ul>
<li>实现方便。不需要额外硬件。</li>
<li>效果不好，有<strong>Belady奇异</strong>。</li>
</ul>
</li>
</ul>
<p>Belady奇异：指<strong>置换策略不满足随着驻留集的增大，页故障数一定减少的规律</strong>。</p>
<p>例如，有访问串序列：1,2,3,4,1,2,5,1,2,3,4,5<br>
在驻留集分别为3和4时，页故障数分别为10和10，不满足随着驻留集的增大，页故障数一定减少的规律。</p>
<h3 id="最佳置换算法-opt">最佳置换算法（OPT）</h3>
<ul>
<li><strong>置换未来最长时间不被访问的页面</strong>。</li>
</ul>
<p>举例：驻留集大小为3，访问串为 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2…</p>
<p><img src="/images/note3-2-1719300367391.png" alt="图 13"></p>
<p>缺页次数明显少于FIFO算法，但是<strong>OPT算法是不可实现的</strong>，因为我们无法预知未来的访问情况。</p>
<p>OPT策略对任意一个访问串的控制均有最小的时空积。（进程所占空间与时间的乘积）。不过由于需要预先得知整个访问串的序，故不能用于实践。仅作为一种标准，用以测量其他可行策略的性能。</p>
<h3 id="最近最少使用-lru">最近最少使用（LRU）</h3>
<ul>
<li><strong>置换最长时间未被访问的页面</strong>。</li>
</ul>
<p>举例：驻留集大小为3，访问串为 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2…</p>
<p><img src="/images/note3-2-1719300476572.png" alt="图 14"></p>
<h4 id="栈算法">栈算法</h4>
<ul>
<li>LRU策略是一种栈算法。</li>
<li>满足：S（m，t）属于 S（m+1，t）的置换算法被称为栈算法。（m/m+1为驻留集大小）。</li>
<li>LRU策略中，当驻留集大小为m时，S（m，t）中保持着最近使用过的m个页帧；当驻留集大小为m+1时，S（m+1，t）中保持着最近使用过的m+1个页帧。故S（m，t）属于 S（m+1，t），LRU策略是栈算法。</li>
</ul>
<h5 id="栈算法没有belady奇异">栈算法没有Belady奇异</h5>
<p><strong>证明</strong>：设n&gt;m，对于栈算法有S(m，t)属于 S(n，t) ，任取r (t)，若r (t) !∈ S(n，t), 则r (t) !∈ S(m，t)。因此，驻留集为n时出现的页故障一定会出现在驻留集为m时。<br>
<strong>LRU没有Belady奇异。</strong></p>
<h4 id="lru策略的特点">LRU策略的特点</h4>
<ul>
<li><strong>要硬件配合，实现费用高，但效果适中。</strong></li>
<li>实现方法之一：给每个页帧设一个计数器，每访问一页，对应页帧计数清0，其余页帧计数加1，淘汰计数最大的页帧。</li>
</ul>
<h3 id="时钟置换算法-clock">时钟置换算法（CLOCK）</h3>
<ul>
<li><strong>时钟置换算法是一种近似LRU算法</strong>。硬件在页面被访问时设置页表项中的访问位，随着表针的移动，淘汰访问位是0的页面，或清除页面的访问位。</li>
<li>是一种非常实用的算法，<strong>实现简单，效果较好</strong>。</li>
</ul>
<p><img src="/images/note3-2-1719300774240.png" alt="图 16"></p>
<h3 id="最近未使用-nru">最近未使用（NRU）</h3>
<ul>
<li>为页帧在页表项中增加一位使用位，硬件<strong>每访存一次即将对应页的使用位置1</strong>，操作系统页面管理程序定时将所有使用位清0。<strong>淘汰时任选一个使用位为0（表示OS清0周期内没被使用过）的页</strong>。操作系统选择淘汰页时，尽量避免选被修改过的页。</li>
<li>于是，淘汰的时候，会查看页表项的两个位：使用位和修改位。使用位为0的页优先被淘汰，如果使用位都为1，则查看修改位，修改位为0的页优先被淘汰。</li>
</ul>
<h3 id="驻留集大小可变的全局置换策略">驻留集大小可变的全局置换策略</h3>
<ul>
<li>
<p><strong>程序行态</strong>：指程序访存布局特性和行为特性</p>
<ul>
<li>局部性行态:一段时间内程序访存有局部性，这些与局部性相关的页面集合称为工作集.</li>
<li>阶段转换行态:从一个工作集向另一个工作集过渡是突然的.</li>
</ul>
</li>
<li>
<p><strong>全局置换引入原因</strong>: 驻留集大小&lt;工作集大小=&gt;抖动;驻留集大小&gt;工作集大小=&gt;浪费;工作集是变化的。因此，应随着程序访问虚存的工作集大小变化而改变驻留集大小。</p>
</li>
</ul>
<h4 id="工作集模型-ws-working-set">工作集模型(WS, Working Set)</h4>
<ul>
<li>
<p>若驻留集中的某页有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 个访问间隔没被访问则将其淘汰。</p>
</li>
<li>
<p>例如，取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 为5，访问串为 7、0、1、2、0、3、0、4、2、3、0、3、2、1、2、0、1<br>
<img src="/images/note3-2-1719301174756.png" alt="图 17"></p>
</li>
<li>
<p>实现：每一页面设一计数器。每访存一次，将所有其它页计数器加1，所访存的页面计数器清0，淘汰计数器值等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 的页面。</p>
</li>
<li>
<p>不过这种算法开销较大，因为每次访问都要对所有页面进行计数器的更新。</p>
</li>
</ul>
<h4 id="sws-sampled-working-set">SWS（Sampled Working Set）</h4>
<ul>
<li><strong>取样工作集</strong>：定时检查计时器，淘汰计时器值大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 的页面，这样硬件消耗仍然较大。</li>
<li>每访问一页，将当前硬时钟值记录在页表项中，操作系统定时(以T为周期)检查驻留集页表项的时钟值，若: $ \text{当前时钟值} - \text{页表项时钟值} &gt; \Delta$，则淘汰该页。</li>
</ul>
<h3 id="置换策略选择">置换策略选择</h3>
<p>实用操作系统（Windows NT, Linux）：动态驻留集SWS+淘汰页数据延迟清除。</p>
<ul>
<li>设立两个队列：<strong>自由链表和修改链表</strong>。</li>
<li>定时做页淘汰（SWS）：淘汰时不立即抹去页中数据，根据页面修改否挂入自由链/修改链，修改链过长或自由链过短时，回写页面后改挂到自由链中。</li>
<li>若paging in要用空页时,<strong>选自由链的第一页帧</strong>，这时页中数据被覆盖。</li>
<li>若在自由链/修改链中的页面再次被访问时，则将该页从链中摘除,使该页又能通过页表项访问到。</li>
</ul>
<h2 id="5-多级页表">5. 多级页表</h2>
<ul>
<li><strong>多级页表</strong>是一种用于解决页表过大的问题的技术。在多级页表中，页表被分成多个级别，每个级别的页表只包含一部分页表项，而不是所有的页表项。这样，可以减少页表的大小，提高内存的使用效率。</li>
</ul>
<p>例如：</p>
<p>一个具有32位逻辑地址空间的计算机系统，如果系统的页大小为4KB( <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">2^12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span> )， 则一个页表可以包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>1</mn></msup><mn>2</mn><mo>=</mo><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^32 / 2^12 = 2^20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span> 个表项，若一个表项占用4B，则每个进程需要4MB物理地址空间存储页表，且要求是连续的。</p>
<p>为了解决这个问题，可以将页表分成多个级别，每个级别的页表只包含一部分页表项。例如，可以将32位逻辑地址分成三部分，前10位作为一级页表的索引，中间10位作为一级页表的页内偏移，最后12位作为页内偏移。</p>
<p><img src="/images/note3-2-1719301935703.png" alt="图 18"></p>
<h3 id="两级页表结构">两级页表结构</h3>
<p><img src="/images/note3-2-1719301964245.png" alt="图 19"></p>
<h4 id="地址变换-多级页表">地址变换——多级页表</h4>
<p><img src="/images/note3-2-1719301996610.png" alt="图 20"></p>
<p>我们首先要根据逻辑地址的高10位找到外部页表的页表项，然后根据逻辑地址的中间10位找到页表的页表项，最后根据逻辑地址的低12位拼接得到物理地址。</p>
<p>而对于64位的系统，我们可以将页表分成三级。</p>
<p><img src="/images/note3-2-1719302199793.png" alt="图 21"></p>
<h3 id="哈希页表">哈希页表</h3>
<blockquote>
<p>哈希桶</p>
</blockquote>
<p><img src="/images/note3-2-1719302389439.png" alt="图 22"></p>
<ul>
<li>超过32位地址空间的常用方法</li>
<li>以逻辑页号作为哈希值，哈希页表的每一个表项都包括一个链表，链表中的元素哈希为同一个位置</li>
<li>每个元素包含3个域：逻辑页号、物理块号、指向下一个元素的指针</li>
</ul>
<h4 id="地址映射">地址映射</h4>
<ul>
<li>逻辑页号通过哈希函数映射到哈希页表的某个位置，然后用逻辑页号与链表中的每一个元素的第一个域进行比较：
<ul>
<li>若相等，则返回该元素的物理块号/利用该元素的物理块号进行地址映射形成物理地址</li>
<li>若不相等，则继续比较下一个元素直到找到匹配的元素</li>
</ul>
</li>
</ul>
<h2 id="6-页式管理">6. 页式管理</h2>
<ul>
<li>确定页面大小
<ul>
<li>页面越大，无用程序装入主存就越多，从而使主存浪费严重</li>
<li>页面越小，程序需要的页越多，页表越大</li>
<li>最佳页尺寸</li>
</ul>
</li>
</ul>
<p>设进程平均大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 字节，页大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 字节，页表项占 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span> 字节，则</p>
<ul>
<li>进程所需页数：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi mathvariant="normal">/</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">s/p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span></span></li>
<li>页表大小：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">se/p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span></span></li>
<li>进程内部碎片平均值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">p/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord">2</span></span></span></span></li>
<li>页表和内部碎片引起的系统开销：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo>+</mo><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">se/p + p/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord">2</span></span></span></span>
<ul>
<li>页表开销中，页越小，页表项数越多，开销越大</li>
<li>内部碎片开销中，页越小，内部碎片越小，开销越小</li>
</ul>
</li>
<li>对页大小求导，得到最佳页大小
<ul>
<li>$ \frac{d}{dp} (se/p + p/2) = -se/p^2 + 1/2 = 0 $</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msqrt><mrow><mn>2</mn><mi>s</mi><mi>e</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">p = \sqrt{2se}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="7-补充">7. 补充</h2>
<ol>
<li>硬件地址变换机构一般用于动态重定位的情况。而单一连续分配和固定分区分配采用的是静态重定位，不需要硬件地址变换机构，而由装入程序或操作系统来完成地址转换。因此，只有页式存储管理、动态分区分配和页式虚拟存储管理需要硬件地址变换机构。</li>
<li>可重定位装入程序在重定位的过程中执行，重定位寄存器（也称基址寄存器）用于存放进程的基地址，地址变换机构用于将指令中的逻辑地址与重定位寄存器中的基地址相加得到物理地址。<strong>目标程序是装入内存后执行的，动态重定位不依赖于目标程序。</strong></li>
<li>拼接技术指的是合并多个小的空闲区域，形成一个大的空闲区域。这样可以减少外部碎片，提高内存的利用率。拼接技术主要用于动态分区分配中，用于合并多个小的空闲区域，以便分配给大的进程。而不是指定地址的重定位。</li>
<li>基于顺序搜索的分配算法有首次适应算法、循环首次适应算法、最佳适应算法和最坏适应算法；基于索引搜索的分配算法有快速适应算法、伙伴系统和哈希算法。</li>
<li>页表和段表同样存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。</li>
<li>动态分区时，在系统启动后，除操作系统占据一部分内存外，其余所有内存空间是一个大空闲区，称为<strong>自由空间</strong>。若作业申请内存，则从空闲区中划出一个与作业需求量相适应的分区分配给该作业，将作业创建为进程，在作业运行完毕后，再收回释放的分区。</li>
<li>引入段式存储管理方式，主要是为了满足用户的下列要求：方便编程、分段共享、分段保护、动态链接和动态增长。</li>
<li>关于地址结构，分段式和分页式都是一维的，而段页式是二维的。分段式的地址结构是段号+段内偏移，分页式的地址结构是页号+页内偏移，段页式的地址结构是段号+段偏移（页号+页内偏移）。</li>
<li>虚拟存储技术并未实际扩充内存、外存，而是采用相关技术相对地扩充主存。是补充内存逻辑空间的技术，使得用户感觉到系统提供了一个容量极大的“主存”。</li>
<li>无论采用什么页面置换算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以缺页次数大于或等于n。</li>
<li>在虚拟内存管理中，全局置换（Global Replacement）和局部置换（Local Replacement）是两种不同的页面置换策略，用于决定当发生缺页中断时，应该从内存中淘汰哪个页面来为新页面腾出空间。<br>
全局置换
<ul>
<li><strong>定义</strong>：全局置换策略允许操作系统从整个物理内存中的所有页中选择一个页面进行置换，而不限于当前进程所拥有的页面。这意味着一个进程可以淘汰另一个进程的页面。</li>
<li><strong>优点</strong>：提供了更大的灵活性和内存利用率，因为操作系统可以根据整个系统的页面使用情况来做出最优的置换决策。</li>
<li><strong>缺点</strong>：可能导致进程间的页面抢占，增加了进程的页面错误率，可能会影响到进程的执行效率。<br>
局部置换</li>
<li><strong>定义</strong>：局部置换策略限制操作系统只能从当前进程所拥有的页面中选择一个页面进行置换。每个进程有自己的一组页面，置换操作仅在这组页面内进行。</li>
<li><strong>优点</strong>：减少了进程间的干扰，每个进程的页面置换只影响自己，从而可以更好地控制每个进程的性能。</li>
<li><strong>缺点</strong>：可能导致内存的利用率不如全局置换高，因为每个进程的页面集合是固定的，可能会有空闲页面但不能被其他需要更多内存的进程使用。</li>
</ul>
</li>
<li>内存映射文件将一个文件映射到进程的虚拟地址空间的某个区域，让进程可以按读写内存的方式来读写文件。内存映射文件不是一次性加载整个文件，而是按需加载文件的部分，这样既节省空间，又方便处理大文件。虽然进程的虚拟地址空间是独立的，但操作系统可以通过页表将对应的虚拟地址空间映射到相同的物理内存，很方便实现多个进程共享同一文件。</li>
<li><strong>缺页中断</strong>产生后，需要<strong>在内存中找到空闲页框并分配给需要访问的页</strong>（可能涉及页面置换），之后缺页中断处理程序调用设备驱动程序做磁盘I/O,将位于外存上的页面调入内存，调入后需要修改页表，将页表中代表该页是否在内存的标志位（或有效位）置为1，并将物理页框号填入相应位置，若必要还需修改其他相关表项等。</li>
<li>在任意时刻 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> ,都存在一个集合，它包含所有最近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次(该题窗口大小为6)内存访问所访问过的页面。这个集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(k,t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span> 就是工作集。题中最近 6 次访问的页面分别为 6,0,3,2,3,2,去除重复的页面，形成的工作集为{6,0,3,2<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span>。</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/">存储管理</a></div><div class="post_share"><div class="social-share" data-image="/img/header.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统笔记3——存储管理</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/23/note2-2/" title="操作系统笔记2——进程并发、同步与互斥"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统笔记2——进程并发、同步与互斥</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="title">操作系统笔记3——存储管理</div></div></a></div><div><a href="/2024/06/21/note1/" title="操作系统笔记1——操作系统结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="title">操作系统笔记1——操作系统结构</div></div></a></div><div><a href="/2024/02/15/os-lab-1/" title="os_lab_1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-15</div><div class="title">os_lab_1</div></div></a></div><div><a href="/2024/02/15/6.S081-note-lec1/" title="6.S081-note-lec1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-15</div><div class="title">6.S081-note-lec1</div></div></a></div><div><a href="/2024/06/24/note2-3/" title="操作系统笔记2——进程死锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="title">操作系统笔记2——进程死锁</div></div></a></div><div><a href="/2024/06/22/note2-1/" title="操作系统笔记2——进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-22</div><div class="title">操作系统笔记2——进程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lee</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lazybearlee"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lazybearlee" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B03-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E4%B8%8E%E8%99%9A%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">操作系统笔记3——存储管理——段页式与虚存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">1. 段式管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-%E6%AE%B5%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">动态地址转换——段式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">段式存储管理的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">2. 段页式管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">3. 虚存管理（内存扩充技术）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 提出背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%89%8D%E7%BD%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 虚存管理的前置技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-overlay"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">覆盖技术（Overlay）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">覆盖技术的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">交换技术的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">覆盖技术与交换技术的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 虚存管理技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">虚拟页式管理技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%8C%BA-swap"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">交换区（SWAP）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">页表项结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">页表建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">动态地址转换——虚存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">缺页处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E6%B7%98%E6%B1%B0"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">页淘汰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">页类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.</span> <span class="toc-text">4. 页面替换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%A0%E7%B0%B8-%E6%8A%96%E5%8A%A8-thrashing"><span class="toc-number">1.4.1.</span> <span class="toc-text">颠簸&#x2F;抖动(thrashing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-fifo"><span class="toc-number">1.4.3.</span> <span class="toc-text">先进先出（FIFO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-opt"><span class="toc-number">1.4.4.</span> <span class="toc-text">最佳置换算法（OPT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8-lru"><span class="toc-number">1.4.5.</span> <span class="toc-text">最近最少使用（LRU）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">栈算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E7%AE%97%E6%B3%95%E6%B2%A1%E6%9C%89belady%E5%A5%87%E5%BC%82"><span class="toc-number">1.4.5.1.1.</span> <span class="toc-text">栈算法没有Belady奇异</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lru%E7%AD%96%E7%95%A5%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">LRU策略的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-clock"><span class="toc-number">1.4.6.</span> <span class="toc-text">时钟置换算法（CLOCK）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8-nru"><span class="toc-number">1.4.7.</span> <span class="toc-text">最近未使用（NRU）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86%E5%A4%A7%E5%B0%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.4.8.</span> <span class="toc-text">驻留集大小可变的全局置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B-ws-working-set"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">工作集模型(WS, Working Set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sws-sampled-working-set"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">SWS（Sampled Working Set）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.9.</span> <span class="toc-text">置换策略选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5. 多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">两级页表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">地址变换——多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">哈希页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">地址映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">6. 页式管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%A1%A5%E5%85%85"><span class="toc-number">1.7.</span> <span class="toc-text">7. 补充</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/18/sync/" title="Go Sync 不完全解析">Go Sync 不完全解析</a><time datetime="2024-07-18T10:10:23.000Z" title="发表于 2024-07-18 18:10:23">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/07/context/" title="Go Context 不完全解析">Go Context 不完全解析</a><time datetime="2024-07-07T04:00:01.000Z" title="发表于 2024-07-07 12:00:01">2024-07-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/note2-3/" title="操作系统笔记2——进程死锁">操作系统笔记2——进程死锁</a><time datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理">操作系统笔记3——存储管理</a><time datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/note3-2/" title="操作系统笔记3——存储管理——段页式与虚存">操作系统笔记3——存储管理——段页式与虚存</a><time datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>