<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统笔记2——进程并发、同步与互斥 | Leeee's Blog</title><meta name="author" content="Lee"><meta name="copyright" content="Lee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程并发、同步与互斥1. 进程并发执行的问题 在本部分，要了解可并行程序的高级语言表示和操作系统的支持；了解并发执行引起的同步和互斥问题；了解进程的同步和互斥的基本概念。  1.1 并发的需求 程序设计上，要利用操作系统对于并发的支持（进程&#x2F;线程），安排可并行事务并发执行 操作系统的核心程序也要尽可能并发的执行  1.2 并发编程123456789101112@startumlstart">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记2——进程并发、同步与互斥">
<meta property="og:url" content="https://lazybearlee.github.io/2024/06/23/note2-2/index.html">
<meta property="og:site_name" content="Leeee&#39;s Blog">
<meta property="og:description" content="进程并发、同步与互斥1. 进程并发执行的问题 在本部分，要了解可并行程序的高级语言表示和操作系统的支持；了解并发执行引起的同步和互斥问题；了解进程的同步和互斥的基本概念。  1.1 并发的需求 程序设计上，要利用操作系统对于并发的支持（进程&#x2F;线程），安排可并行事务并发执行 操作系统的核心程序也要尽可能并发的执行  1.2 并发编程123456789101112@startumlstart">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lazybearlee.github.io/img/header.jpeg">
<meta property="article:published_time" content="2024-06-23T12:24:35.000Z">
<meta property="article:modified_time" content="2024-06-25T04:58:38.192Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lazybearlee.github.io/img/header.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lazybearlee.github.io/2024/06/23/note2-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统笔记2——进程并发、同步与互斥',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-25 12:58:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Leeee's Blog"><span class="site-name">Leeee's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统笔记2——进程并发、同步与互斥</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-23T12:24:35.000Z" title="发表于 2024-06-23 20:24:35">2024-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-25T04:58:38.192Z" title="更新于 2024-06-25 12:58:38">2024-06-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/">OS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/OS/Note/">Note</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统笔记2——进程并发、同步与互斥"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进程并发、同步与互斥"><a href="#进程并发、同步与互斥" class="headerlink" title="进程并发、同步与互斥"></a>进程并发、同步与互斥</h1><h2 id="1-进程并发执行的问题"><a href="#1-进程并发执行的问题" class="headerlink" title="1. 进程并发执行的问题"></a>1. 进程并发执行的问题</h2><blockquote>
<p>在本部分，要了解可并行程序的高级语言表示和操作系统的支持；了解并发执行引起的同步和互斥问题；了解进程的同步和互斥的基本概念。</p>
</blockquote>
<h3 id="1-1-并发的需求"><a href="#1-1-并发的需求" class="headerlink" title="1.1 并发的需求"></a>1.1 并发的需求</h3><ul>
<li>程序设计上，要利用操作系统对于并发的支持（进程&#x2F;线程），安排可并行事务并发执行</li>
<li>操作系统的核心程序也要尽可能并发的执行</li>
</ul>
<h3 id="1-2-并发编程"><a href="#1-2-并发编程" class="headerlink" title="1.2 并发编程"></a>1.2 并发编程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">start</span><br><span class="line">fork</span><br><span class="line">  :Task1;</span><br><span class="line">fork again</span><br><span class="line">  :Task2;</span><br><span class="line">fork again</span><br><span class="line">  :Task3;</span><br><span class="line">end fork</span><br><span class="line">:Task4;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="/images/note2-2-1719152050658.png" alt="图 0">  </p>
<ul>
<li><p>三种并发编程的方法</p>
<ul>
<li>程序员写顺序程序，用自动识别工具识别可并行成分，组织使用操作系统的进程或线程实现并发。</li>
<li>由程序员识别可并行成分，用并发程序设计语言设计并发程序，由编译系统安排使用进程或线程；</li>
<li>在传统语言基础上，利用操作系统的进程或线程系统调用设计并发程序。</li>
</ul>
</li>
</ul>
<h3 id="1-3-并发设计语言"><a href="#1-3-并发设计语言" class="headerlink" title="1.3 并发设计语言"></a>1.3 并发设计语言</h3><h4 id="并发语句"><a href="#并发语句" class="headerlink" title="并发语句"></a>并发语句</h4><p>语法形式：<br>    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    S1; S2; ...; Sn</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure></p>
<p>在上面的语法中，S1; S2; …; Sn 是并发执行的语句序列，Parbegin 和 Parend 是并发执行的开始和结束标志。</p>
<p>例如，下面的程序段中的语句 S1 和 S2 是并发执行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    S1;</span><br><span class="line">    S2;</span><br><span class="line">Parend</span><br><span class="line">S3;</span><br></pre></td></tr></table></figure>

<p>但是，仍然存在着用Parbegin&#x2F;Parend语句无法描述的并发优先关系。</p>
<p><img src="/images/note2-2-1719152276700.png" alt="图 1">  </p>
<p>而对于这样的并发优先关系，就有必要引入其他的并发控制语句，如：并发信号量机制。</p>
<h3 id="1-4-并发执行实现"><a href="#1-4-并发执行实现" class="headerlink" title="1.4 并发执行实现"></a>1.4 并发执行实现</h3><ul>
<li>实现并发执行，需要通过操作系统支持的<strong>进程</strong>或<strong>线程</strong>机制来实现。</li>
<li>操作系统提供进程（线程）<strong>创建</strong>、<strong>结束</strong>、<strong>同步</strong>的系统调用，可直接提供给用户编写并行程序；或由并行语言编译器将并发语言的语句转化为对操作系统的系统调用。</li>
</ul>
<p>例如，Linux提供了<code>fork()</code>和<code>exec()</code>等系统调用，可以用于创建进程和执行程序。</p>
<ul>
<li><code>fork()</code>：创建一个新进程。该系统调用执行完成后，系统已创建了一个子进程，该子进程逻辑复制（共享）了父进程的程序，复制了父进程的数据段和栈段。也就是说不管是父进程还是子进程，在占有处理机后，都从系统调用的返回点开始运行，父进程系统调用的返回值是子进程的进程标识<code>pid</code>；子进程的返回值是<code>0</code>，子进程从<code>trap</code>指令后一条指令开始运行。<br>  <img src="/images/note2-2-1719152517272.png" alt="图 2">  </li>
<li><code>exec()</code>：执行一个程序。该系统调用执行完成后，系统已经用新的程序替换了当前进程的程序，新程序的代码段、数据段和栈段都已经加载到内存中，当前进程的程序已经被新程序替换，新程序从<code>trap</code>指令后一条指令开始运行。</li>
<li><code>exit(status)</code>：结束一个进程。该系统调用执行完成后，系统已经结束了当前进程，进程的资源已经被释放，进程的状态已经被设置为<code>ZOMBIE</code>状态，进程的退出状态为<code>status</code>。然后，操作系统会将进程的退出状态传递给父进程，父进程可以通过<code>wait()</code>系统调用来获取子进程的退出状态。</li>
<li><code>wait(&amp;status)</code>：等待一个进程结束。该系统调用执行完成后，系统已经等待了一个子进程结束，当子进程结束后，系统会将子进程的退出状态传递给父进程，父进程可以通过<code>status</code>参数来获取子进程的退出状态。</li>
<li><code>waitpid(pid, &amp;status, options)</code>：等待一个指定的进程结束。该系统调用执行完成后，系统已经等待了一个指定的子进程结束，当指定的子进程结束后，系统会将子进程的退出状态传递给父进程，父进程可以通过<code>status</code>参数来获取子进程的退出状态。</li>
</ul>
<p>如下是使用Linux原语实现的一个简单的并发程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    S2;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    S1;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    S3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-进程同步与互斥"><a href="#1-5-进程同步与互斥" class="headerlink" title="1.5 进程同步与互斥"></a>1.5 进程同步与互斥</h3><ul>
<li>进程同步：多个进程之间的协调，以便使进程按照一定的顺序执行。同步关系是指完成同一任务的伙伴进程间，因需要在某些位置上协调它们的工作而等待、传递信息所产生的制约关系，亦称<strong>直接制约关系</strong>。</li>
<li>进程互斥：多个进程之间的互斥关系，以便使进程之间不会相互干扰。互斥关系是指进程间因相互竞争使用<strong>独占型资源</strong>（互斥资源）所产生的制约关系,亦称<strong>间接制约关系</strong>。</li>
</ul>
<h3 id="1-6-同步-互斥与临界段问题"><a href="#1-6-同步-互斥与临界段问题" class="headerlink" title="1.6 同步&#x2F;互斥与临界段问题"></a>1.6 同步&#x2F;互斥与临界段问题</h3><h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><ul>
<li>例：如果一个进程P1执行S1，S3，进程P2执行S2，则P1在执行S3之前必须等待P2执行完S2。<ul>
<li><img src="/images/note2-2-1719152818483.png" alt="图 3"></li>
</ul>
</li>
</ul>
<h4 id="互斥问题（独占型资源）"><a href="#互斥问题（独占型资源）" class="headerlink" title="互斥问题（独占型资源）"></a>互斥问题（独占型资源）</h4><ul>
<li>例：P1、P2两进程使用同一打印机，如果不互斥使用会交叉输出。</li>
</ul>
<h4 id="互斥问题（共享数据）"><a href="#互斥问题（共享数据）" class="headerlink" title="互斥问题（共享数据）"></a>互斥问题（共享数据）</h4><ul>
<li>例：P1、P2两进程对共享变量X进行操作，如果不互斥使用会导致数据不一致。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">   <span class="title function_">A</span><span class="params">(amount)</span>&#123;</span><br><span class="line">    R1=balance;</span><br><span class="line">    R2=amount;</span><br><span class="line">    R1=R1+R2;</span><br><span class="line">    balance=R1;</span><br><span class="line">    &#125;;</span><br><span class="line">   B(amount) &#123;</span><br><span class="line">    R1=balance;</span><br><span class="line">    R2=amount;</span><br><span class="line">    R1=R1-R2;</span><br><span class="line">    balance=R1;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>在上面这段程序中，我们是要求两个进程A和B对共享变量<code>balance</code>进行操作的时候应该是互斥的，否则会导致数据不一致。</p>
<h4 id="有限缓冲区的生产者-消费者问题（生产者和消费者共享一个产品缓冲链）"><a href="#有限缓冲区的生产者-消费者问题（生产者和消费者共享一个产品缓冲链）" class="headerlink" title="有限缓冲区的生产者&#x2F;消费者问题（生产者和消费者共享一个产品缓冲链）"></a>有限缓冲区的生产者&#x2F;消费者问题（生产者和消费者共享一个产品缓冲链）</h4><p><img src="/images/note2-2-1719152998209.png" alt="图 4">  </p>
<ul>
<li>生产者进程：生产者进程是一个周期性进程，它的任务是生产产品并将产品放入缓冲区。</li>
<li>消费者进程：消费者进程是一个周期性进程，它的任务是从缓冲区中取出产品并消费产品。</li>
<li>缓冲区：缓冲区是一个有限的产品链，生产者和消费者共享这个产品链。</li>
</ul>
<p>数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; item;   <span class="comment">// 消息类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span> <span class="title">inst</span>;</span><span class="comment">//产品</span></span><br><span class="line">&#125; buffer;   <span class="comment">// 缓冲类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">P</span>, *<span class="title">C</span>, *<span class="title">First</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> <span class="title">nextp</span>, <span class="title">nextc</span>;</span></span><br><span class="line">First = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>对于如上的数据结构，我们可以定义如下的生产者和消费者的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">Producer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            produce(nextp);<span class="comment">//生产产品</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            new(P); <span class="comment">// 申请一个新的缓冲区</span></span><br><span class="line">            P-&gt;inst = nextp;</span><br><span class="line">            P-&gt;next = First;</span><br><span class="line">            First = P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Consumer() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (First != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果为空，那么就循环等待</span></span><br><span class="line">                C = First;</span><br><span class="line">                first = first-&gt;next;</span><br><span class="line">                nextc = C-&gt;inst;</span><br><span class="line">                dispose(C);<span class="comment">//释放缓冲区</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                consume(nextc);<span class="comment">//消费产品</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>对于如下一个序列，会导致生产者加入的产品丢失：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T0: consumer C=First;</span><br><span class="line">T1: producer P.next=First; First=P;</span><br><span class="line">T2: consumer first=fist-&gt;next;</span><br></pre></td></tr></table></figure>

<p>在上面这段代码中，我们可以看到，如果在T0时刻，消费者C取出了First，然后在T1时刻，生产者P将First指向了新的缓冲区，那么在T2时刻，消费者first指向了First的下一个缓冲区，那么First就丢失了。</p>
<h3 id="1-7-临界段问题"><a href="#1-7-临界段问题" class="headerlink" title="1.7 临界段问题"></a>1.7 临界段问题</h3><ul>
<li>临界段（Critical Section）：指的是一段程序片段，这段程序片段中的代码是对共享资源进行访问的代码，这段代码是一个临界资源，多个进程同时访问这段代码会导致数据不一致。这一段代码要求各进程必须互斥地访问，即同一时刻只能有一个进程访问这段代码。</li>
<li>临界资源（Critical Resource）：指的是一种共享资源，多个进程需要访问这个资源，但是这个资源只能被一个进程访问，否则会导致数据不一致。</li>
</ul>
<h2 id="2-进程同步与互斥实现方法"><a href="#2-进程同步与互斥实现方法" class="headerlink" title="2. 进程同步与互斥实现方法"></a>2. 进程同步与互斥实现方法</h2><blockquote>
<p>在本部分，了解解决互斥问题的软件算法;理解互斥问题的硬件实现方法；掌握信号量机制及使用它解决进程同步互斥问题的方法。 </p>
</blockquote>
<h3 id="2-1-并发进程进入临界区需要遵循的四个准则"><a href="#2-1-并发进程进入临界区需要遵循的四个准则" class="headerlink" title="2.1 并发进程进入临界区需要遵循的四个准则"></a>2.1 并发进程进入临界区需要遵循的四个准则</h3><ul>
<li><strong>互斥使用</strong>：在任一时刻，只允许一个进程进入临界区执行；</li>
<li><strong>让权等待</strong>：等待进入临界区的进程，应释放处理机后阻塞等待；</li>
<li><strong>有空让进</strong>：在临界区外运行的进程不可阻止其他进程进入临界区；</li>
<li><strong>有限等待</strong>：进程进入临界区的等待时间应有限，不应该使要进入临界区的进程无限等待。</li>
</ul>
<p><img src="/images/note2-2-1719154478754.png" alt="图 5">  </p>
<h3 id="2-2-解决进程之间互斥的方法"><a href="#2-2-解决进程之间互斥的方法" class="headerlink" title="2.2 解决进程之间互斥的方法"></a>2.2 解决进程之间互斥的方法</h3><h4 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h4><h5 id="实现互斥的软件算法"><a href="#实现互斥的软件算法" class="headerlink" title="实现互斥的软件算法"></a>实现互斥的软件算法</h5><ul>
<li>进入临界段之前要<strong>申请</strong>，获得批准方可进入；</li>
<li>退出临界段之后要<strong>声明</strong>，以便其他进程进入。</li>
</ul>
<p>算法应该满足以下几个条件：</p>
<ul>
<li><strong>准则1：</strong>不能虚设硬件指令或假设处理机数目。</li>
<li><strong>准则2：</strong>不能假设n个进程的相对速度。</li>
<li><strong>准则3：</strong>当一个进程未处于其临界段时，不应阻止其它进程进入临界段。</li>
<li><strong>准则4：</strong>当若干进程欲进入临界段时，应能在有限时间内选出一个进程进入其临界段。</li>
</ul>
<p>协调各进程入临界段的调度原则：</p>
<ul>
<li>当<strong>无进程</strong>处于临界段时，允许一个进程立即<strong>进入</strong>临界段。</li>
<li>当<strong>已有进程</strong>进入临界段时， 其它试图进入的进程必须<strong>等待</strong>。</li>
<li>当某进程<strong>退出临界段</strong>时，若有等待进入临界段的进程，则应选取一个进入临界段。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">    &#123;</span><br><span class="line">    Entry Section</span><br><span class="line">    Critical Section</span><br><span class="line">    Exit Section</span><br><span class="line">    Remainder Section</span><br><span class="line">    &#125;</span><br><span class="line">until <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Dekker算法"><a href="#Dekker算法" class="headerlink" title="Dekker算法"></a>Dekker算法</h5><ul>
<li>Dekker算法首先有一个初步构想：定义全局变量turn，值0、1分别标志进程P0和P1可以进入CS：</li>
</ul>
<p><img src="/images/note2-2-1719154869681.png" alt="图 6">  </p>
<p>而以上过程可能会导致某个进程一直在等待，也叫<strong>忙等待（busy waiting）</strong>。</p>
<p>而以上过程也违背了准则4，即<strong>有限等待</strong>。</p>
<p>同时，即使临界区此时为空，由于turn的值为1，P0也无法进入临界区。这违反了准则3——<strong>有空让进</strong>。</p>
<p>因此，引出了第一个改进：使用全局共享数组flag，flag[0]和flag[1]分别标志进程P0和P1是否占用临界区，如果数组中的值全部为0&#x2F;false，那么临界区为空。</p>
<p>有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>但是，这个算法仍然存在问题，即<strong>忙等待</strong>。会发现，如果某个进程在临界区内失败且对应的flag为true，那么其他进程会一直在忙等待。</p>
<p>因此，引出了第二个改进：使用一个标志位，哪个进程需要使用临界区，谁就要举手声明。</p>
<p>有下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 举手声明</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 举手声明</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>但是，上面的算法依然不能实现<strong>有空让进</strong>，即如果某个进程在临界区内失败或者两个进程同时举手声明，那么其他进程会一直在忙等待，而这两个进程也会一直在忙等待。</p>
<p>因此，引出了第三个改进：</p>
<ul>
<li>为两个进程Pi和Pj分别设置布尔变量，即boolean flag[2]，其初值为flag[i] &#x3D; flag[j]&#x3D; false ，若flag[i]&#x3D;&#x3D;true，则表示进程 Pi要求进入临界区 </li>
<li>为两个进程Pi和Pj设置共享整型变量turn指示应该由哪个进程进入临界区。turn&#x3D;&#x3D;i时，表示允许进程Pi进入临界区，反之允许进程Pj进入临界区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 举手声明</span></span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (turn == <span class="number">1</span>) &#123; <span class="comment">// 如果是P1的轮次，那么就等待</span></span><br><span class="line">                    flag[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 举手放弃</span></span><br><span class="line">                    <span class="keyword">while</span> (turn == <span class="number">1</span>) &#123;</span><br><span class="line">                        do_nothing();</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 直到P1放弃轮次，才能再次举手</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            turn = <span class="number">1</span>;<span class="comment">// 轮到P1</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (turn == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (turn == <span class="number">0</span>) &#123;</span><br><span class="line">                        do_nothing();</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>上面的算法类似于令牌的传递，即只有拿到令牌的进程才能进入临界区。</p>
<h5 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h5><p>Peterson算法是Dekker算法的改进，Peterson算法的基本思想是：在进入临界区之前，进程必须先申请进入临界区，然后等待对方放弃进入临界区的权利。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn;</span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            turn = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            turn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>) &#123;</span><br><span class="line">                do_nothing();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 临界区</span></span><br><span class="line">            flag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 余下区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>在上面的Peterson算法中，<code>flag[0] = 1; turn = 1;</code>这一步是实现两个进程间互斥访问临界区的关键。</p>
<ul>
<li><p><code>flag[0] = 1;</code> 表示进程P0想要进入临界区。<code>flag</code>数组用于标记每个进程是否有意进入临界区，其中<code>flag[0]</code>对应进程P0，<code>flag[1]</code>对应进程P1。</p>
</li>
<li><p><code>turn = 1;</code> 表示当两个进程都想进入临界区时，优先权给进程P1。<code>turn</code>变量用于解决两个进程都想进入临界区时的冲突，通过轮流给予每个进程优先权。</p>
</li>
</ul>
<p>这两步操作共同实现了以下目的：</p>
<ol>
<li><p><strong>表达意图</strong>：通过设置<code>flag[0] = 1</code>，进程P0表明它想要进入临界区。这是告知系统及其他进程其意图的方式。</p>
</li>
<li><p><strong>决定优先权</strong>：通过设置<code>turn = 1</code>，算法在两个进程都想进入临界区时提供了一种决策机制。这里，将优先权给了另一个进程（P1），这是一种礼让机制，确保了公平性。</p>
</li>
</ol>
<p>接下来的<code>while (flag[1] &amp;&amp; turn == 1)</code>循环是检查条件，确保当另一个进程（P1）也想进入临界区且当前的优先权不在自己（P0）时，进程P0会等待。这样，只有当另一个进程不想进入临界区（<code>flag[1] == 0</code>）或者优先权转回自己（<code>turn != 1</code>）时，进程P0才会进入临界区。</p>
<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>主要是利用处理机提供的特殊指令来实现临界区加锁。</p>
<h5 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h5><p>例如存取balance：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">(amount)</span> &#123;</span><br><span class="line">        disable_interrupt();</span><br><span class="line">        R1 = balance;</span><br><span class="line">        R2 = amount;</span><br><span class="line">        R1 = R1 + R2;</span><br><span class="line">        balance = R1;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">    &#125;;</span><br><span class="line">    B(amount) &#123;</span><br><span class="line">        disable_interrupt();</span><br><span class="line">        R1 = balance;</span><br><span class="line">        R2 = amount;</span><br><span class="line">        R1 = R1 - R2;</span><br><span class="line">        balance = R1;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">    &#125;;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<p>上面的程序非常简单，但是限制了处理机交叉执行的能力，并且把禁止中断的<strong>权力交给用户进程</strong>是不明智的，同时若是<strong>多处理机系统</strong>，则禁止中断<strong>仅仅对执行本指令的那个CPU有效</strong>。其他CPU仍将继续运行，并可以访问临界资源。</p>
<h5 id="“Test-and-Set”指令"><a href="#“Test-and-Set”指令" class="headerlink" title="“Test_and_Set”指令"></a>“Test_and_Set”指令</h5><ul>
<li>“Test_and_Set”指令是一个原子操作，它可以在一个操作中读取一个存储器单元的值，并将该单元的值设置为一个新值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">Test_and_Set</span><span class="params">(boolean *lock)</span> &#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如下是一个使用”Test_and_Set”指令的互斥算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (Test_and_Set(&amp;lock)) &#123;</span><br><span class="line">            do_nothing();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        lock = <span class="literal">false</span>;<span class="comment">//释放锁</span></span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="“Swap”指令"><a href="#“Swap”指令" class="headerlink" title="“Swap”指令"></a>“Swap”指令</h5><ul>
<li>“Swap”指令是一个原子操作，它可以在一个操作中交换两个存储器单元的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">Swap</span><span class="params">(boolean *a, boolean *b)</span> &#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，上面的函数也可以采用引用方式描述。</p>
<p>而如下是一个使用”Swap”指令的互斥算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">P0() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (key) &#123;</span><br><span class="line">            Swap(&amp;lock, &amp;key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        lock = <span class="literal">false</span>;<span class="comment">//释放锁</span></span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的使用中，一开始<code>lock</code>为<code>false</code>，<code>key</code>为<code>true</code>，那么<code>Swap(&amp;lock, &amp;key);</code>会将<code>lock</code>设置为<code>true</code>，<code>key</code>设置为<code>false</code>，那么<code>while (key)</code>就会退出循环，进入临界区。而如果<code>lock</code>为<code>true</code>，那么<code>Swap(&amp;lock, &amp;key);</code>会将<code>lock</code>设置为<code>false</code>，<code>key</code>设置为<code>true</code>，那么<code>while (key)</code>就会继续循环，等待<code>lock</code>为<code>false</code>。</p>
<h3 id="2-3-信号量-Semaphore-和PV操作"><a href="#2-3-信号量-Semaphore-和PV操作" class="headerlink" title="2.3 信号量(Semaphore)和PV操作"></a>2.3 信号量(Semaphore)和PV操作</h3><ul>
<li><strong>信号量</strong>：1965年由荷兰计算机科学家Dijkstra提出的一种用于进程间通信和同步的机制。信号量是一个整型变量，可以对其进行两种操作：增加和减少。信号量的值大于等于0时，表示可用资源的数目；小于0时，表示等待使用资源的进程数目。也就是说，每个信号量与一个资源相关联，信号量的值就是资源的数目。同时，其值只能通过初始化、P操作和V操作来访问。</li>
<li>信号量的类型：<ul>
<li>公用信号量：用于进程间的互斥，<strong>初始值为1</strong>；</li>
<li>私用信号量：用于进程间的同步，<strong>初始值为0或n</strong>。</li>
</ul>
</li>
</ul>
<h4 id="信号量机制实现"><a href="#信号量机制实现" class="headerlink" title="信号量机制实现"></a>信号量机制实现</h4><ul>
<li><p>假设信号量S为一个整型变量，可以对其进行两种操作：增加和减少。</p>
</li>
<li><p><strong>P操作</strong>：如果S的值大于0，则将S减1。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        do_nothing();</span><br><span class="line">    &#125;</span><br><span class="line">    S=S<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>V操作</strong>：将S的值加1。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V(S) &#123;</span><br><span class="line">    S=S+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在上面的程序中，P、V操作是两条原语，P、V操作对变量S的访问是互斥的。</p>
<h4 id="原语的概念与实现"><a href="#原语的概念与实现" class="headerlink" title="原语的概念与实现"></a>原语的概念与实现</h4><ul>
<li><strong>原语</strong>：指完成某种功能且不被分割或不被逻辑上中断执行的操作序列。原语可通过<strong>硬件</strong>实现不可中断性；或通过<strong>实现临界段的元方法</strong>达到不被逻辑上中断。</li>
<li>实现临界段的元方法：屏蔽中断&#x2F;加硬锁。</li>
</ul>
<h5 id="屏蔽中断实现的原语"><a href="#屏蔽中断实现的原语" class="headerlink" title="屏蔽中断实现的原语"></a>屏蔽中断实现的原语</h5><ul>
<li><strong>屏蔽中断</strong>：在进入临界区之前，关闭中断；在退出临界区之后，开启中断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">P(S) &#123;</span><br><span class="line">    disable_interrupt();</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        enable_interrupt();</span><br><span class="line">        disable_interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    S=S<span class="number">-1</span>;</span><br><span class="line">    enable_interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是一个实现信号量P操作（等待操作）的例子，其中涉及到中断的禁用和启用。在<code>while (S &lt;= 0)</code>循环中，重新打开中断（<code>enable_interrupt();</code>）再关闭中断（<code>disable_interrupt();</code>）的原因主要是为了避免死锁和提高系统的响应性。</p>
<ol>
<li><p><strong>避免死锁</strong>：当<code>S &lt;= 0</code>时，表示没有可用资源，当前进程需要等待。如果在等待期间一直禁用中断，那么系统将无法响应任何中断，包括那些可能释放资源（使<code>S</code>变为正值）的中断。这样会导致死锁，因为当前进程在等待资源变为可用状态，而系统又无法处理那些可能释放资源的操作。</p>
</li>
<li><p><strong>提高系统响应性</strong>：通过在等待循环中临时重新启用中断，系统可以处理其他中断请求，这样可以保证系统对其他重要事件的响应不会被当前等待操作阻塞。一旦处理完中断，再次禁用中断并检查条件，这样既保证了对资源访问的互斥性，又提高了系统的整体响应性和效率。</p>
</li>
</ol>
<p>简而言之，这种在等待循环中临时启用中断的做法是一种权衡，它旨在避免在等待资源时造成系统响应的完全阻塞，同时又能在资源变为可用时及时恢复执行。这种方法在实际操作系统和并发编程中是一种常见的实践，用于处理资源等待和中断响应之间的平衡。</p>
<h5 id="加硬锁实现的原语"><a href="#加硬锁实现的原语" class="headerlink" title="加硬锁实现的原语"></a>加硬锁实现的原语</h5><p>使用硬件锁实现原语的方法通常依赖于硬件提供的特定指令或机制，这些指令或机制能够原子地测试并设置锁变量，从而实现互斥。一个常见的硬件锁实现是使用“测试并设置”（Test-and-Set）指令或“比较并交换”（Compare-and-Swap，CAS）指令。</p>
<ol>
<li><p><strong>定义锁变量</strong>：首先，定义一个锁变量，通常是一个整型或布尔型变量，用于表示锁的状态（加锁或未加锁）。</p>
</li>
<li><p><strong>加锁（Lock）操作</strong>：</p>
<ul>
<li>使用CAS指令原子地检查锁变量的值。</li>
<li>如果锁变量为0（未加锁状态），则将其设置为1（加锁状态），并进入临界区。</li>
<li>如果锁变量已经为1（加锁状态），则循环等待，直到锁变量变为0。</li>
</ul>
</li>
<li><p><strong>解锁（Unlock）操作</strong>：</p>
<ul>
<li>完成临界区的操作后，将锁变量设置回0，表示锁已释放。</li>
</ul>
</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设lock是一个共享变量，初始化为0（未加锁状态）</span></span><br><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!compare_and_swap(&amp;lock, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 循环等待，直到成功将lock从0改为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    lock = <span class="number">0</span>; <span class="comment">// 直接将lock设置为0，释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是不需要禁用中断，因此可以在多核处理器环境中使用，而且避免了因禁用中断导致的系统响应性问题。然而，它可能导致忙等（busy waiting），特别是在锁竞争激烈的情况下，这会浪费CPU资源。为了缓解这个问题，可以引入退避（backoff）策略或使用更高级的同步机制，如队列锁。</p>
<h4 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h4><ul>
<li><p><strong>互斥</strong>：信号量S的初值为1，表示资源可用，进程P执行P(S)操作，进入临界区后执行V(S)操作，释放资源。一般而言这个信号量也被命名为 <strong>mutex</strong> 。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutex = <span class="number">1</span>;</span><br><span class="line">Process <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步</strong>：信号量S的初值为0，表示资源不可用，进程P执行P(S)操作，等待资源可用，进程Q执行V(S)操作，释放资源。这个信号量也常被命名为 <strong>synch</strong> 。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">synch = <span class="number">0</span>;</span><br><span class="line">Parbegin</span><br><span class="line">    Process <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        V(synch);</span><br><span class="line">    &#125;</span><br><span class="line">    Process <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">        P(synch);</span><br><span class="line">        <span class="comment">// 余下区</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  那么，在上面的情况下，P0进程中的临界区会在P1进程中的余下区之前执行。</p>
</li>
</ul>
<h5 id="信号量机制的应用举例"><a href="#信号量机制的应用举例" class="headerlink" title="信号量机制的应用举例"></a>信号量机制的应用举例</h5><p><img src="/images/note2-2-1719211390686.png" alt="图 7">  </p>
<p>在如上的图中，语句S1在S2和S3之前执行，而S2和S3是并发执行的，S4在S2后执行，S5在S4后执行，S6在S3和S4之后执行，S7在S5和S6之后执行。我们可以设置如下的信号量机制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s1 = <span class="number">1</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>, s4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">P0</span><span class="params">()</span> &#123;</span><br><span class="line">        P(s1);</span><br><span class="line">        S1;</span><br><span class="line">        V(s2);</span><br><span class="line">        S2;</span><br><span class="line">        S4;</span><br><span class="line">        V(s3);</span><br><span class="line">        S5;</span><br><span class="line">        V(s4);</span><br><span class="line">    &#125;</span><br><span class="line">    P1() &#123;</span><br><span class="line">        P(s2);</span><br><span class="line">        S3;</span><br><span class="line">        P(s3);</span><br><span class="line">        s6;</span><br><span class="line">        P(s4);</span><br><span class="line">        S7;</span><br><span class="line">    &#125;</span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<h5 id="消除忙等待的信号量机制"><a href="#消除忙等待的信号量机制" class="headerlink" title="消除忙等待的信号量机制"></a>消除忙等待的信号量机制</h5><ul>
<li><strong>忙等待</strong>：在等待资源时，进程不断循环检查资源是否可用，这种方式会浪费CPU资源。我们需要在使用信号量机制的同时，与进程调度机制结合，避免忙等待。</li>
<li><strong>原则</strong>：在P操作循环等待的地方加入<strong>放弃处理机&#x2F;挂入等待队列</strong>动作，在V操作时，从等待队列中摘取进程变为就绪态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进后的信号量声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 信号量值，代表资源可用数目</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 等待队列，存放等待进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(semaphore *s)</span> &#123;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        保存现场;</span><br><span class="line">        将本进程挂入s-&gt;<span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(semaphore *s)</span> &#123;</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        从s-&gt;<span class="built_in">list</span>中取出一个进程;</span><br><span class="line">        将该进程放入就绪队列;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用两个线程实现共享数组的data-1000-累加"><a href="#用两个线程实现共享数组的data-1000-累加" class="headerlink" title="用两个线程实现共享数组的data[1000]累加"></a>用两个线程实现共享数组的data[1000]累加</h5><ul>
<li>采用互斥量实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 也可以仅是一个整型变量</span></span><br><span class="line"></span><br><span class="line">Thread1() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 首先获取互斥量，保证只有一个线程能够访问data数组</span></span><br><span class="line">        P(mutex);<span class="comment">//实际这里应该是&amp;mutex</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            sum += data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果i&gt;=1000，说明data数组已经遍历完，释放互斥量并退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread1 sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread2() &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 首先获取互斥量，保证只有一个线程能够访问data数组</span></span><br><span class="line">        P(mutex);<span class="comment">//实际这里应该是&amp;mutex</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            sum += data[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果i&gt;=1000，说明data数组已经遍历完，释放互斥量并退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread2 sum = %d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>采用同步机制计算data[1000]的和：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;<span class="comment">//两个线程的累加和</span></span><br><span class="line">semaphore synch = <span class="number">0</span>;<span class="comment">//信号量，也可以是一个整型变量</span></span><br><span class="line"></span><br><span class="line">Thread1() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">        sum1 += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    P(synch);</span><br><span class="line">    sum1 += sum2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread1 sum = %d\n&quot;</span>, sum1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread2() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">500</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        sum2 += data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    V(synch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-进程同步与互斥举例"><a href="#3-进程同步与互斥举例" class="headerlink" title="3. 进程同步与互斥举例"></a>3. 进程同步与互斥举例</h2><blockquote>
<p>在本部分，通过实例了解进程同步与互斥的应用。</p>
</blockquote>
<h3 id="3-1-生产者-消费者问题（有限缓冲区）"><a href="#3-1-生产者-消费者问题（有限缓冲区）" class="headerlink" title="3.1 生产者&#x2F;消费者问题（有限缓冲区）"></a>3.1 生产者&#x2F;消费者问题（有限缓冲区）</h3><ul>
<li>问题描述：设有n个缓冲区，一组生产者进程往缓冲区写数据，一组消费者进程从缓冲区取数据，写、取以一个缓冲区为单位。</li>
<li><strong>生产者</strong>：生产者进程是一个周期性进程，它的任务是生产产品并将产品放入缓冲区。</li>
<li><strong>消费者</strong>：消费者进程是一个周期性进程，它的任务是从缓冲区中取出产品并消费产品。</li>
<li><strong>说明</strong>：<ul>
<li>将缓冲区看作共享数据，对缓冲区的访问应该是互斥的。</li>
<li>如果缓冲区全满，生产者进程应该等待，直到有空缓冲区。</li>
<li>如果缓冲区为空，消费者进程应该等待，直到有产品可取。</li>
</ul>
</li>
</ul>
<p><img src="/images/note2-2-1719212407468.png" alt="图 10">  </p>
<ul>
<li><strong>数据结构</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; item;   <span class="comment">// 消息类型</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex: 互斥量，用于对缓冲区的访问进行互斥</span></span><br><span class="line"><span class="comment"> * empty: 信号量，表示空缓冲区的数目</span></span><br><span class="line"><span class="comment"> * full: 信号量，表示满缓冲区的数目</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 下一个生产者和消费者的产品</span></span><br><span class="line">item nextp, nextc;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Producer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        produce(nextp);<span class="comment">//生产产品</span></span><br><span class="line">        P(empty);<span class="comment">//等待空缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        get_empty_buffer();</span><br><span class="line">        buffer-&gt;inst = nextp;<span class="comment">//将产品放入缓冲区</span></span><br><span class="line">        add_to_full_buffer_queue(buffer);</span><br><span class="line">        V(mutex);<span class="comment">//退出临界区</span></span><br><span class="line">        V(full);<span class="comment">//增加满缓冲区数目</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的P(empty)操作中，如果empty的值小于等于0，那么生产者就会等待，直到有空缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (empty &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    do_nothing();</span><br><span class="line">&#125;</span><br><span class="line">empty--;<span class="comment">//empty = empty - 1;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(full);<span class="comment">//等待满缓冲区，消耗一个缓冲区</span></span><br><span class="line">        P(mutex);<span class="comment">//进入临界区</span></span><br><span class="line">        <span class="comment">// 从缓冲区取出产品</span></span><br><span class="line">        buffer = get_full_buffer();</span><br><span class="line">        nextc = buffer-&gt;inst;</span><br><span class="line">        dispose(buffer);<span class="comment">//释放缓冲区</span></span><br><span class="line">        V(mutex);<span class="comment">//退出临界区</span></span><br><span class="line">        V(empty);<span class="comment">//增加空缓冲区数目</span></span><br><span class="line">        consume(nextc);<span class="comment">//消费产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上的生成者和消费者代码，其中的<code>full</code>和<code>empty</code>的P和V操作是不能省略的，同时这些操作的位置也是有严格要求的，不能随意替换位置。</p>
<ol>
<li><p><strong>为什么不能省略</strong>：</p>
<ul>
<li><code>empty</code>信号量用于表示空缓冲区的数量。生产者在生产新产品之前需要确保有空缓冲区可用，这是通过P(empty)操作来保证的。如果省略这一步，生产者可能会在没有空缓冲区的情况下尝试生产产品，导致数据覆盖或其他错误。</li>
<li><code>full</code>信号量用于表示满缓冲区的数量。消费者在消费产品之前需要确保有产品可消费，这是通过P(full)操作来保证的。如果省略这一步，消费者可能会在缓冲区为空的情况下尝试消费产品，导致错误。</li>
</ul>
</li>
<li><p><strong>为什么操作的位置不能替换</strong>：</p>
<ul>
<li>**P(empty)<strong>操作必须在</strong>P(mutex)**之前。这是因为生产者需要先确保有空缓冲区可用，然后再进入临界区放置产品。如果先进入临界区，可能会导致所有生产者都在临界区内等待空缓冲区，而没有生产者能够释放临界区，从而造成死锁。</li>
<li>同样，**P(full)<strong>操作必须在</strong>P(mutex)**之前。消费者需要先确保有产品可消费，然后再进入临界区取出产品。如果先进入临界区，可能会导致所有消费者都在临界区内等待产品，而没有消费者能够释放临界区，从而造成死锁。</li>
<li>**V(mutex)<strong>操作须在</strong>V(full)或V(empty)**之后。这是因为生产者或消费者完成操作后，需要先退出临界区，释放对缓冲区的互斥访问权，然后再通过V操作增加满或空缓冲区的数量，这样可以让其他等待的生产者或消费者得到通知并开始执行。这样可以减少其他进程等待的时间，提高系统的效率。</li>
</ul>
</li>
</ol>
<p>总之，<code>full</code>和<code>empty</code>的P和V操作是实现生产者和消费者问题同步机制的关键部分，不能省略；同时，这些操作的顺序设计是为了避免死锁和确保系统的正确性，因此也不能随意更改位置。</p>
<h3 id="3-2-读者-写者问题"><a href="#3-2-读者-写者问题" class="headerlink" title="3.2 读者&#x2F;写者问题"></a>3.2 读者&#x2F;写者问题</h3><ul>
<li>问题描述：存在共享数据A，那些对它进行只读访问进程叫Reader；对它进行了写操作的进程叫Writer。</li>
<li>两类读者写者问题：<ul>
<li><strong>第一类——并发极大化</strong>：读者优先，Reader和Writer争夺访问共享数据A时，如果已经有Reader访问A，后续Reader与后续Writer比有较高优先权。</li>
<li><strong>第二类-数据时效优先</strong>：写者优先，Reader和Writer争夺访问共享数据A时，Writer有较高优先权。</li>
</ul>
</li>
</ul>
<h4 id="第一类读者写者问题"><a href="#第一类读者写者问题" class="headerlink" title="第一类读者写者问题"></a>第一类读者写者问题</h4><ol>
<li>如果当前无进程访问A，则Reader&#x2F; Writer欲访问即可访问。</li>
<li><strong>如果已存在一个Reader正在访问数据，其它欲访问Reader可马上访问（这体现Reader有较高优先权）；而欲访问的Writer必须等待。</strong></li>
<li>若某个Writer正访问数据，则欲访问的Reader&#x2F; Writer都必须等待。</li>
<li><strong>当最后一个结束访问数据的Reader发现有Writer正在等待时，则将其中一个唤醒。</strong></li>
<li>当某个Writer结束访问时，若只有Writer在等待，则唤醒某个Writer，若既有Writer也有Reader；则按FIFO或其它原则唤醒一个Writer或所有Reader。</li>
</ol>
<p>那么对于以上问题描述，我们可以设定一个写的互斥量<code>wrt</code>，一个读的互斥量<code>mutex</code>，一个读者计数器<code>readcount</code>。需要注意的点是，在这里，我们使用了一个mutex来保护读者计数器，防止因为多个读者同时访问而导致计数器的错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>, wrt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex);<span class="comment">// 保护readcount</span></span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>) &#123;</span><br><span class="line">            P(wrt);<span class="comment">// 第一个读者等待写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        read();</span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) &#123;</span><br><span class="line">            V(wrt);<span class="comment">// 最后一个读者唤醒写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        P(wrt);<span class="comment">// 写者等待</span></span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        write();</span><br><span class="line">        V(wrt);<span class="comment">// 写者释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二类读者写者问题"><a href="#第二类读者写者问题" class="headerlink" title="第二类读者写者问题"></a>第二类读者写者问题</h4><p>第二类读者写者问题中，要求保证写者优先，即写者有较高优先权。在这种情况下，如果有写者在等待访问共享数据A，那么后续的读者和写者都必须等待，直到当前的写者完成访问。或者在当前访问结束后，优先唤醒写者。</p>
<p>在读者优先的基础上，增加信号量 r ，初值是 1：当至少有一个写进程准备访问数据区时，用于禁止所有的读进程。同时，我们增加一个记数器，即整型变量 writecount ，记录写者数，初值是 0。为多个写者共享的变量，是临界资源。用互斥信号量 mutex2 控制。</p>
<p>除此之外，我们也需要一个互斥量 mutex3，用于确保在 r 这个信号量上，只有一个读进程在排队等待。</p>
<ul>
<li><strong>数据结构</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>, wrt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex2 = <span class="number">1</span>, mutex3 = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> writecount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Reader() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先获取mutex3，保证只有一个读进程在r信号量上排队等待</span></span><br><span class="line">        P(mutex3);</span><br><span class="line">        <span class="comment">// 然后获取r信号量，如果有写者在等待，那么读者需要等待</span></span><br><span class="line">        P(r);</span><br><span class="line">        <span class="comment">// 获取mutex，保护readcount</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 读者在读进程中，写者不能进入</span></span><br><span class="line">            P(wrt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次释放mutex、r信号量和mutex3</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        V(r);</span><br><span class="line">        V(mutex3);</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        read();</span><br><span class="line">        P(mutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span> (readcount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读完毕，唤醒写者</span></span><br><span class="line">            V(wrt);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>写者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Writer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 首先获取mutex2，保证只有一个写进程在排队等待</span></span><br><span class="line">        P(mutex2);</span><br><span class="line">        writecount++;</span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 请求r信号量，禁止所有的读进程</span></span><br><span class="line">            P(r);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">        <span class="comment">// 写者请求写操作</span></span><br><span class="line">        P(wrt);</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        write();</span><br><span class="line">        V(wrt);</span><br><span class="line">        P(mutex2);</span><br><span class="line">        writecount--;</span><br><span class="line">        <span class="keyword">if</span> (writecount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 最后一个写者唤醒r信号量上的唯一读者</span></span><br><span class="line">            V(r);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的读者-写者问题实现中，通过使用信号量和计数器的方式确保了写者优先。这是通过以下几个关键步骤实现的：</p>
<ol>
<li><p><strong>写者计数器（<code>writecount</code>）</strong>：用于跟踪当前等待写操作的写者数量。当第一个写者到来时，它会通过<code>P(r)</code>操作阻止新的读者开始读取，从而确保写者可以优先进行写操作。而后续，只要还有写者准备写，那么这个r信号量就会一直被占用，从而阻止新的读者开始读取。</p>
</li>
<li><p><strong>读者信号量（<code>r</code>）</strong>：当有写者等待时，通过<code>P(r)</code>操作阻止新的读者开始，这样只要有写者在等待，新的读者就不能开始读取。这确保了一旦有写者准备写入，读者将不会开始新的读操作，从而给予写者优先权。</p>
</li>
<li><p><strong>互斥信号量（<code>mutex2</code>，<code>mutex3</code>，<code>mutex</code>）</strong>：用于保护写者计数器和读者计数器的修改，确保在任何时刻只有一个写者或读者可以修改计数器。mutex3稍微特殊，用于确保在r信号量上只有一个读进程在排队等待。</p>
</li>
</ol>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p>假设系统中有多个读者和写者同时请求访问共享资源。</p>
<ul>
<li><strong>情景一</strong>：当没有写者时，多个读者可以同时访问资源，因为读操作不会相互影响。</li>
<li><strong>情景二</strong>：一旦有一个写者请求写操作，它会增加<code>writecount</code>并通过<code>P(r)</code>操作阻止新的读者开始。这时，即使读者请求访问，也会因为<code>r</code>信号量被占用而等待。</li>
<li><strong>情景三</strong>：当前的读者完成读操作后，不会有新的读者开始，因为<code>r</code>信号量已经被第一个等待的写者占用。这时，写者完成<code>P(mutex2)</code>操作后，会执行<code>P(wrt)</code>进行写操作。在写操作完成之前，所有其他操作都会等待。</li>
<li><strong>情景四</strong>：写操作完成后，如果没有其他写者等待（<code>writecount</code>为0），则通过<code>V(r)</code>操作允许读者开始读操作。如果还有其他写者，那么下一个写者会继续写操作，直到没有写者等待。</li>
</ul>
<p>通过这种方式，一旦有写者准备写入，它会通过阻止新的读者开始并等待当前读者完成来确保写操作可以优先进行，从而实现了写者优先的策略。</p>
<p><strong>上面的 <code>mutex3</code> 主要作用是什么？</strong></p>
<p>我们可以发现，<code>r</code> 是读者和写者都需要获取的信号量，而如果我们仅使用一个 <code>r</code> 来控制写者的优先性，那么会导致在多个读者与一个写者的情况下，写者可能会被多个读者阻塞。因此，我们需要一个额外的互斥量 <code>mutex3</code> 来保证在 <code>r</code> 上只有一个读进程在排队等待，这样可以确保写者至少在一个读者写的时候才会被阻塞，而不是在一个读者写完之后还需要继续等待其他比它到的早的读者。</p>
<h3 id="3-3-哲学家就餐问题"><a href="#3-3-哲学家就餐问题" class="headerlink" title="3.3 哲学家就餐问题"></a>3.3 哲学家就餐问题</h3><ul>
<li>问题描述：五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。</li>
</ul>
<p><img src="/images/note2-2-1719217315316.png" alt="图 11">  </p>
<h4 id="初步设想"><a href="#初步设想" class="headerlink" title="初步设想"></a>初步设想</h4><ul>
<li>我们可以为每个筷子设置一个信号量，表示筷子是否被占用。当一个哲学家需要用筷子时，他会先检查左右两只筷子是否都可用，如果可用，就分别获取左右筷子，然后开始吃饭。吃完后，他会释放左右两只筷子，然后继续思考。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个构想是存在问题的，因为在这种情况下，可能会出现死锁。比如，如果每个哲学家都先拿左边的筷子，再拿右边的筷子，那么他们可能会同时拿到左边的筷子，然后都在等待右边的筷子，从而导致死锁。</p>
<p>这个常用来演示多线程同步（Synchrnization），用来解释死锁和资源耗尽的问题。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>设置一个取筷子的信号量，每个时刻只有一个哲学家可以取筷子。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种解决方案是，破坏死锁的循环等待，让一次只能有4名哲学家坐下，这样就不会形成循环等待的条件，也就构不成死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">semaphore seat = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">Philosopher(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(seat);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        eat();</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i + <span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">        V(seat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-吸烟者问题（补充）"><a href="#3-4-吸烟者问题（补充）" class="headerlink" title="3.4 吸烟者问题（补充）"></a>3.4 吸烟者问题（补充）</h3><ul>
<li>问题描述：有三个吸烟者和一个供应者，吸烟者需要烟草、纸和火柴才能吸烟，供应者有这三种物品。吸烟者循环做着思考和吸烟的动作，供应者循环做着提供三种物品的动作。三个吸烟者分别拥有烟草、纸和火柴，他们需要等待供应者提供其他两种物品。供应者会无限制地提供这三种物品，每次会将其中两种物品放在桌子上，然后唤醒一个拥有对应剩下一种物品的吸烟者来卷起香烟吸烟，该吸烟者吸完后会给供应者发信号，供应者继续提供物品。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">semaphore tobacco = <span class="number">0</span>, paper = <span class="number">0</span>, match = <span class="number">0</span>;</span><br><span class="line">semaphore finished = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 供应者</span></span><br><span class="line">Supplier() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 提供纸和火柴</span></span><br><span class="line">        supply_paper_and_match();</span><br><span class="line">        <span class="comment">// 唤醒有烟草的吸烟者</span></span><br><span class="line">        V(tobacco);</span><br><span class="line">        <span class="comment">// 如果烟草已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">        <span class="comment">// 提供烟草和火柴</span></span><br><span class="line">        supply_tobacco_and_match();</span><br><span class="line">        <span class="comment">// 唤醒有纸的吸烟者</span></span><br><span class="line">        V(paper);</span><br><span class="line">        <span class="comment">// 如果纸已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">        <span class="comment">// 提供烟草和纸</span></span><br><span class="line">        supply_tobacco_and_paper();</span><br><span class="line">        <span class="comment">// 唤醒有火柴的吸烟者</span></span><br><span class="line">        V(match);</span><br><span class="line">        <span class="comment">// 如果火柴已经被消耗</span></span><br><span class="line">        P(finished);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 吸烟者</span></span><br><span class="line">Smoker() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待供应者提供纸和火柴</span></span><br><span class="line">        P(tobacco);</span><br><span class="line">        <span class="comment">// 吸烟</span></span><br><span class="line">        smoke();</span><br><span class="line">        <span class="comment">// 通知供应者</span></span><br><span class="line">        V(finished);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他两个吸烟者类似</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个生产者-消费者问题的变种，我们会发现我们用同步的方式来实现了互斥的访问，也确保了供应者和吸烟者之间的同步。</p>
<p>但是，如果在这一期间存在别的进程，会来干扰我们的桌子上的物品，而它与现有进程不存在同步关系，那么我们显然需要更多的信号量来保证这一点（例如添加一个互斥量来保证每次只有一个人在桌子上操作）。</p>
<h2 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h2><blockquote>
<p>在本部分，我们将介绍管程的概念和实现。</p>
</blockquote>
<h3 id="4-1-管程的概念"><a href="#4-1-管程的概念" class="headerlink" title="4.1 管程的概念"></a>4.1 管程的概念</h3><h4 id="为什么提出管程的概念"><a href="#为什么提出管程的概念" class="headerlink" title="为什么提出管程的概念"></a>为什么提出管程的概念</h4><p>采用P-V同步机制来编写并发程序，对于共享变量及信号量变量的操作将被分散于各个进程中，主要缺点：</p>
<ul>
<li>（１）<strong>易读性差</strong>，因为要了解对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序；</li>
<li>（２）<strong>不利于修改和维护</strong>，因为程序的局部性很差，所以任一组变量或一段代码的修改都可能影响全局；</li>
<li>（３）<strong>正确性难以保证</strong>，因为操作系统或并发程序通常很大，要保证复杂系统没有逻辑错误非常困难。</li>
</ul>
<p>于是，提出用共享数据结构来表示并发程序中的共享数据和对共享数据的操作，这种数据结构称为管程。我们<strong>把分散的临界段集中于管程</strong>，管程中的临界程序一次只能被一个进程执行，这样就避免了多个进程同时访问共享数据的问题。思想与Java中的synchronized类似。</p>
<h4 id="管程的定义与构成"><a href="#管程的定义与构成" class="headerlink" title="管程的定义与构成"></a>管程的定义与构成</h4><ul>
<li><strong>管程</strong>：管程是管理进程间同步的机制，它保证进程互斥地访问共享变量，并且提供了一个方便的阻塞和唤醒进程的机制。它是一种用于并发编程的抽象数据类型，用于管理共享资源和协调多个进程之间的同步和通信。</li>
<li><strong>构成</strong>：共享数据结构；对共享结构操作的一组函数；对数据结构的初始化程序。</li>
<li><strong>特点</strong>：管程的局部变量只能由该管程的过程存取；系统保证进程只能互斥地调用管程中的过程。</li>
</ul>
<h3 id="4-2-管程的实现"><a href="#4-2-管程的实现" class="headerlink" title="4.2 管程的实现"></a>4.2 管程的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor_name &#123;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    shared_data_type shared_data;</span><br><span class="line">    <span class="comment">// 条件变量</span></span><br><span class="line">    condition_variable_type condition_variable;</span><br><span class="line">    <span class="comment">// 本管程内定义的过程名</span></span><br><span class="line">    define some_procedures;</span><br><span class="line">    <span class="comment">// 引用的外部模块的说明</span></span><br><span class="line">    use external_modules;</span><br><span class="line">    <span class="comment">// 过程1</span></span><br><span class="line">    procedure1() &#123;</span><br><span class="line">        <span class="comment">// 过程1的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过程2</span></span><br><span class="line">    procedure2() &#123;</span><br><span class="line">        <span class="comment">// 过程2的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为本管程内共享变量赋初值</span></span><br><span class="line">    initialization() &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如有一个管程定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Monitor  mutexshow &#123; </span><br><span class="line">   boolean busy=<span class="literal">false</span>; <span class="comment">//临界资源是否可用标志</span></span><br><span class="line">   condition nonbusy; <span class="comment">//等待队列的条件变量</span></span><br><span class="line">   define request, release; <span class="comment">//管程中的过程说明</span></span><br><span class="line">   use wait, signal;  <span class="comment">//引用外部模块</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>调用wait()的进程会阻塞在条件变量nonbusy的等待队列上。调用signal()会启动一个阻塞进程，<strong>若无阻塞进程则signal()不起作用</strong>，这也意味着signal()其实与V操作有所不同，它并一定会使信号量增加。</p>
<h4 id="申请管程临界资源"><a href="#申请管程临界资源" class="headerlink" title="申请管程临界资源"></a>申请管程临界资源</h4><ul>
<li><strong>申请管程临界资源</strong>：进程在进入管程时，需要申请管程的临界资源，以确保只有一个进程可以访问共享数据。这通常通过调用管程中的过程来实现，这些过程会对共享数据进行操作，并在操作完成后释放资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (busy) &#123;</span><br><span class="line">        <span class="comment">// 资源忙则在nonbusy等待队列上等待，并立即退出该管程。</span></span><br><span class="line">        wait(nonbusy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请成功，置资源已经占用标志busy为真。</span></span><br><span class="line">    busy = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放管程临界资源"><a href="#释放管程临界资源" class="headerlink" title="释放管程临界资源"></a>释放管程临界资源</h4><ul>
<li><strong>释放管程临界资源</strong>：进程在退出管程时，需要释放管程的临界资源，以便其他进程可以访问共享数据。这通常通过调用管程中的过程来实现，这些过程会对共享数据进行操作，并在操作完成后释放资源。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置资源未占用</span></span><br><span class="line">    busy = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个进程</span></span><br><span class="line">    signal(nonbusy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过上述设置资源未占用的步骤实际上会更为复杂，需要考虑到当前进程是否有设置资源的权限，以及如何唤醒等待队列上的进程等问题。</p>
<h3 id="4-3-管程的应用"><a href="#4-3-管程的应用" class="headerlink" title="4.3 管程的应用"></a>4.3 管程的应用</h3><h4 id="生产者-消费者问题的管程实现"><a href="#生产者-消费者问题的管程实现" class="headerlink" title="生产者&#x2F;消费者问题的管程实现"></a>生产者&#x2F;消费者问题的管程实现</h4><ul>
<li><strong>管程定义</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Monitor  prod_conshow &#123; </span><br><span class="line">    <span class="type">char</span> buffer[n]; <span class="comment">//缓冲区</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//缓冲区中产品数目</span></span><br><span class="line">    <span class="type">int</span> nextempty=<span class="number">0</span>, nextfull=<span class="number">0</span>; <span class="comment">//下一个空缓冲区和满缓冲区</span></span><br><span class="line">    condition notfull, notempty; <span class="comment">//等待队列的条件变量</span></span><br><span class="line">    define produce, consume; <span class="comment">//管程中的过程说明</span></span><br><span class="line">    use <span class="title function_">wait</span><span class="params">()</span>, <span class="title function_">signal</span><span class="params">()</span>;  <span class="comment">//引用外部模块</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>生产者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">produce</span><span class="params">(<span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">        <span class="comment">// 缓冲区已满，等待非满条件</span></span><br><span class="line">        wait(notfull);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[nextempty] = item;</span><br><span class="line">    count=count+<span class="number">1</span>;</span><br><span class="line">    nextempty = (nextempty + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个消费者</span></span><br><span class="line">    signal(notempty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>消费者</strong>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">procedure <span class="title function_">consume</span><span class="params">(<span class="type">char</span> item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 缓冲区为空，等待非空条件</span></span><br><span class="line">        wait(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">    item = buffer[nextfull];</span><br><span class="line">    count = count - <span class="number">1</span>;</span><br><span class="line">    nextfull = (nextfull + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="comment">// 唤醒等待队列上的一个生产者</span></span><br><span class="line">    signal(notfull);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>而在实际的生产者和消费者代码中，我们可以通过调用管程中的过程来实现生产者和消费者的操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Producer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> item = produce_item();</span><br><span class="line">        prod_conshow.produce(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> item;</span><br><span class="line">        prod_conshow.consume(item);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读者-写者问题的管程实现"><a href="#读者-写者问题的管程实现" class="headerlink" title="读者&#x2F;写者问题的管程实现"></a>读者&#x2F;写者问题的管程实现</h4><p>TODO</p>
<h3 id="4-4-管程的特征和与进程的区别"><a href="#4-4-管程的特征和与进程的区别" class="headerlink" title="4.4 管程的特征和与进程的区别"></a>4.4 管程的特征和与进程的区别</h3><h4 id="管程的特征"><a href="#管程的特征" class="headerlink" title="管程的特征"></a>管程的特征</h4><ul>
<li>模块化：一个管程是一个基本程序单位，可以单独编译；</li>
<li>抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码，是对数据和操作的封装。</li>
<li>信息掩蔽：管程如何实现其功能相对于外部程序是半透明的。</li>
</ul>
<h4 id="管程的优点"><a href="#管程的优点" class="headerlink" title="管程的优点"></a>管程的优点</h4><ul>
<li>安全性：共享变量外部不可见，只能由管程中的操作存取</li>
<li>互斥性：管程确保任何一个时刻只能有一个进程进入；</li>
<li>等待机制：设置有等待队列及相应的操作，对资源进行管理。</li>
</ul>
<h4 id="管程与进程的区别"><a href="#管程与进程的区别" class="headerlink" title="管程与进程的区别"></a>管程与进程的区别</h4><ul>
<li>设置目的不同：管程是对共享资源进行管理，进程是资源分配和执行的基本单位。</li>
<li>数据结构不同：管程定义公用数据结构，进程定义私有数据结构。</li>
<li>存在方式不同：进程有生命周期，管程是操作系统固有的部分，没有生命周期。</li>
<li>执行方式不同：管程被进程调用，没有并发性，进程具有并发执行性。</li>
</ul>
<h2 id="5-some-questions"><a href="#5-some-questions" class="headerlink" title="5. some questions"></a>5. some questions</h2><h3 id="5-1-概念相关"><a href="#5-1-概念相关" class="headerlink" title="5.1 概念相关"></a>5.1 概念相关</h3><ol>
<li>进程进入临界区必须满足互斥条件，当进程进入临界区但尚未离开时就被迫进入阻塞是可以的，系统中经常出现这样的情形。在此状态下，只要其他进程在运行过程中不寻求进入该进程的临界区，就应允许其运行，即分配CPU。该进程所锁定的临界区是不允许其他进程访问的，其他进程若要访问，必定会在临界区的“锁”上阻塞，期待该进程下次运行时可以离开并将临界区交给它。</li>
<li>共享程序段可能同时被多个进程使用，所以必须可重入编码，否则无法实现共享的功能。而PCB是进程的控制块，是进程的唯一标识，不可能被多个进程共享，所以不需要可重入编码。</li>
<li>如果两个线程分别对两个不同的互斥锁<strong>先后加锁</strong>，但<strong>顺序相反</strong>，那么可能导致死锁，这是典型的循环等待现象。例如，线程1先对互斥锁A加锁，然后尝试对互斥锁B加锁：同时，线程2先对B加锁，然后尝试对A加锁，两个线程都在等待对方释放资源，从而无法继续推进。而对于一个进程给一个互斥锁加锁但没有解锁，这是不会导致死锁的，因为并没出现循环等待的情况。</li>
<li>管程的<strong>signal</strong>操作与信号量机制中的<strong>V操作</strong>不同，信号量机制中的V操作一定会改变信号量的值S&#x3D;S+1。而管程中的signal操作是针对某个条件变量的，若不存在因该条件而阻塞的进程，则signal不会产生任何影响。</li>
<li>所谓互斥使用某临界资源，是指在同一时间段只允许一个进程使用此资源，所以互斥信号量的初值都为1。即使某个临界资源的容量大于1，也要保证在同一时间段只允许一个进程使用，所以互斥信号量的初值都为1。</li>
<li>进程并发带来问题不仅包括同步互斥问题，而且包括死锁等其他问题。<strong>生产者-消费者问题用于解决进程的同步和互斥问题</strong>。共享一个数据对象仅涉及互斥访问的问题。</li>
<li>在生产者-消费者问题中，每次只能有一个生产者或消费者进入缓冲区，需要用一个<strong>互斥信号量</strong>来控制，当有一个生产者或消费者进入缓冲区时，其他申请进入缓冲区的消费者会被阻塞。对应的，存在满缓冲区和空缓冲区<strong>并非互斥信号量</strong>。</li>
</ol>
<h3 id="5-2-算法设计相关"><a href="#5-2-算法设计相关" class="headerlink" title="5.2 算法设计相关"></a>5.2 算法设计相关</h3><ol>
<li><p>在一个仓库中可以存放A和B两种产品，要求：</p>
<ol>
<li>每次只能存入一种产品。</li>
<li>A产品数量-B产品数量&lt;M,其中M是正整数。</li>
<li>B产品数量-A产品数量&lt;N,其中N是正整数。<br> 假设仓库的容量是无限的，试用P,V操作描述产品A和B的入库过程。</li>
</ol>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count_a = <span class="number">0</span>, count_b = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1 = <span class="number">1</span>, mutex2 = <span class="number">1</span>, mutex3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(mutex1);</span><br><span class="line">            P(mutex2);</span><br><span class="line">            <span class="keyword">if</span> (count_a+<span class="number">1</span>-count_b&lt;M)</span><br><span class="line">            &#123;</span><br><span class="line">                P(mutex3);</span><br><span class="line">                count_a=count_a+<span class="number">1</span>;</span><br><span class="line">                put_a();</span><br><span class="line">                V(mutex3);</span><br><span class="line">            &#125;</span><br><span class="line">            V(mutex2);</span><br><span class="line">            V(mutex1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(mutex2);</span><br><span class="line">            P(mutex1);</span><br><span class="line">            <span class="keyword">if</span> (count_b+<span class="number">1</span>-count_a&lt;N)</span><br><span class="line">            &#123;</span><br><span class="line">                P(mutex3);</span><br><span class="line">                count_b=count_b+<span class="number">1</span>;</span><br><span class="line">                put_b();</span><br><span class="line">                V(mutex3);</span><br><span class="line">            &#125;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            V(mutex2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>

<p> 另一种实现：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore Sa=M<span class="number">-1</span>,Sb=N<span class="number">-1</span>;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Parbegin</span><br><span class="line">    <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(Sa);</span><br><span class="line">            P(mutex);</span><br><span class="line">            put_a();</span><br><span class="line">            V(Sb);</span><br><span class="line">            V(mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            P(Sb);</span><br><span class="line">            P(mutex);</span><br><span class="line">            put_b();</span><br><span class="line">            V(Sa);</span><br><span class="line">            V(mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Parend</span><br></pre></td></tr></table></figure>
</li>
<li><p>面包师有很多面包，由多名销售人员推销。每名顾客进店后按序取一个号，并且等待叫号，当一名销售人员空闲时，就按序叫下一个号。可以用两个整型变量来记录当前的取号值和叫号值，试设计一个使销售人员和顾客同步的算法。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> getnum = <span class="number">0</span>, callnum = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1, mutex2;</span><br><span class="line">semaphore forhead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">seller() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 保证叫到的号已经被取了</span></span><br><span class="line">        P(forhead);</span><br><span class="line">        P(mutex1);</span><br><span class="line">        call();</span><br><span class="line">        callnum++;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        get();</span><br><span class="line">        getnum++;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        V(forhead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 不过上面的算法实际上可以稍微更改一下，不采用forhead量来保证 <code>callnum&lt;getnum</code> ，而是在获得数值之后，再进行判断，同时如果不满足条件可以释放锁，休息片刻，而不是一直让seller忙等待。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> getnum = <span class="number">0</span>, callnum = <span class="number">0</span>;</span><br><span class="line">semaphore mutex1, mutex2;</span><br><span class="line"></span><br><span class="line">seller() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex1);</span><br><span class="line">        <span class="keyword">if</span> (callnum&lt;getnum) &#123;</span><br><span class="line">            call();</span><br><span class="line">            callnum++;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V(mutex1);</span><br><span class="line">            relax();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(mutex2);</span><br><span class="line">        get();</span><br><span class="line">        getnum++;</span><br><span class="line">        P(mutex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某工厂有两个生产车间和一个装配车间，两个生产车间分别生产A,B两种零件，装配车间的任务是把A,B两种零件组装成产品。两个生产车间每生产一个零件后，都要分别把它们送到专配车间的货架F1,F2上。F1存放零件A,F2存放零件B,F1,和F2的容量均可存放10个零件。装配工人每次从货架上取一个零件A和一个零件B后组装成产品。请用PV操作进行正确管理。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore a_full = <span class="number">0</span>, b_full = <span class="number">0</span>;</span><br><span class="line">semaphore a_empty = <span class="number">10</span>, b_empty = <span class="number">10</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">producer_a ()&#123;</span><br><span class="line">    produce_a();</span><br><span class="line">    P(a_empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    put_a();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(a_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer_b ()&#123;</span><br><span class="line">    produce_b();</span><br><span class="line">    P(b_empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">    put_b();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(b_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker ()&#123;</span><br><span class="line">    P(a_full);</span><br><span class="line">    P(b_full);</span><br><span class="line">    P(mutex);</span><br><span class="line">    get_ab();</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(a_empty);</span><br><span class="line">    V(b_empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的过程略有问题，没仔细看题——两个货架，应当采用两个 <code>mutex</code> 。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">semaphore a_full = <span class="number">0</span>, b_full = <span class="number">0</span>;</span><br><span class="line">semaphore a_empty = <span class="number">10</span>, b_empty = <span class="number">10</span>;</span><br><span class="line">semaphore mutex_a = <span class="number">1</span>, mutex_b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">producer_a ()&#123;</span><br><span class="line">    produce_a();</span><br><span class="line">    P(a_empty);</span><br><span class="line">    P(mutex_a);</span><br><span class="line">    put_a();</span><br><span class="line">    V(mutex_a);</span><br><span class="line">    V(a_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer_b ()&#123;</span><br><span class="line">    produce_b();</span><br><span class="line">    P(b_empty);</span><br><span class="line">    P(mutex_b);</span><br><span class="line">    put_b();</span><br><span class="line">    V(mutex_b);</span><br><span class="line">    V(b_full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker ()&#123;</span><br><span class="line">    P(a_full);</span><br><span class="line">    P(mutex_a);</span><br><span class="line">    get_a();</span><br><span class="line">    V(mutex_a);</span><br><span class="line">    V(a_empty);</span><br><span class="line">    P(b_full);</span><br><span class="line">    P(mutex_b);</span><br><span class="line">    get_b();</span><br><span class="line">    V(mutex_b);</span><br><span class="line">    V(b_empty);</span><br><span class="line">    produce();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>某寺庙有小和尚、老和尚若干，有一水缸，由小和尚提水入缸供老和尚饮用。水缸可容 10桶水，水取自同一井中。水井径窄，每次只能容一个桶取水。水桶总数为3个。每次入缸取水仅为1桶水，且不可同时进行。试给出有关从缸取水、入水的算法描述。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    ```</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 如下图所示，三个合作进程P1,P2,P3,它们都需要通过同一设备输入各自的数据a,b,c,该输入设备必须互斥地使用，而且其第一个数据必须由P1进程读取，第二个数据必须由P2进程读取，第三个数据必须由P3进程读取。然后，三个进程分别对输入数据进行下列计算：P1:x=a+b; P2:y=a*b; P3:z=y+c-a;最后，P1进程通过所连接的打印机将计算结果x,y,z的值打印出来。请用信号量实现它们的同步。</span><br><span class="line"></span><br><span class="line">    ![图 <span class="number">12</span>](images/note2<span class="number">-2</span><span class="number">-1719234457173.</span>png)  </span><br><span class="line"></span><br><span class="line">    ```c</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="/img/header.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统笔记3——存储管理</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/22/note2-1/" title="操作系统笔记2——进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统笔记2——进程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/24/note2-3/" title="操作系统笔记2——进程死锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="title">操作系统笔记2——进程死锁</div></div></a></div><div><a href="/2024/06/22/note2-1/" title="操作系统笔记2——进程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-22</div><div class="title">操作系统笔记2——进程</div></div></a></div><div><a href="/2024/06/21/note1/" title="操作系统笔记1——操作系统结构"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-21</div><div class="title">操作系统笔记1——操作系统结构</div></div></a></div><div><a href="/2024/02/15/os-lab-1/" title="os_lab_1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-15</div><div class="title">os_lab_1</div></div></a></div><div><a href="/2024/02/15/6.S081-note-lec1/" title="6.S081-note-lec1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-15</div><div class="title">6.S081-note-lec1</div></div></a></div><div><a href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-24</div><div class="title">操作系统笔记3——存储管理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lee</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lazybearlee"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lazybearlee" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">1.</span> <span class="toc-text">进程并发、同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">1. 进程并发执行的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%9C%80%E6%B1%82"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 并发的需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 并发编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 并发设计语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">并发语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 并发执行实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 进程同步与互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E4%B8%8E%E4%B8%B4%E7%95%8C%E6%AE%B5%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 同步&#x2F;互斥与临界段问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">同步问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%EF%BC%88%E7%8B%AC%E5%8D%A0%E5%9E%8B%E8%B5%84%E6%BA%90%EF%BC%89"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">互斥问题（独占型资源）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98%EF%BC%88%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">互斥问题（共享数据）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E4%BA%A7%E5%93%81%E7%BC%93%E5%86%B2%E9%93%BE%EF%BC%89"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">有限缓冲区的生产者&#x2F;消费者问题（生产者和消费者共享一个产品缓冲链）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E4%B8%B4%E7%95%8C%E6%AE%B5%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 临界段问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2. 进程同步与互斥实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%87%86%E5%88%99"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 并发进程进入临界区需要遵循的四个准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%BA%92%E6%96%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 解决进程之间互斥的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">软件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">实现互斥的软件算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dekker%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">Dekker算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">Peterson算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">硬件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">中断屏蔽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9CTest-and-Set%E2%80%9D%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">“Test_and_Set”指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9CSwap%E2%80%9D%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">“Swap”指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore-%E5%92%8CPV%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 信号量(Semaphore)和PV操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">信号量机制实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">原语的概念与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">屏蔽中断实现的原语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E7%A1%AC%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">加硬锁实现的原语</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">信号量机制的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">信号量机制的应用举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">消除忙等待的信号量机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E6%95%B0%E7%BB%84%E7%9A%84data-1000-%E7%B4%AF%E5%8A%A0"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">用两个线程实现共享数组的data[1000]累加</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3. 进程同步与互斥举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 生产者&#x2F;消费者问题（有限缓冲区）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 读者&#x2F;写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">第一类读者写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">第二类读者写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">举例说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 哲学家就餐问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%BE%E6%83%B3"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">初步设想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 吸烟者问题（补充）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">4. 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 管程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%90%E5%87%BA%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">为什么提出管程的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9E%84%E6%88%90"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">管程的定义与构成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 管程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E7%AE%A1%E7%A8%8B%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">申请管程临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E7%AE%A1%E7%A8%8B%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">释放管程临界资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 管程的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">生产者&#x2F;消费者问题的管程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">读者&#x2F;写者问题的管程实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 管程的特征和与进程的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">管程的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">管程的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">管程与进程的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-some-questions"><span class="toc-number">1.5.</span> <span class="toc-text">5. some questions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 概念相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 算法设计相关</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/note2-3/" title="操作系统笔记2——进程死锁">操作系统笔记2——进程死锁</a><time datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/24/note3-1/" title="操作系统笔记3——存储管理">操作系统笔记3——存储管理</a><time datetime="2024-06-24T13:09:11.000Z" title="发表于 2024-06-24 21:09:11">2024-06-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/23/note2-2/" title="操作系统笔记2——进程并发、同步与互斥">操作系统笔记2——进程并发、同步与互斥</a><time datetime="2024-06-23T12:24:35.000Z" title="发表于 2024-06-23 20:24:35">2024-06-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/22/note2-1/" title="操作系统笔记2——进程">操作系统笔记2——进程</a><time datetime="2024-06-22T07:24:35.000Z" title="发表于 2024-06-22 15:24:35">2024-06-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/21/note1/" title="操作系统笔记1——操作系统结构">操作系统笔记1——操作系统结构</a><time datetime="2024-06-21T13:10:35.000Z" title="发表于 2024-06-21 21:10:35">2024-06-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>